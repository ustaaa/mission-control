<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>Mission Control - MoltBot</title>
    
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#282828">
    <meta name="color-scheme" content="dark">
    <meta name="description" content="Task management dashboard for MoltBot">
    
    <!-- iOS PWA Support -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="MissionCtrl">
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 180 180'><rect fill='%231d2021' width='180' height='180' rx='36'/><text x='90' y='120' font-size='90' text-anchor='middle'>üéõÔ∏è</text></svg>">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.min.js"></script>
    
    <style>
        :root {
            /* Gruvbox Theme (Default) */
            --bg-primary: #1d2021;
            --bg-secondary: #282828;
            --bg-tertiary: #3c3836;
            --bg-card: #32302f;
            --bg-modal: #282828;
            --text-primary: #ebdbb2;
            --text-secondary: #a89984;
            --text-muted: #665c54;
            
            /* Gruvbox Accents */
            --accent: #458588;
            --accent-blue: #458588;
            --accent-green: #98971a;
            --accent-yellow: #d79921;
            --accent-red: #cc241d;
            --accent-purple: #b16286;
            --accent-orange: #d65d0e;
            
            --border: rgba(235, 219, 178, 0.12);
            --border-color: rgba(235, 219, 178, 0.12);
            
            /* Responsive Spacing Scale */
            --space-xs: clamp(0.25rem, 0.5vw, 0.5rem);
            --space-sm: clamp(0.5rem, 1vw, 0.75rem);
            --space-md: clamp(0.75rem, 1.5vw, 1rem);
            --space-lg: clamp(1rem, 2vw, 1.5rem);
            --space-xl: clamp(1.5rem, 3vw, 2rem);
            
            /* Responsive Column Widths */
            --col-min-width: 280px;
            --col-max-width: 400px;
            
            /* Breakpoints */
            --bp-mobile: 640px;
            --bp-tablet: 1024px;
            --bp-desktop: 1440px;
        }
        
        /* ============================================
           THEME SYSTEM - CSS Custom Properties
           ============================================ */
        
        /* Nord Theme - Arctic Blue Palette */
        [data-theme="nord"] {
            --bg-primary: #2e3440;
            --bg-secondary: #3b4252;
            --bg-tertiary: #434c5e;
            --bg-card: #434c5e;
            --bg-modal: #3b4252;
            --text-primary: #eceff4;
            --text-secondary: #d8dee9;
            --text-muted: #4c566a;
            
            --accent: #88c0d0;
            --accent-blue: #88c0d0;
            --accent-green: #a3be8c;
            --accent-yellow: #ebcb8b;
            --accent-red: #bf616a;
            --accent-purple: #b48ead;
            --accent-orange: #d08770;
            
            --border: rgba(216, 222, 233, 0.15);
            --border-color: rgba(216, 222, 233, 0.15);
        }
        
        /* Claude Theme - Anthropic Claude Actual UI (Warm, Earthy) */
        [data-theme="claude"] {
            --bg-primary: #1e1e2e;
            --bg-secondary: #2d2d3a;
            --bg-tertiary: #363642;
            --bg-card: #363642;
            --bg-modal: #2d2d3a;
            --text-primary: #fafafa;
            --text-secondary: #a0a0a0;
            --text-muted: #6b6b7b;
            
            --accent: #d97757;
            --accent-blue: #d97757;
            --accent-green: #7eb77f;
            --accent-yellow: #e5c07b;
            --accent-red: #e06c75;
            --accent-purple: #c678dd;
            --accent-orange: #d97757;
            
            --border: rgba(217, 119, 87, 0.3);
            --border-color: rgba(217, 119, 87, 0.3);
        }
        
        /* OpenCode Theme - Moonrise AI / Purple Accent */
        [data-theme="opencode"] {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --bg-card: #21262d;
            --bg-modal: #161b22;
            --text-primary: #c9d1d9;
            --text-secondary: #8b949e;
            --text-muted: #484f58;
            
            --accent: #a855f7;
            --accent-blue: #a855f7;
            --accent-green: #3fb950;
            --accent-yellow: #d29922;
            --accent-red: #f85149;
            --accent-purple: #a855f7;
            --accent-orange: #db6d28;
            
            --border: rgba(168, 85, 247, 0.3);
            --border-color: rgba(168, 85, 247, 0.3);
        }
        
        /* GNOME Theme - Adwaita Dark */
        [data-theme="gnome"] {
            --bg-primary: #1e1e1e;
            --bg-secondary: #2d2d2d;
            --bg-tertiary: #3d3d3d;
            --bg-card: #3d3d3d;
            --bg-modal: #2d2d2d;
            --text-primary: #ffffff;
            --text-secondary: #b0b0b0;
            --text-muted: #707070;
            
            --accent: #3584e4;
            --accent-blue: #3584e4;
            --accent-green: #33d17a;
            --accent-yellow: #f6d32d;
            --accent-red: #e01b24;
            --accent-purple: #9141ac;
            --accent-orange: #ff7800;
            
            --border: rgba(53, 132, 228, 0.3);
            --border-color: rgba(53, 132, 228, 0.3);
        }
        
        /* Base font size - smaller for Mission Control */
        html {
            font-size: 14px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
        }

        /* Header */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 2rem;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 2rem;
        }

        .logo {
            font-size: 1rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .nav-tabs {
            display: flex;
            gap: 0.5rem;
        }

        .nav-tab {
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            color: var(--text-secondary);
            transition: all 0.2s;
        }

        .nav-tab.active {
            background: var(--bg-card);
            color: var(--text-primary);
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        /* ============================================
           BUTTON HIERARCHY SYSTEM
           ============================================ */
        .btn {
            padding: 0.5rem 1rem;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            font-size: 0.813rem;
            font-weight: 500;
            transition: all 0.15s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            white-space: nowrap;
        }

        .btn svg {
            width: 16px;
            height: 16px;
            stroke-width: 2;
            flex-shrink: 0;
        }

        /* Primary - Main CTA, filled prominent */
        .btn-primary {
            background: var(--accent);
            color: white;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        .btn-primary:hover {
            filter: brightness(1.1);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15);
        }

        /* Secondary - Less prominent, outline style */
        .btn-secondary {
            background: transparent;
            color: var(--text-primary);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--bg-tertiary);
            border-color: var(--text-muted);
        }

        /* Ghost - Minimal, no border */
        .btn-ghost {
            background: transparent;
            color: var(--text-secondary);
            border: none;
            padding: 0.5rem 0.75rem;
        }

        .btn-ghost:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        /* Icon-only button */
        .btn-icon-only {
            background: transparent;
            color: var(--text-secondary);
            border: none;
            padding: 0.5rem;
            border-radius: 6px;
        }

        .btn-icon-only:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .btn-icon-only svg {
            width: 18px;
            height: 18px;
        }

        .btn-github {
            background: #24292e;
            color: white;
        }

        .btn-github:hover {
            background: #1b1f23;
        }

        .btn-danger {
            background: transparent;
            color: var(--accent-red);
            border: 1px solid var(--accent-red);
        }

        .btn-danger:hover {
            background: var(--accent-red);
            color: white;
        }

        .btn-small {
            padding: 0.375rem 0.75rem;
            font-size: 0.75rem;
        }

        .btn-small svg {
            width: 14px;
            height: 14px;
        }

        /* Toolbar grouping */
        .toolbar-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .toolbar-divider {
            width: 1px;
            height: 24px;
            background: var(--border);
            margin: 0 0.5rem;
        }

        .live-indicator {
            display: inline-flex;
            align-items: center;
            gap: 0.375rem;
            padding: 0.375rem 0.75rem;
            border-radius: 9999px;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .live-indicator::before {
            content: '';
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
        }

        .live-indicator.live {
            background: rgba(16, 185, 129, 0.2);
            color: var(--accent-green);
        }

        .live-indicator.stale {
            background: rgba(245, 158, 11, 0.2);
            color: var(--accent-yellow);
        }

        /* User Profile */
        .user-profile {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.375rem 0.75rem;
            background: var(--bg-card);
            border-radius: 6px;
            border: 1px solid var(--border);
        }

        .user-avatar {
            width: 28px;
            height: 28px;
            border-radius: 50%;
        }

        .user-name {
            font-size: 0.875rem;
            font-weight: 500;
        }

        .user-logout {
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .user-logout:hover {
            color: var(--accent-red);
            background: rgba(239, 68, 68, 0.1);
        }

        /* Theme Switcher */
        .theme-switcher {
            position: relative;
            display: flex;
            align-items: center;
        }

        .theme-switcher select {
            appearance: none;
            -webkit-appearance: none;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 0.5rem 2rem 0.5rem 0.75rem;
            color: var(--text-primary);
            font-size: 0.813rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
            min-width: 100px;
        }

        .theme-switcher select:hover {
            border-color: var(--text-muted);
            background: var(--bg-card);
        }

        .theme-switcher select:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 2px rgba(69, 133, 136, 0.15);
        }

        .theme-switcher::after {
            content: '';
            position: absolute;
            right: 0.75rem;
            top: 50%;
            transform: translateY(-50%);
            width: 0;
            height: 0;
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-top: 5px solid var(--text-secondary);
            pointer-events: none;
        }

        /* Stats Bar */
        .stats-bar {
            display: flex;
            gap: 1.5rem;
            padding: 0.875rem 2rem;
            background: var(--bg-primary);
            border-bottom: 1px solid var(--border);
        }

        .stat {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.375rem 0.75rem;
            background: var(--bg-secondary);
            border-radius: 6px;
        }

        .stat-value {
            font-size: 1rem;
            font-weight: 600;
        }

        .stat-label {
            color: var(--text-muted);
            font-size: 0.75rem;
            font-weight: 500;
        }

        .stat-highlight {
            color: var(--accent-green);
        }
        
        /* Hide 0% completion - show dash instead */
        .stat-value.zero-state {
            color: var(--text-muted);
        }

        /* Unsaved Changes Banner */
        .unsaved-banner {
            display: none;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 2rem;
            background: var(--accent-yellow);
            color: #000;
        }

        .unsaved-banner.visible {
            display: flex;
        }

        .unsaved-text {
            font-weight: 500;
        }

        /* Version Update Banner */
        .version-banner {
            display: none;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 2rem;
            background: linear-gradient(90deg, var(--accent-blue), var(--accent-purple));
            color: white;
            animation: versionPulse 2s ease-in-out infinite;
        }

        @keyframes versionPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.85; }
        }

        .version-banner.visible {
            display: flex;
        }

        .version-banner-text {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 500;
        }

        .version-banner-text .update-icon {
            font-size: 1.1rem;
        }

        .version-banner .btn-refresh {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 0.375rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.875rem;
            font-weight: 500;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .version-banner .btn-refresh:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.02);
        }

        .version-banner .btn-dismiss {
            background: transparent;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            cursor: pointer;
            padding: 0.25rem;
            margin-left: 0.5rem;
            font-size: 1.1rem;
            line-height: 1;
            transition: color 0.2s;
        }

        .version-banner .btn-dismiss:hover {
            color: white;
        }

        /* Filters */
        .filters {
            display: flex;
            gap: 0.5rem;
            padding: 1rem 2rem;
            flex-wrap: wrap;
        }

        .filter-btn {
            padding: 0.375rem 0.75rem;
            border-radius: 20px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            color: var(--text-secondary);
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .filter-btn:hover {
            border-color: var(--accent-blue);
        }

        .filter-btn.active {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
            color: white;
        }

        /* Main Layout - Responsive */
        .main {
            display: flex;
            height: calc(100vh - clamp(140px, 15vh, 180px));
            overflow: hidden;
        }

        /* ============================================
           KANBAN BOARD - Fluid Responsive Grid
           ============================================ */
        .kanban {
            flex: 1;
            display: grid;
            /* Truly fluid columns: auto-fill, with smarter min/max */
            grid-template-columns: repeat(auto-fill, minmax(min(100%, 300px), 1fr));
            gap: var(--space-lg);
            padding: var(--space-lg);
            overflow-x: auto;
            overflow-y: hidden;
            align-items: start;
            -webkit-overflow-scrolling: touch;
            scroll-behavior: smooth;
        }
        
        /* Horizontal scroll mode when many columns */
        @container (max-width: 1800px) {
            .kanban {
                grid-template-columns: repeat(8, minmax(280px, 340px));
                grid-auto-flow: column;
                scroll-snap-type: x proximity;
            }
        }

        /* Fallback for browsers without container queries */
        @media (max-width: 1800px) {
            .kanban {
                grid-template-columns: repeat(8, minmax(280px, 340px));
                grid-auto-flow: column;
                scroll-snap-type: x proximity;
            }
        }

        .column {
            min-width: 280px;
            max-width: 400px;
            display: flex;
            flex-direction: column;
            scroll-snap-align: start;
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: var(--space-sm);
        }
        
        /* Wide screens: let columns breathe */
        @media (min-width: 2560px) {
            .kanban {
                grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
                max-width: 3400px;
                margin: 0 auto;
            }
            
            .column {
                max-width: none;
            }
        }

        .column-header {
            display: flex;
            align-items: center;
            gap: 0.625rem;
            padding: 0.75rem 0.5rem;
            margin-bottom: 0.5rem;
            border-bottom: 1px solid var(--border);
        }

        .column-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .column-dot.recurring { background: #06b6d4; }
        .column-dot.permanent { background: var(--accent-purple); }
        .column-dot.scheduled { background: #f97316; }
        .column-dot.templates { background: #8B5CF6; }
        .column-dot.backlog { background: var(--accent-yellow); }
        .column-dot.in-progress { background: var(--accent-blue); }
        .column-dot.review { background: var(--accent-green); }
        .column-dot.done { background: #6b7280; }

        .column-title {
            font-weight: 600;
            font-size: 0.875rem;
            letter-spacing: -0.01em;
        }

        .column-count {
            color: var(--text-muted);
            font-size: 0.75rem;
            font-weight: 500;
            background: var(--bg-tertiary);
            padding: 0.125rem 0.5rem;
            border-radius: 10px;
        }

        .column-add {
            margin-left: auto;
            color: var(--text-muted);
            cursor: pointer;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 6px;
            transition: all 0.15s ease;
            border: 1px solid transparent;
        }

        .column-add svg {
            width: 16px;
            height: 16px;
            stroke-width: 2;
        }

        .column-add:hover {
            background: var(--bg-tertiary);
            color: var(--accent);
            border-color: var(--border);
        }

        .column-add.disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .column-add.disabled:hover {
            background: transparent;
            color: var(--text-muted);
            border-color: transparent;
        }

        .archive-all-btn {
            margin-left: auto;
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-secondary);
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .archive-all-btn:hover {
            background: var(--accent-purple);
            border-color: var(--accent-purple);
            color: white;
        }

        .task-card.archived {
            opacity: 0.6;
            border-left: 3px solid var(--accent-purple);
        }

        .task-card.archived .task-title::before {
            content: 'üì¶ ';
        }

        .archived-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            background: rgba(139, 92, 246, 0.2);
            color: var(--accent-purple);
            padding: 0.125rem 0.375rem;
            border-radius: 4px;
            font-size: 0.65rem;
            font-weight: 500;
        }

        .column-tasks {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            flex: 1;
            padding: 0.25rem;
            padding-bottom: 1rem;
            overflow-y: auto;
            overflow-x: hidden;
            align-items: stretch;
            /* Smooth scrolling */
            scroll-behavior: smooth;
            /* Hide scrollbar but keep functionality */
            scrollbar-width: thin;
            scrollbar-color: var(--bg-tertiary) transparent;
        }
        
        .column-tasks::-webkit-scrollbar {
            width: 4px;
        }
        
        .column-tasks::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .column-tasks::-webkit-scrollbar-thumb {
            background: var(--bg-tertiary);
            border-radius: 2px;
        }
        
        .column-tasks::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }

        /* Task Card */
        .task-card {
            background: var(--bg-card);
            border-radius: 10px;
            padding: 0.875rem;
            cursor: pointer;
            border: 1px solid var(--border);
            /* Subtle shadow for depth */
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
            /* No automatic animation - FLIP handles movement */
            transition: opacity 0.2s, filter 0.2s, box-shadow 0.15s, border-color 0.15s;
            /* Prevent stretching */
            display: block;
            height: auto;
            margin-bottom: 0.625rem;
        }
        
        .task-card:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
            border-color: var(--text-muted);
        }
        
        .task-card.search-dimmed {
            opacity: 0.25;
            filter: grayscale(0.5);
            pointer-events: none;
        }

        /* Cron Cards */
        .cron-card {
            background: var(--bg-card);
            border-radius: 8px;
            padding: 0.875rem;
            border-left: 3px solid #06b6d4;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: transform 0.2s, border-color 0.2s;
        }
        
        .cron-card:hover {
            transform: translateY(-2px);
            border-color: #22d3ee;
        }
        
        .cron-card[draggable="true"] {
            cursor: grab;
        }
        
        .cron-card.dragging {
            opacity: 0.4;
            cursor: grabbing;
        }
        
        /* Template Cards */
        .template-card {
            background: var(--bg-card);
            border-radius: 8px;
            padding: 0.875rem;
            border-left: 3px solid #8B5CF6;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: transform 0.2s, border-color 0.2s;
        }
        
        .template-card:hover {
            transform: translateY(-2px);
            border-color: #a78bfa;
        }
        
        .template-card .template-name {
            font-weight: 500;
            font-size: 0.9rem;
            margin-bottom: 0.25rem;
        }
        
        .template-card .template-description {
            color: var(--text-secondary);
            font-size: 0.8rem;
            margin-bottom: 0.5rem;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        
        .template-card .template-meta {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }
        
        .template-card .execution-count {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            background: rgba(139, 92, 246, 0.15);
            color: #a78bfa;
            padding: 0.125rem 0.5rem;
            border-radius: 4px;
        }
        
        .template-card .template-actions {
            display: flex;
            gap: 0.25rem;
            margin-top: 0.5rem;
        }
        
        .template-card .template-action-btn {
            flex: 1;
            padding: 0.25rem 0.5rem;
            border: none;
            border-radius: 4px;
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.2s;
            background: rgba(139, 92, 246, 0.15);
            color: #a78bfa;
        }
        
        .template-card .template-action-btn:hover {
            background: rgba(139, 92, 246, 0.3);
        }
        
        .template-card .template-action-btn.run {
            background: rgba(16, 185, 129, 0.15);
            color: var(--accent-green);
        }
        
        .template-card .template-action-btn.run:hover {
            background: rgba(16, 185, 129, 0.3);
        }
        
        /* Scheduled Task Cards */
        .scheduled-card {
            background: var(--bg-card);
            border-radius: 8px;
            padding: 0.875rem;
            border-left: 3px solid #f97316;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: transform 0.2s, border-color 0.2s;
        }
        
        .scheduled-card:hover {
            transform: translateY(-2px);
            border-color: #fb923c;
        }
        
        .scheduled-card .scheduled-name {
            font-weight: 500;
            font-size: 0.9rem;
            margin-bottom: 0.25rem;
        }
        
        .scheduled-card .scheduled-time {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.75rem;
            margin-bottom: 0.5rem;
        }
        
        .scheduled-card .countdown {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            background: rgba(249, 115, 22, 0.15);
            color: #fb923c;
            padding: 0.125rem 0.5rem;
            border-radius: 4px;
        }
        
        .scheduled-card .countdown.overdue {
            background: rgba(239, 68, 68, 0.15);
            color: var(--accent-red);
            animation: pulse 1s infinite;
        }
        
        .cron-card .cron-name {
            font-weight: 500;
            font-size: 0.9rem;
            margin-bottom: 0.25rem;
        }
        
        .cron-card .cron-schedule {
            color: var(--text-secondary);
            font-size: 0.8rem;
            margin-bottom: 0.5rem;
        }
        
        .cron-card .cron-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.75rem;
        }
        
        .cron-card .cron-status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }
        
        .cron-card .cron-status-dot.ok { background: var(--accent-green); }
        .cron-card .cron-status-dot.error { background: var(--accent-red); }
        .cron-card .cron-status-dot.disabled { background: var(--text-secondary); }
        .cron-card .cron-status-dot.pending { background: var(--accent-yellow, #f59e0b); animation: pulse 2s infinite; }
        .cron-card .cron-status-dot.running { 
            background: var(--accent-blue);
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }
        
        .cron-card .cron-next {
            color: var(--text-secondary);
            font-size: 0.75rem;
            margin-top: 0.25rem;
        }
        
        /* Search Input */
        .search-container {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .search-input-wrapper {
            position: relative;
            display: inline-block;
        }
        
        .search-input {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 0.5rem 2rem 0.5rem 2.25rem;
            color: var(--text-primary);
            font-size: 0.875rem;
            width: 200px;
            transition: all 0.2s;
        }
        
        .search-input:focus,
        .search-input.expanded {
            outline: none;
            border-color: var(--accent-blue);
            width: 280px;
        }
        
        .search-input::placeholder {
            color: var(--text-secondary);
        }
        
        .search-icon {
            position: absolute;
            left: 0.75rem;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-secondary);
            pointer-events: none;
        }
        
        .search-clear {
            position: absolute;
            right: 0.5rem;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 0.25rem;
            display: none;
            font-size: 1rem;
            line-height: 1;
        }
        
        .search-clear:hover {
            color: var(--text-primary);
        }
        
        .search-input:not(:placeholder-shown) ~ .search-clear {
            display: block;
        }
        
        .search-info {
            font-size: 0.75rem;
            color: var(--text-secondary);
            white-space: nowrap;
        }

        .archive-search-toggle {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.7rem;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            transition: all 0.2s;
            user-select: none;
        }

        .archive-search-toggle:hover {
            background: var(--bg-card);
        }

        .archive-search-toggle input {
            cursor: pointer;
        }

        .archive-search-toggle input:checked + span {
            color: var(--accent-purple);
        }

        .task-card.priority-changed {
            animation: priorityPulse 0.5s ease-out;
        }

        /* Old dragging styles moved to Drag & Drop section below */

        @keyframes priorityPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); box-shadow: 0 0 20px rgba(99, 102, 241, 0.4); }
            100% { transform: scale(1); }
        }

        .task-card.priority-high {
            border-left: 3px solid var(--accent-red);
        }

        .task-card.priority-medium {
            border-left: 3px solid var(--accent-yellow);
        }
        
        .task-card.priority-low {
            border-left: 3px solid var(--accent-green);
        }

        .task-title {
            font-weight: 600;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: flex-start;
            gap: 0.5rem;
            font-size: 0.875rem;
            line-height: 1.4;
            color: var(--text-primary);
        }

        .task-title-text {
            flex: 1;
        }

        .task-description {
            color: var(--text-secondary);
            font-size: 0.8rem;
            margin-bottom: 0.5rem;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            max-height: 2.8em; /* Fallback: ~2 lines at 0.875rem */
            line-height: 1.4;
            white-space: pre-line; /* Respect newlines but wrap */
        }

        .task-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 0.5rem;
        }

        .task-comment-indicator {
            display: flex;
            align-items: center;
            gap: 4px;
            color: var(--text-muted);
            font-size: 0.75rem;
            flex-shrink: 0;
        }

        .task-comment-indicator svg {
            opacity: 0.7;
        }
        
        /* Processing indicator (agent working on task) */
        .task-processing {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 10px;
            margin: 8px 0;
            background: linear-gradient(90deg, rgba(99, 102, 241, 0.15), rgba(59, 130, 246, 0.15));
            border-radius: 6px;
            font-size: 0.75rem;
            color: var(--accent-blue);
            animation: processingPulse 2s ease-in-out infinite;
        }
        
        /* Pulsing border effect on processing task cards */
        .task-card.processing-active {
            border-color: var(--accent-blue) !important;
            box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.4);
            animation: processingBorderPulse 2s ease-in-out infinite;
        }
        
        @keyframes processingBorderPulse {
            0%, 100% { 
                box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.4);
            }
            50% { 
                box-shadow: 0 0 0 8px rgba(59, 130, 246, 0);
            }
        }
        
        /* Timeout warning (30+ minutes) */
        .task-processing.timeout-warning {
            background: linear-gradient(90deg, rgba(245, 158, 11, 0.2), rgba(239, 68, 68, 0.15));
            color: var(--accent-yellow);
        }
        
        .task-card.processing-timeout {
            border-color: var(--accent-red) !important;
            box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.4);
            animation: timeoutBorderPulse 2s ease-in-out infinite;
        }
        
        @keyframes timeoutBorderPulse {
            0%, 100% { 
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.3);
            }
            50% { 
                box-shadow: 0 0 0 6px rgba(239, 68, 68, 0);
            }
        }
        
        .processing-time {
            font-size: 0.7rem;
            opacity: 0.8;
        }
        
        @keyframes processingPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .processing-spinner {
            width: 14px;
            height: 14px;
            border: 2px solid rgba(99, 102, 241, 0.3);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .task-tags {
            display: flex;
            gap: 0.375rem;
            flex-wrap: wrap;
        }

        .task-tag {
            padding: 0.125rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            background: var(--bg-secondary);
            /* Prevent other class rules from affecting tag size */
            min-height: auto !important;
            height: auto !important;
            display: inline-block;
        }

        .task-tag.linkedin { background: #0077b520; color: #0077b5; }
        .task-tag.project-a { background: #10b98120; color: #10b981; }
        .task-tag.project-b { background: #8b5cf620; color: #8b5cf6; }
        .task-tag.system { background: #6b728020; color: #9ca3af; }

        .tag-chip {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            font-size: 0.8rem;
        }
        .tag-chip .tag-remove {
            cursor: pointer;
            opacity: 0.6;
            font-size: 0.9rem;
        }
        .tag-chip .tag-remove:hover {
            opacity: 1;
            color: #ef4444;
        }

        .btn-icon {
            background: none;
            border: none;
            font-size: 1.2rem;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background 0.2s;
        }
        .btn-icon:hover {
            background: var(--bg-secondary);
        }

        .project-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 12px;
            background: var(--bg-secondary);
            border-radius: 8px;
            margin-bottom: 8px;
        }
        .project-item .project-icon {
            font-size: 1.2rem;
        }
        .project-item .project-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
        }
        .project-item .project-name {
            flex: 1;
            font-weight: 500;
        }
        .project-item .project-id {
            color: var(--text-secondary);
            font-size: 0.8rem;
        }
        .project-item .project-actions {
            display: flex;
            gap: 4px;
        }
        .project-item .project-actions button {
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            opacity: 0.6;
        }
        .project-item .project-actions button:hover {
            opacity: 1;
            background: var(--bg-primary);
        }

        .emoji-btn {
            width: 36px;
            height: 36px;
            font-size: 1.2rem;
            border: 1px solid var(--border-color);
            background: var(--bg-secondary);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.15s;
        }
        .emoji-btn:hover {
            background: var(--bg-primary);
            transform: scale(1.1);
        }
        .emoji-btn.selected {
            border-color: var(--accent);
            background: var(--accent);
        }

        .view {
            display: none;
        }
        .view.active {
            display: block;
        }

        .docs-container h2 {
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.5rem;
        }
        .docs-container code {
            background: var(--bg-secondary);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
        }
        .docs-container details {
            background: var(--bg-secondary);
            padding: 1rem;
            border-radius: 8px;
        }
        .docs-container details summary {
            outline: none;
        }

        .task-date {
            color: var(--text-secondary);
            font-size: 0.75rem;
        }

        .task-subtasks {
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px solid var(--border);
        }

        .subtask-progress {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .progress-bar {
            flex: 1;
            height: 4px;
            background: var(--bg-secondary);
            border-radius: 2px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: var(--accent-green);
            transition: width 0.3s;
        }

        /* Subtasks in Modal */
        .subtasks-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
            max-height: 200px;
            overflow-y: auto;
        }

        .subtask-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem;
            background: var(--bg-secondary);
            border-radius: 4px;
        }

        .subtask-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .subtask-item .subtask-title {
            flex: 1;
            font-size: 0.875rem;
        }

        .subtask-item .subtask-title.done {
            text-decoration: line-through;
            color: var(--text-secondary);
        }

        .subtask-item .subtask-delete {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 0.25rem;
            font-size: 1rem;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .subtask-item:hover .subtask-delete {
            opacity: 1;
        }

        .subtask-item .subtask-delete:hover {
            color: var(--accent-red);
        }

        .subtask-add, .comment-add {
            display: flex;
            gap: 0.5rem;
            align-items: flex-start;
        }

        .subtask-add input, .comment-add textarea {
            flex: 1;
        }

        /* Comments in Modal */
        .comments-list {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            margin-bottom: 0.75rem;
            max-height: 200px;
            overflow-y: auto;
        }

        .comment-item {
            padding: 0.75rem;
            background: var(--bg-secondary);
            border-radius: 4px;
        }

        .comment-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.25rem;
        }

        .comment-author {
            font-weight: 500;
            font-size: 0.875rem;
        }

        .comment-time {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .comment-text {
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        /* Task Actions (Review buttons) */
        .task-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px solid var(--border);
        }

        .task-action-btn {
            flex: 1;
            padding: 0.375rem 0.5rem;
            border: none;
            border-radius: 4px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .task-action-btn.done {
            background: rgba(16, 185, 129, 0.2);
            color: var(--accent-green);
        }

        .task-action-btn.done:hover {
            background: rgba(16, 185, 129, 0.4);
        }

        .task-action-btn.backlog {
            background: rgba(245, 158, 11, 0.2);
            color: var(--accent-yellow);
        }

        .task-action-btn.backlog:hover {
            background: rgba(245, 158, 11, 0.4);
        }

        .task-action-btn.archive {
            background: rgba(139, 92, 246, 0.2);
            color: var(--accent-purple);
        }

        .task-action-btn.archive:hover {
            background: rgba(139, 92, 246, 0.4);
        }

        .task-action-btn.unarchive {
            background: rgba(59, 130, 246, 0.2);
            color: var(--accent-blue);
        }

        .task-action-btn.unarchive:hover {
            background: rgba(59, 130, 246, 0.4);
        }

        /* Drag & Drop - Trello-style smooth animations */
        .task-card[draggable="true"] {
            cursor: grab;
            transition: transform 0.2s cubic-bezier(0.2, 0, 0.2, 1),
                        opacity 0.2s ease,
                        margin 0.2s cubic-bezier(0.2, 0, 0.2, 1);
        }

        .task-card.dragging {
            opacity: 0.4;
            cursor: grabbing;
            transform: scale(0.95) rotate(2deg);
            z-index: 1000;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .column-tasks.drag-over {
            background: rgba(59, 130, 246, 0.05);
            border-radius: 8px;
        }

        /* Smooth gap opening for drop target */
        .task-card.make-space-above {
            margin-top: 60px;
        }

        .task-card.make-space-below {
            margin-bottom: 60px;
        }

        /* Visual drop indicator line */
        .drop-indicator {
            height: 3px;
            background: linear-gradient(90deg, var(--accent), var(--accent-blue));
            border-radius: 2px;
            margin: 2px 0;
            opacity: 0;
            transition: opacity 0.15s ease;
            pointer-events: none;
        }

        .drop-indicator.visible {
            opacity: 1;
        }

        /* Empty column drop zone */
        .column-tasks.drag-over:empty::after {
            content: 'Drop here';
            display: block;
            padding: 40px 20px;
            text-align: center;
            color: var(--accent-blue);
            font-size: 0.875rem;
            border: 2px dashed var(--accent-blue);
            border-radius: 8px;
            opacity: 0.7;
        }

        /* Prevent janky transitions during render */
        .column-tasks.no-transition .task-card {
            transition: none !important;
            animation: none !important;
        }

        /* Activity Feed */
        .activity {
            width: 320px;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border);
            padding: 1rem;
            overflow-y: auto;
            transition: all 0.3s ease;
            position: relative;
        }

        .activity.collapsed {
            width: 0;
            padding: 0;
            border-left: none;
            overflow: hidden;
        }

        .activity-toggle {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 4px;
            cursor: pointer;
            color: var(--text-secondary);
            font-size: 0.875rem;
            transition: all 0.2s;
            margin-left: auto;
        }

        .activity-toggle:hover {
            background: var(--border);
            color: var(--text-primary);
        }

        /* Reopen button when collapsed */
        .activity-reopen {
            position: fixed;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 32px;
            height: 80px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-right: none;
            border-radius: 8px 0 0 8px;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
            font-size: 0.75rem;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            z-index: 100;
        }

        .activity-reopen:hover {
            background: var(--bg-card);
            color: var(--text-primary);
        }

        .activity.collapsed ~ .activity-reopen,
        body:has(.activity.collapsed) .activity-reopen {
            display: flex;
        }

        .activity-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--text-secondary);
            font-size: 0.875rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .activity-list {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .activity-item {
            display: flex;
            gap: 0.75rem;
            font-size: 0.875rem;
        }

        .activity-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-top: 0.375rem;
            flex-shrink: 0;
        }

        .activity-dot.created { background: var(--accent-green); }
        .activity-dot.moved { background: var(--accent-blue); }
        .activity-dot.completed { background: var(--accent-purple); }
        .activity-dot.deleted { background: var(--accent-red); }
        .activity-dot.archive { background: var(--accent-purple); }
        .activity-dot.unarchive { background: var(--accent-blue); }

        .activity-content {
            flex: 1;
        }

        .activity-actor {
            font-weight: 500;
        }

        .activity-action {
            color: var(--text-secondary);
        }

        .activity-task {
            color: var(--accent-blue);
        }

        .activity-time {
            color: var(--text-secondary);
            font-size: 0.75rem;
            margin-top: 0.25rem;
        }

        /* Empty State */
        .empty-state {
            color: var(--text-muted);
            text-align: center;
            padding: 2.5rem 1.5rem;
            font-size: 0.813rem;
            background: var(--bg-tertiary);
            border-radius: 8px;
            border: 1px dashed var(--border);
            margin: 0.5rem;
        }

        /* Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-overlay.visible {
            display: flex;
        }

        .modal {
            background: var(--bg-modal);
            border-radius: 12px;
            padding: 2rem;
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            border: 1px solid var(--border);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .modal-title {
            font-size: 1.25rem;
            font-weight: 600;
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.25rem;
            line-height: 1;
        }

        .modal-close:hover {
            color: var(--text-primary);
        }

        .modal-body {
            margin-bottom: 1.5rem;
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 0.75rem;
        }

        /* Form Elements */
        .form-group {
            margin-bottom: 1.25rem;
        }

        .form-label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            font-size: 0.875rem;
        }

        .form-input {
            width: 100%;
            padding: 0.75rem;
            border-radius: 6px;
            border: 1px solid var(--border);
            background: var(--bg-card);
            color: var(--text-primary);
            font-size: 0.875rem;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--accent-blue);
        }

        .form-hint {
            margin-top: 0.5rem;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .form-hint a {
            color: var(--accent-blue);
        }

        /* Steps */
        .steps {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .step {
            display: flex;
            gap: 1rem;
            align-items: flex-start;
        }

        .step-number {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: var(--accent-blue);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.875rem;
            font-weight: 600;
            flex-shrink: 0;
        }

        .step-content {
            flex: 1;
        }

        .step-title {
            font-weight: 500;
            margin-bottom: 0.25rem;
        }

        .step-description {
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        /* Validation States */
        .validation-loading {
            display: none;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.5rem;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .validation-loading.visible {
            display: flex;
        }

        .validation-success {
            display: none;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.5rem;
            font-size: 0.875rem;
            color: var(--accent-green);
        }

        .validation-success.visible {
            display: flex;
        }

        .validation-error {
            display: none;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.5rem;
            font-size: 0.875rem;
            color: var(--accent-red);
        }

        .validation-error.visible {
            display: flex;
        }

        /* Spinner */
        .spinner {
            width: 16px;
            height: 16px;
            border: 2px solid var(--border);
            border-top-color: var(--accent-blue);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Toast */
        .toast-container {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            z-index: 2000;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .toast {
            padding: 1rem 1.5rem;
            border-radius: 8px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            display: flex;
            align-items: center;
            gap: 0.75rem;
            animation: slideIn 0.3s ease;
        }

        .toast.success {
            border-color: var(--accent-green);
        }

        .toast.error {
            border-color: var(--accent-red);
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                gap: 1rem;
                padding: 1rem;
            }

            .header-left {
                flex-direction: column;
                gap: 1rem;
                width: 100%;
            }

            .stats-bar {
                flex-wrap: wrap;
                gap: 1rem;
                padding: 1rem;
            }

            .main {
                flex-direction: column;
                height: auto;
            }

            .kanban {
                padding: 1rem;
                flex-direction: column;
            }

            .column {
                min-width: 100%;
                max-width: 100%;
            }

            .activity {
                width: 100%;
                border-left: none;
                border-top: 1px solid var(--border);
            }
        }

        /* === LOGIN SCREEN === */
        .login-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, var(--bg-primary) 0%, #1a1a2e 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }

        .login-container {
            text-align: center;
            max-width: 480px;
            width: 90%;
        }

        .login-logo {
            font-size: 4rem;
            margin-bottom: 1rem;
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .login-title {
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
        }

        .login-subtitle {
            color: var(--text-secondary);
            margin-bottom: 2rem;
            font-size: 1.1rem;
        }

        .login-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 2rem;
            text-align: left;
        }

        .login-card h2 {
            color: var(--text-primary);
            margin-bottom: 0.5rem;
            font-size: 1.3rem;
        }

        .login-card > p {
            color: var(--text-secondary);
            margin-bottom: 1.5rem;
        }

        .login-steps {
            margin-bottom: 1.5rem;
        }

        .login-step {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            align-items: flex-start;
        }

        .login-step-num {
            background: var(--accent);
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: 600;
            flex-shrink: 0;
        }

        .login-step strong {
            display: block;
            color: var(--text-primary);
            margin-bottom: 2px;
        }

        .login-link {
            color: var(--accent);
            text-decoration: none;
            font-size: 0.9rem;
        }

        .login-link:hover {
            text-decoration: underline;
        }

        .login-hint {
            color: var(--text-muted);
            font-size: 0.85rem;
        }

        .login-form {
            margin-top: 1.5rem;
        }

        .login-input {
            width: 100%;
            padding: 0.875rem 1rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 1rem;
            margin-bottom: 1rem;
            box-sizing: border-box;
        }

        .login-input:focus {
            outline: none;
            border-color: var(--accent);
        }

        .login-btn {
            width: 100%;
            padding: 0.875rem 1.5rem;
            background: #238636;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            transition: background 0.2s;
        }

        .login-btn:hover {
            background: #2ea043;
        }

        .login-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .login-error {
            display: none;
            color: var(--accent-red);
            margin-top: 1rem;
            padding: 0.75rem;
            background: rgba(239, 68, 68, 0.1);
            border-radius: 8px;
            font-size: 0.9rem;
        }

        .login-loading {
            display: none;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            margin-top: 1rem;
            color: var(--text-secondary);
        }

        .login-security {
            margin-top: 1.5rem;
            text-align: center;
            color: var(--text-muted);
            font-size: 0.85rem;
        }

        #dashboard {
            min-height: 100vh;
        }

        /* === PEOPLE / COLLABORATORS === */
        .people-container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 2rem;
        }

        .people-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
        }

        .people-header h1 {
            font-size: 1.75rem;
            font-weight: 600;
        }

        .people-stats {
            display: flex;
            gap: 1rem;
        }

        .people-stat {
            background: var(--bg-card);
            padding: 0.5rem 1rem;
            border-radius: 8px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .people-stat strong {
            color: var(--text-primary);
        }

        .collaborators-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 1rem;
        }

        .collaborator-card {
            background: var(--bg-card);
            border-radius: 12px;
            padding: 1.25rem;
            display: flex;
            align-items: center;
            gap: 1rem;
            transition: all 0.2s;
            border: 1px solid var(--border);
        }

        .collaborator-card:hover {
            border-color: var(--accent-blue);
            transform: translateY(-2px);
        }

        .collaborator-avatar {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid var(--border);
        }

        .collaborator-info {
            flex: 1;
            min-width: 0;
        }

        .collaborator-name {
            font-weight: 600;
            font-size: 1rem;
            margin-bottom: 0.25rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .collaborator-username {
            color: var(--text-secondary);
            font-size: 0.875rem;
            margin-bottom: 0.5rem;
        }

        .collaborator-username a {
            color: var(--text-secondary);
            text-decoration: none;
        }

        .collaborator-username a:hover {
            color: var(--accent-blue);
        }

        .collaborator-role {
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
            padding: 0.25rem 0.6rem;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.02em;
        }

        .role-admin {
            background: rgba(239, 68, 68, 0.15);
            color: #f87171;
        }

        .role-maintain {
            background: rgba(139, 92, 246, 0.15);
            color: #a78bfa;
        }

        .role-write {
            background: rgba(59, 130, 246, 0.15);
            color: #60a5fa;
        }

        .role-triage {
            background: rgba(245, 158, 11, 0.15);
            color: #fbbf24;
        }

        .role-read {
            background: rgba(107, 114, 128, 0.15);
            color: #9ca3af;
        }

        .people-loading {
            text-align: center;
            padding: 4rem 2rem;
            color: var(--text-secondary);
        }

        .people-loading .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--accent-blue);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }

        .people-empty {
            text-align: center;
            padding: 4rem 2rem;
            color: var(--text-secondary);
        }

        .people-empty-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* ============================================
           RESPONSIVE MEDIA QUERIES
           ============================================ */
        
        /* Mobile Column Selector (hidden by default, shown on mobile) */
        .mobile-column-selector {
            display: none;
            padding: var(--space-sm) var(--space-md);
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            position: sticky;
            top: 0;
            z-index: 50;
        }
        
        .mobile-column-selector select {
            width: 100%;
            padding: 0.75rem 1rem;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            appearance: none;
            -webkit-appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='%23a0a0a0'%3E%3Cpath d='M6 9L1 4h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 1rem center;
        }
        
        .mobile-column-selector select:focus {
            outline: none;
            border-color: var(--accent);
        }
        
        .mobile-column-selector .swipe-hint {
            text-align: center;
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-top: 0.5rem;
        }

        /* Mobile: < 640px - Dropdown column selector pattern */
        @media (max-width: 640px) {
            html {
                font-size: 14px;
            }
            
            .header {
                padding: var(--space-sm) var(--space-md);
                flex-wrap: wrap;
                gap: var(--space-sm);
            }
            
            .header-left {
                gap: var(--space-sm);
                width: 100%;
            }
            
            .logo {
                font-size: 1rem;
            }
            
            .nav-tabs {
                width: 100%;
                justify-content: center;
            }
            
            .nav-tab {
                padding: 0.375rem 0.5rem;
                font-size: 0.75rem;
            }
            
            .header-right {
                width: 100%;
                justify-content: center;
                flex-wrap: wrap;
            }
            
            .stats-bar {
                padding: var(--space-sm) var(--space-md);
                gap: var(--space-md);
                flex-wrap: wrap;
                justify-content: center;
            }
            
            .stat-value {
                font-size: 1.25rem;
            }
            
            .filters {
                padding: var(--space-sm);
            }
            
            .main {
                height: auto;
                min-height: calc(100vh - 280px);
                flex-direction: column;
            }
            
            /* Show mobile column selector */
            .mobile-column-selector {
                display: block;
            }
            
            /* Mobile: Single column view with dropdown selector */
            .kanban {
                display: block;
                padding: var(--space-sm);
                overflow-x: hidden;
                overflow-y: auto;
            }
            
            /* Hide all columns by default on mobile */
            .column {
                display: none;
                min-width: 100%;
                max-width: 100%;
            }
            
            /* Show only the active/selected column */
            .column.mobile-active {
                display: flex;
            }
            
            /* Hide column headers on mobile (selector handles this) */
            .column.mobile-active .column-header {
                display: none;
            }
            
            .column.mobile-active .column-tasks {
                padding-top: var(--space-sm);
            }
            
            .task-card {
                padding: var(--space-sm);
            }
            
            .modal-content {
                width: 95vw;
                max-height: 90vh;
            }
            
            .project-grid {
                grid-template-columns: 1fr;
            }
            
            /* Hide theme text on very small screens */
            .theme-switcher .theme-label {
                display: none;
            }
            
            /* Hide activity sidebar on mobile */
            .activity {
                display: none;
            }
            
            .activity-reopen {
                display: none !important;
            }
        }
        
        /* Tablet: 641px - 1024px */
        @media (min-width: 641px) and (max-width: 1024px) {
            html {
                font-size: 15px;
            }
            
            .header {
                padding: var(--space-sm) var(--space-md);
            }
            
            .stats-bar {
                padding: var(--space-sm) var(--space-md);
            }
            
            /* Tablet: Scrollable grid with fixed columns */
            .kanban {
                display: grid;
                grid-template-columns: repeat(8, 300px);
                grid-auto-flow: column;
                gap: var(--space-sm);
                padding: var(--space-sm) var(--space-md);
                scroll-snap-type: x mandatory;
            }
            
            .column {
                min-width: 280px;
                max-width: 320px;
                scroll-snap-align: start;
            }
            
            .modal-content {
                width: 80vw;
                max-width: 700px;
            }
            
            .project-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        /* Desktop: 1025px - 1600px */
        @media (min-width: 1025px) and (max-width: 1600px) {
            .kanban {
                display: grid;
                grid-template-columns: repeat(8, minmax(280px, 320px));
                gap: var(--space-md);
                padding: var(--space-md) var(--space-lg);
            }
            
            .column {
                min-width: 280px;
                max-width: 340px;
            }
            
            .modal-content {
                width: 70vw;
                max-width: 800px;
            }
            
            .project-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }
        
        /* Wide: 1601px - 2559px - Columns can expand */
        @media (min-width: 1601px) and (max-width: 2559px) {
            .kanban {
                display: grid;
                grid-template-columns: repeat(8, minmax(300px, 1fr));
                gap: var(--space-lg);
                padding: var(--space-lg) var(--space-xl);
            }
            
            .column {
                min-width: 300px;
                max-width: 420px;
            }
            
            .modal-content {
                width: 60vw;
                max-width: 900px;
            }
            
            .project-grid {
                grid-template-columns: repeat(4, 1fr);
            }
            
            .container {
                max-width: 1800px;
                margin: 0 auto;
            }
        }
        
        /* Touch Device Optimizations */
        @media (pointer: coarse) {
            .task-card,
            .btn,
            .filter-btn,
            .nav-tab {
                min-height: 44px;
                min-width: 44px;
            }
            
            .column-add {
                width: 44px;
                height: 44px;
            }
            
            .kanban {
                scroll-snap-type: x mandatory;
            }
            
            .column {
                scroll-snap-align: start;
            }
        }
        
        /* Reduced Motion */
        @media (prefers-reduced-motion: reduce) {
            *,
            *::before,
            *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
        
        /* Dark Mode (System Preference) */
        @media (prefers-color-scheme: light) {
            /* Mission Control is dark-mode only, but we could add light theme here */
        }
        
        /* Print Styles */
        @media print {
            .header,
            .filters,
            .column-add,
            .btn {
                display: none !important;
            }
            
            .kanban {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
                gap: 1rem;
                overflow: visible;
            }
            
            .column {
                break-inside: avoid;
                page-break-inside: avoid;
            }
            
            body {
                background: white;
                color: black;
            }
        }

        /* Voice Recording Styles */
        .voice-mic-btn {
            background: transparent;
            border: none;
            cursor: pointer;
            font-size: 1rem;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s;
            color: var(--text-secondary);
            margin-left: 4px;
        }
        
        .voice-mic-btn:hover {
            background: var(--bg-card);
            color: var(--accent-blue);
            transform: scale(1.1);
        }
        
        .voice-mic-btn.recording {
            color: var(--accent-red);
            animation: micPulse 1s ease-in-out infinite;
        }
        
        @keyframes micPulse {
            0%, 100% { 
                transform: scale(1);
                opacity: 1;
            }
            50% { 
                transform: scale(1.15);
                opacity: 0.8;
            }
        }
        
        .recording-indicator {
            display: none;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: rgba(204, 36, 29, 0.15);
            border: 1px solid var(--accent-red);
            border-radius: 8px;
            margin-bottom: 12px;
            font-size: 0.875rem;
            color: var(--accent-red);
        }
        
        .recording-indicator.active {
            display: flex;
        }
        
        .recording-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--accent-red);
            animation: recordingPulse 1s ease-in-out infinite;
        }
        
        @keyframes recordingPulse {
            0%, 100% { 
                opacity: 1;
                box-shadow: 0 0 0 0 rgba(204, 36, 29, 0.5);
            }
            50% { 
                opacity: 0.6;
                box-shadow: 0 0 8px 4px rgba(204, 36, 29, 0.3);
            }
        }
        
        .voice-transcript {
            margin-top: 8px;
            padding: 8px 12px;
            background: var(--bg-secondary);
            border-radius: 6px;
            font-style: italic;
            color: var(--text-secondary);
            min-height: 40px;
        }
        
        .voice-transcript.has-text {
            color: var(--text-primary);
            font-style: normal;
        }
        
        .voice-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        
        .voice-modal-overlay.visible {
            display: flex;
        }
        
        .voice-modal {
            background: var(--bg-modal);
            border-radius: 16px;
            padding: 2rem;
            max-width: 400px;
            width: 90%;
            text-align: center;
            border: 1px solid var(--border);
        }
        
        .voice-modal-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }
        
        .voice-modal-icon.recording {
            animation: micPulse 1s ease-in-out infinite;
        }
        
        .voice-modal-status {
            font-size: 1.1rem;
            margin-bottom: 1rem;
            color: var(--text-primary);
        }
        
        .voice-modal-hint {
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-bottom: 1.5rem;
        }
        
        .voice-modal-transcript {
            background: var(--bg-secondary);
            padding: 1rem;
            border-radius: 8px;
            min-height: 60px;
            margin-bottom: 1rem;
            font-size: 1rem;
            color: var(--text-primary);
        }
        
        .voice-modal-buttons {
            display: flex;
            gap: 0.75rem;
            justify-content: center;
        }

        /* Voice Note Styles */
        .voice-note-btn {
            background: transparent;
            border: none;
            cursor: pointer;
            font-size: 0.85rem;
            padding: 4px 6px;
            border-radius: 4px;
            transition: all 0.2s;
            color: var(--text-secondary);
            opacity: 0.6;
        }
        
        .voice-note-btn:hover {
            background: var(--bg-secondary);
            color: var(--accent-blue);
            opacity: 1;
        }
        
        .voice-memo-btn {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-secondary);
            padding: 0.375rem 0.75rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.875rem;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 0.375rem;
        }
        
        .voice-memo-btn:hover {
            background: var(--bg-card);
            color: var(--accent-blue);
            border-color: var(--accent-blue);
        }
        
        /* Voice Note Recording Modal */
        .voice-note-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        
        .voice-note-modal-overlay.visible {
            display: flex;
        }
        
        .voice-note-modal {
            background: var(--bg-modal);
            border-radius: 16px;
            padding: 2rem;
            max-width: 400px;
            width: 90%;
            text-align: center;
            border: 1px solid var(--border);
        }
        
        .voice-note-modal-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }
        
        .voice-note-modal-subtitle {
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-bottom: 1.5rem;
        }
        
        .voice-note-record-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        
        .voice-note-record-btn {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: 3px solid var(--border);
            background: var(--bg-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            transition: all 0.2s;
        }
        
        .voice-note-record-btn:hover {
            border-color: var(--accent-red);
            transform: scale(1.05);
        }
        
        .voice-note-record-btn.recording {
            background: rgba(204, 36, 29, 0.15);
            border-color: var(--accent-red);
            animation: recordPulse 1.5s ease-in-out infinite;
        }
        
        @keyframes recordPulse {
            0%, 100% { 
                box-shadow: 0 0 0 0 rgba(204, 36, 29, 0.4);
            }
            50% { 
                box-shadow: 0 0 0 15px rgba(204, 36, 29, 0);
            }
        }
        
        .voice-note-timer {
            font-size: 1.5rem;
            font-weight: 500;
            font-family: monospace;
            color: var(--text-primary);
        }
        
        .voice-note-timer.recording {
            color: var(--accent-red);
        }
        
        .voice-note-waveform {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 3px;
            height: 40px;
        }
        
        .voice-note-waveform .bar {
            width: 4px;
            background: var(--accent-blue);
            border-radius: 2px;
            height: 10px;
            transition: height 0.1s;
        }
        
        .voice-note-waveform.recording .bar {
            animation: waveformBounce 0.5s ease-in-out infinite;
        }
        
        .voice-note-waveform .bar:nth-child(1) { animation-delay: 0s; }
        .voice-note-waveform .bar:nth-child(2) { animation-delay: 0.1s; }
        .voice-note-waveform .bar:nth-child(3) { animation-delay: 0.2s; }
        .voice-note-waveform .bar:nth-child(4) { animation-delay: 0.3s; }
        .voice-note-waveform .bar:nth-child(5) { animation-delay: 0.4s; }
        .voice-note-waveform .bar:nth-child(6) { animation-delay: 0.35s; }
        .voice-note-waveform .bar:nth-child(7) { animation-delay: 0.25s; }
        .voice-note-waveform .bar:nth-child(8) { animation-delay: 0.15s; }
        
        @keyframes waveformBounce {
            0%, 100% { height: 10px; }
            50% { height: 35px; }
        }
        
        /* Voice Note Playback Controls */
        .voice-note-playback {
            display: none;
            flex-direction: column;
            gap: 1rem;
            padding: 1rem;
            background: var(--bg-secondary);
            border-radius: 8px;
            margin-bottom: 1rem;
        }
        
        .voice-note-playback.visible {
            display: flex;
        }
        
        .voice-note-playback-controls {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        
        .voice-note-play-btn {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            border: none;
            background: var(--accent-blue);
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            transition: all 0.2s;
        }
        
        .voice-note-play-btn:hover {
            transform: scale(1.05);
            background: #2563eb;
        }
        
        .voice-note-progress {
            flex: 1;
            height: 6px;
            background: var(--bg-tertiary);
            border-radius: 3px;
            overflow: hidden;
            cursor: pointer;
        }
        
        .voice-note-progress-fill {
            height: 100%;
            background: var(--accent-blue);
            width: 0%;
            transition: width 0.1s linear;
        }
        
        .voice-note-duration {
            font-size: 0.8rem;
            color: var(--text-secondary);
            font-family: monospace;
            min-width: 45px;
        }
        
        .voice-note-transcript-preview {
            font-size: 0.85rem;
            color: var(--text-secondary);
            font-style: italic;
            padding: 0.5rem;
            background: var(--bg-tertiary);
            border-radius: 4px;
            text-align: left;
        }
        
        .voice-note-modal-buttons {
            display: flex;
            gap: 0.75rem;
            justify-content: center;
        }
        
        /* Voice Note Player in Comments */
        .voice-note-comment {
            padding: 0.75rem;
            background: var(--bg-secondary);
            border-radius: 8px;
            border-left: 3px solid var(--accent-blue);
        }
        
        .voice-note-comment-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        
        .voice-note-comment-label {
            font-size: 0.8rem;
            font-weight: 500;
            color: var(--accent-blue);
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }
        
        .voice-note-comment-time {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }
        
        .voice-note-player {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem;
            background: var(--bg-tertiary);
            border-radius: 6px;
            margin-bottom: 0.5rem;
        }
        
        .voice-note-player-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: none;
            background: var(--accent-blue);
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
            transition: all 0.2s;
            flex-shrink: 0;
        }
        
        .voice-note-player-btn:hover {
            transform: scale(1.05);
        }
        
        .voice-note-player-progress {
            flex: 1;
            height: 4px;
            background: var(--bg-primary);
            border-radius: 2px;
            overflow: hidden;
            cursor: pointer;
        }
        
        .voice-note-player-progress-fill {
            height: 100%;
            background: var(--accent-blue);
            width: 0%;
            transition: width 0.1s linear;
        }
        
        .voice-note-player-duration {
            font-size: 0.7rem;
            color: var(--text-secondary);
            font-family: monospace;
            min-width: 36px;
            text-align: right;
        }
        
        .voice-note-transcript {
            font-size: 0.8rem;
            color: var(--text-secondary);
            font-style: italic;
        }

        /* ============================================
           NOTES + DIGITAL PEN STYLES
           ============================================ */
        
        /* Notes Container */
        .notes-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 1.5rem;
            height: calc(100vh - 140px);
            display: flex;
            flex-direction: column;
        }

        .notes-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .notes-header h1 {
            font-size: 1.5rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .notes-actions {
            display: flex;
            gap: 0.75rem;
        }

        /* Notes Grid (List View) */
        .notes-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 1rem;
            overflow-y: auto;
            flex: 1;
            padding-bottom: 1rem;
        }

        .note-card {
            background: var(--bg-card);
            border-radius: 12px;
            border: 1px solid var(--border);
            overflow: hidden;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
        }

        .note-card:hover {
            border-color: var(--accent);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .note-card-thumbnail {
            width: 100%;
            height: 140px;
            background: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .note-card-thumbnail.dark {
            background: #1a1a1a;
        }

        .note-card-thumbnail.lined {
            background: 
                linear-gradient(#f0f0f0 1px, transparent 1px);
            background-size: 100% 24px;
            background-color: #fff;
        }

        .note-card-thumbnail.grid {
            background: 
                radial-gradient(circle, #ccc 1px, transparent 1px);
            background-size: 20px 20px;
            background-color: #fff;
        }

        .note-card-thumbnail canvas {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .note-card-thumbnail .empty-note {
            color: var(--text-muted);
            font-size: 2rem;
        }

        .note-card-info {
            padding: 0.75rem;
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .note-card-title {
            font-weight: 500;
            font-size: 0.9rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .note-card-date {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .note-card-delete {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background: rgba(0, 0, 0, 0.5);
            border: none;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s;
            font-size: 0.75rem;
        }

        .note-card:hover .note-card-delete {
            opacity: 1;
        }

        .note-card-delete:hover {
            background: var(--accent-red);
        }

        /* New Note Card */
        .note-card.new-note {
            border: 2px dashed var(--border);
            background: transparent;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 200px;
        }

        .note-card.new-note:hover {
            border-color: var(--accent);
            background: rgba(69, 133, 136, 0.1);
        }

        .new-note-content {
            text-align: center;
            color: var(--text-secondary);
        }

        .new-note-content .icon {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
        }

        /* Notes Editor View */
        .notes-editor {
            display: none;
            flex-direction: column;
            height: 100%;
            background: var(--bg-secondary);
            border-radius: 12px;
            overflow: hidden;
        }

        .notes-editor.active {
            display: flex;
        }

        .notes-list.hidden {
            display: none;
        }

        /* Editor Toolbar */
        .notes-toolbar {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1rem;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border);
            flex-wrap: wrap;
        }

        .notes-toolbar-group {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            padding-right: 0.75rem;
            border-right: 1px solid var(--border);
        }

        .notes-toolbar-group:last-child {
            border-right: none;
        }

        .notes-tool-btn {
            width: 36px;
            height: 36px;
            border: 1px solid var(--border);
            border-radius: 6px;
            background: var(--bg-card);
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            transition: all 0.15s;
        }

        .notes-tool-btn:hover {
            background: var(--bg-secondary);
            border-color: var(--accent);
        }

        .notes-tool-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }

        .notes-tool-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        /* Color Picker */
        .notes-color-btn {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.15s;
        }

        .notes-color-btn:hover {
            transform: scale(1.1);
        }

        .notes-color-btn.active {
            border-color: var(--text-primary);
            box-shadow: 0 0 0 2px var(--bg-secondary);
        }

        /* Width Slider */
        .notes-width-slider {
            width: 100px;
            height: 6px;
            border-radius: 3px;
            background: var(--bg-card);
            -webkit-appearance: none;
            appearance: none;
            cursor: pointer;
        }

        .notes-width-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
        }

        .notes-width-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            border: none;
        }

        .notes-width-value {
            font-size: 0.75rem;
            color: var(--text-secondary);
            min-width: 32px;
            text-align: center;
        }

        /* Background Selector */
        .notes-bg-select {
            padding: 0.375rem 0.75rem;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 0.8rem;
            cursor: pointer;
        }

        .notes-bg-select:focus {
            outline: none;
            border-color: var(--accent);
        }

        /* Note Title Input */
        .notes-title-input {
            flex: 1;
            max-width: 300px;
            padding: 0.5rem 0.75rem;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 0.9rem;
        }

        .notes-title-input:focus {
            outline: none;
            border-color: var(--accent);
        }

        /* Canvas Container */
        .notes-canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: #fff;
            touch-action: none;
        }

        .notes-canvas-container.dark {
            background: #1a1a1a;
        }

        .notes-canvas-container.lined {
            background: 
                linear-gradient(#e5e5e5 1px, transparent 1px);
            background-size: 100% 28px;
            background-color: #fff;
        }

        .notes-canvas-container.grid {
            background: 
                radial-gradient(circle, #ddd 1px, transparent 1px);
            background-size: 24px 24px;
            background-color: #fff;
        }

        .notes-canvas {
            position: absolute;
            top: 0;
            left: 0;
            touch-action: none;
            cursor: crosshair;
        }

        /* Fullscreen Mode */
        .notes-container.fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            max-width: none;
            height: 100vh;
            padding: 0;
            z-index: 2000;
            background: var(--bg-primary);
        }

        .notes-container.fullscreen .notes-header {
            display: none;
        }

        .notes-container.fullscreen .notes-toolbar {
            border-radius: 0;
        }

        /* Mobile Notes */
        @media (max-width: 640px) {
            .notes-toolbar {
                padding: 0.5rem;
                gap: 0.25rem;
            }

            .notes-toolbar-group {
                padding-right: 0.5rem;
            }

            .notes-tool-btn {
                width: 40px;
                height: 40px;
            }

            .notes-color-btn {
                width: 32px;
                height: 32px;
            }

            .notes-width-slider {
                width: 80px;
            }

            .notes-title-input {
                max-width: 150px;
            }

            .notes-grid {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            }
        }

        /* Chat Widget Styles */
        .chat-widget {
            position: fixed;
            bottom: var(--space-lg);
            right: var(--space-lg);
            width: clamp(300px, 35vw, 400px);
            max-height: 500px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            z-index: 1000;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            transition: transform 0.3s ease;
        }

        .chat-widget.collapsed {
            transform: translateY(calc(100% - 44px));
        }

        .chat-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--space-sm) var(--space-md);
            background: var(--accent-blue);
            border-radius: 12px 12px 0 0;
            cursor: pointer;
            font-weight: 500;
            color: white;
            user-select: none;
        }

        .chat-header:hover {
            background: #2563eb;
        }

        .chat-body {
            display: flex;
            flex-direction: column;
            height: 400px;
            overflow: hidden;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: var(--space-md);
            display: flex;
            flex-direction: column;
            gap: var(--space-sm);
        }

        .chat-message {
            max-width: 85%;
            padding: var(--space-sm) var(--space-md);
            border-radius: 12px;
            font-size: 0.875rem;
            line-height: 1.4;
            word-wrap: break-word;
        }

        .chat-message.user {
            align-self: flex-end;
            background: var(--accent-blue);
            color: white;
            border-bottom-right-radius: 4px;
        }

        .chat-message.bot {
            align-self: flex-start;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-bottom-left-radius: 4px;
        }

        .chat-message.typing {
            opacity: 0.7;
            font-style: italic;
        }

        .chat-input-area {
            display: flex;
            gap: var(--space-sm);
            padding: var(--space-sm) var(--space-md);
            border-top: 1px solid var(--border);
            background: var(--bg-card);
        }

        .chat-input-area input {
            flex: 1;
            padding: var(--space-sm) var(--space-md);
            border: 1px solid var(--border);
            border-radius: 20px;
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: 0.875rem;
            outline: none;
        }

        .chat-input-area input:focus {
            border-color: var(--accent-blue);
        }

        .chat-input-area button {
            width: 36px;
            height: 36px;
            border: none;
            border-radius: 50%;
            background: var(--accent-blue);
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            transition: background 0.2s;
        }

        .chat-input-area button:hover {
            background: #2563eb;
        }

        /* Mobile chat adjustments */
        @media (max-width: 640px) {
            .chat-widget {
                width: calc(100vw - 2rem);
                right: var(--space-md);
                bottom: var(--space-md);
                max-height: 60vh;
            }
            
            .chat-body {
                height: 50vh;
            }
        }

        @media (max-width: 1024px) {
            .chat-widget.collapsed {
                transform: translateY(calc(100% - 48px));
            }
        }
    </style>
</head>
<body>
    <!-- Chat Widget -->
    <div id="chat-widget" class="chat-widget">
        <div class="chat-header" onclick="toggleChat()">
            <span>üí¨ Nomura</span>
            <span id="chat-toggle">‚ñº</span>
        </div>
        <div id="chat-body" class="chat-body">
            <div id="chat-messages" class="chat-messages"></div>
            <div class="chat-input-area">
                <input type="text" id="chat-input" placeholder="Ask Nomura..." onkeypress="handleChatKey(event)">
                <button onclick="sendChatMessage()">‚û§</button>
            </div>
        </div>
    </div>
    <!-- Login Required Screen (shown when not authenticated) -->
    <div id="login-screen" class="login-screen">
        <div class="login-container">
            <div class="login-logo">üéØ</div>
            <h1 class="login-title">Mission Control</h1>
            <p class="login-subtitle">Task & Project Management Dashboard</p>

            <div class="login-card">
                <h2>üîê Login Required</h2>
                <p>Connect your GitHub account to access the dashboard.</p>

                <div class="login-steps">
                    <div class="login-step">
                        <span class="login-step-num">1</span>
                        <div>
                            <strong>Create a Personal Access Token</strong>
                            <a href="https://github.com/settings/tokens/new?scopes=repo&description=Mission%20Control%20Dashboard" target="_blank" class="login-link">
                                Create token on GitHub ‚Üí
                            </a>
                        </div>
                    </div>
                    <div class="login-step">
                        <span class="login-step-num">2</span>
                        <div>
                            <strong>Select "repo" scope</strong>
                            <span class="login-hint">Allows read/write access to repositories</span>
                        </div>
                    </div>
                    <div class="login-step">
                        <span class="login-step-num">3</span>
                        <div>
                            <strong>Paste your token below</strong>
                            <span class="login-hint">Starts with "ghp_"</span>
                        </div>
                    </div>
                </div>

                <div class="login-form">
                    <input type="password" id="login-token-input" class="login-input" placeholder="ghp_xxxxxxxxxxxxxxxxxxxx" autocomplete="off">
                    <button id="login-btn" class="login-btn" onclick="handleLogin()">
                        <svg width="20" height="20" viewBox="0 0 16 16" fill="currentColor">
                            <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/>
                        </svg>
                        Connect with GitHub
                    </button>
                    <div id="login-error" class="login-error"></div>
                    <div id="login-loading" class="login-loading">
                        <div class="spinner"></div>
                        <span>Validating...</span>
                    </div>
                </div>

                <p class="login-security">üîí Your token is stored locally and never sent anywhere except GitHub.</p>
            </div>
        </div>
    </div>

    <!-- Main Dashboard (hidden until authenticated) -->
    <div id="dashboard" class="dashboard" style="display: none;">

    <header class="header">
        <div class="header-left">
            <div class="logo">
                <span>üéØ</span>
                <span>Mission Control</span>
            </div>
            <nav class="nav-tabs">
                <div class="nav-tab active" data-view="tasks" onclick="switchView('tasks')">Tasks</div>
                <div class="nav-tab" data-view="todo" onclick="switchView('todo')">Todo</div>
                <div class="nav-tab" data-view="notes" onclick="switchView('notes')">üìù Notes</div>
                <div class="nav-tab" data-view="docs" onclick="switchView('docs')">Docs</div>
                <div class="nav-tab" data-view="people" onclick="switchView('people')">People</div>
            </nav>
            
            <!-- Search -->
            <div class="search-container">
                <div class="search-input-wrapper">
                    <input type="text" 
                           id="search-input" 
                           class="search-input" 
                           placeholder="Search tasks..." 
                           oninput="handleSearch(this.value)"
                           onkeydown="if(event.key==='Escape'){clearSearch()}">
                    <svg class="search-icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="11" cy="11" r="8"></circle>
                        <path d="M21 21l-4.35-4.35"></path>
                    </svg>
                    <button class="search-clear" onmousedown="event.preventDefault()" onclick="clearSearch()" title="Clear search">√ó</button>
                </div>
                <span class="search-info" id="search-info"></span>
                <label class="archive-search-toggle" title="Include archived tasks in search">
                    <input type="checkbox" id="search-include-archived" onchange="toggleArchiveSearch(this.checked)">
                    <span>üì¶ Archive</span>
                </label>
            </div>
        </div>
        <div class="header-right">
            <!-- Status Group -->
            <div class="toolbar-group">
                <span class="live-indicator live" id="live-indicator">Live</span>
            </div>
            
            <div class="toolbar-divider"></div>
            
            <!-- Actions Group -->
            <div class="toolbar-group">
                <button class="btn btn-ghost" onclick="pollForUpdates(); window.location.reload()" title="Refresh">
                    <i data-lucide="refresh-cw"></i>
                    <span>Refresh</span>
                </button>
                <button class="btn btn-secondary" onclick="openVoiceNoteModal(null)" title="Record a voice memo">
                    <i data-lucide="mic"></i>
                    <span>Voice Memo</span>
                </button>
            </div>

            <div class="toolbar-divider"></div>
            
            <!-- Settings Group -->
            <div class="toolbar-group">
                <div class="theme-switcher">
                    <select id="theme-select" onchange="setTheme(this.value)" aria-label="Select theme">
                        <option value="gruvbox">Gruvbox</option>
                        <option value="nord">Nord</option>
                        <option value="claude">Claude</option>
                        <option value="opencode">OpenCode</option>
                        <option value="gnome">GNOME</option>
                    </select>
                </div>
            </div>
            
            <div class="toolbar-divider"></div>

            <!-- Auth Group -->
            <div class="toolbar-group">
                <!-- Not Logged In -->
                <button class="btn btn-github" id="btn-connect" onclick="showAuthModal()">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                        <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/>
                    </svg>
                    <span>local</span>
                </button>

                <!-- Logged In (hidden by default) -->
                <div class="user-profile" id="user-profile" style="display: none;">
                    <img class="user-avatar" id="user-avatar" src="" alt="Avatar">
                    <span class="user-name" id="user-name"></span>
                    <button class="btn-icon-only" onclick="showSettingsModal()" title="Settings">
                        <i data-lucide="settings"></i>
                    </button>
                    <span class="user-logout" onclick="logout()">Logout</span>
                </div>
            </div>
        </div>
    </header>

    <!-- Version Update Banner -->
    <div class="version-banner" id="version-banner">
        <div class="version-banner-text">
            <span class="update-icon">üîÑ</span>
            Neue Version verf√ºgbar!
        </div>
        <div>
            <button class="btn-refresh" onclick="reloadPage()">‚Üª Aktualisieren</button>
            <button class="btn-dismiss" onclick="dismissVersionBanner()">‚úï</button>
        </div>
    </div>

    <!-- Unsaved Changes Banner -->
    <div class="unsaved-banner" id="unsaved-banner">
        <span class="unsaved-text">‚ö†Ô∏è You have unsaved changes</span>
        <div>
            <button class="btn btn-secondary btn-small" onclick="discardChanges()">Discard</button>
            <button class="btn btn-primary btn-small" onclick="showCommitModal()">Save & Commit</button>
        </div>
    </div>

    <!-- TASKS VIEW -->
    <div id="view-tasks" class="view active">

    <div class="stats-bar">
        <div class="stat">
            <span class="stat-value" id="stat-week">0</span>
            <span class="stat-label">This week</span>
        </div>
        <div class="stat">
            <span class="stat-value" id="stat-progress">0</span>
            <span class="stat-label">In progress</span>
        </div>
        <div class="stat">
            <span class="stat-value" id="stat-total">0</span>
            <span class="stat-label">Total</span>
        </div>
        <div class="stat">
            <span class="stat-value stat-highlight" id="stat-completion">0%</span>
            <span class="stat-label">Completion</span>
        </div>
    </div>

    <div class="filters" id="filters">
        <button class="filter-btn active" data-filter="all">All projects</button>
    </div>

    <!-- Mobile Column Selector (hidden on desktop) -->
    <div class="mobile-column-selector" id="mobile-column-selector">
        <select id="mobile-column-select" onchange="selectMobileColumn(this.value)">
            <option value="recurring">üîÑ Recurring</option>
            <option value="scheduled">üìÖ Scheduled</option>
            <option value="templates">üìë Templates</option>
            <option value="permanent">üü£ Permanent</option>
            <option value="backlog" selected>üìã Backlog</option>
            <option value="in_progress">üöÄ In Progress</option>
            <option value="review">üëÄ Review</option>
            <option value="done">‚úÖ Done</option>
        </select>
        <div class="swipe-hint">Swipe left/right to change columns</div>
    </div>

    <main class="main">
        <div class="kanban" id="kanban-board">
            <div class="column column-recurring" data-column="recurring">
                <div class="column-header">
                    <div class="column-dot recurring"></div>
                    <span class="column-title">Recurring</span>
                    <span class="column-count" id="count-recurring">0</span>
                </div>
                <div class="column-tasks" id="tasks-recurring" ondragover="handleCronDragOver(event)" ondragleave="handleCronDragLeave(event)" ondrop="handleCronDrop(event)"></div>
            </div>

            <div class="column column-scheduled" data-column="scheduled">
                <div class="column-header">
                    <div class="column-dot scheduled"></div>
                    <span class="column-title">üìÖ Scheduled</span>
                    <span class="column-count" id="count-scheduled">0</span>
                    <span class="column-add" onclick="openScheduledTaskModal()" title="Schedule a task"><i data-lucide="plus"></i></span>
                </div>
                <div class="column-tasks" id="tasks-scheduled" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)" ondrop="handleDrop(event, 'scheduled')"></div>
            </div>

            <div class="column column-templates" data-column="templates">
                <div class="column-header">
                    <div class="column-dot templates"></div>
                    <span class="column-title">üìë Templates</span>
                    <span class="column-count" id="count-templates">0</span>
                    <span class="column-add" onclick="openNewTemplate()" title="Add new template"><i data-lucide="plus"></i></span>
                </div>
                <div class="column-tasks" id="tasks-templates"></div>
            </div>

            <div class="column" data-column="permanent">
                <div class="column-header">
                    <div class="column-dot permanent"></div>
                    <span class="column-title">Permanent</span>
                    <span class="column-count" id="count-permanent">0</span>
                    <span class="column-add" onclick="openNewTask('permanent')" title="Add new task"><i data-lucide="plus"></i></span>
                    <button class="voice-mic-btn" onclick="startVoiceInput('permanent')" title="Add task by voice">üé§</button>
                </div>
                <div class="column-tasks" id="tasks-permanent" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)" ondrop="handleDrop(event, 'permanent')"></div>
            </div>

            <div class="column" data-column="backlog">
                <div class="column-header">
                    <div class="column-dot backlog"></div>
                    <span class="column-title">Backlog</span>
                    <span class="column-count" id="count-backlog">0</span>
                    <span class="column-add" onclick="openNewTask('backlog')" title="Add new task"><i data-lucide="plus"></i></span>
                    <button class="voice-mic-btn" onclick="startVoiceInput('backlog')" title="Add task by voice">üé§</button>
                </div>
                <div class="column-tasks" id="tasks-backlog" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)" ondrop="handleDrop(event, 'backlog')"></div>
            </div>

            <div class="column" data-column="in_progress">
                <div class="column-header">
                    <div class="column-dot in-progress"></div>
                    <span class="column-title">In Progress</span>
                    <span class="column-count" id="count-in_progress">0</span>
                    <span class="column-add" onclick="openNewTask('in_progress')" title="Add new task"><i data-lucide="plus"></i></span>
                    <button class="voice-mic-btn" onclick="startVoiceInput('in_progress')" title="Add task by voice">üé§</button>
                </div>
                <div class="column-tasks" id="tasks-in_progress" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)" ondrop="handleDrop(event, 'in_progress')"></div>
            </div>

            <div class="column" data-column="review">
                <div class="column-header">
                    <div class="column-dot review"></div>
                    <span class="column-title">Review</span>
                    <span class="column-count" id="count-review">0</span>
                    <span class="column-add" onclick="openNewTask('review')" title="Add new task"><i data-lucide="plus"></i></span>
                    <button class="voice-mic-btn" onclick="startVoiceInput('review')" title="Add task by voice">üé§</button>
                </div>
                <div class="column-tasks" id="tasks-review" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)" ondrop="handleDrop(event, 'review')"></div>
            </div>

            <div class="column" data-column="done">
                <div class="column-header">
                    <div class="column-dot done"></div>
                    <span class="column-title">Done</span>
                    <span class="column-count" id="count-done">0</span>
                    <button class="archive-all-btn" onclick="showArchiveView()" title="View archived tasks" style="background: transparent;">üìÇ View</button>
                    <button class="archive-all-btn" onclick="archiveAllDone()" title="Archive all done tasks">üì¶ Archive All</button>
                </div>
                <div class="column-tasks" id="tasks-done" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)" ondrop="handleDrop(event, 'done')"></div>
            </div>
        </div>

        <aside class="activity" id="activity-sidebar">
            <div class="activity-header">
                <span>ACTIVITY</span>
                <button class="activity-toggle" onclick="toggleActivity()" title="Hide Activity">
                    <span id="activity-toggle-icon">‚úï</span>
                </button>
            </div>
            <div class="activity-list" id="activity-list"></div>
        </aside>
        <button class="activity-reopen" id="activity-reopen" onclick="toggleActivity()" title="Show Activity">
            ACTIVITY
        </button>
    </main>

    </div><!-- END view-tasks -->

    <!-- TODO VIEW -->
    <div id="view-todo" class="view" style="display: none;">
        <div style="max-width: 900px; margin: 0 auto; padding: 1.25rem 1.5rem;">
            <div style="display:flex; align-items:center; justify-content:space-between; gap: 1rem; margin-bottom: 1rem;">
                <h1 style="margin: 0; font-size: 1.25rem;">üìù Todo</h1>
                <div style="display:flex; gap: .5rem; align-items:center;">
                    <input id="todo-input" class="search-input" style="width: 420px;" placeholder="Add a todo‚Ä¶" onkeydown="if(event.key==='Enter'){addTodoFromInput()}" />
                    <button class="btn btn-primary" onclick="addTodoFromInput()">Add</button>
                </div>
            </div>

            <div style="display:flex; align-items:center; justify-content:space-between; gap: 1rem; margin-bottom: 1rem;">
                <div style="display:flex; gap: .5rem; align-items:center; flex-wrap: wrap;">
                    <button class="filter-btn active" id="todo-filter-all" onclick="setTodoFilter('all')">All</button>
                    <button class="filter-btn" id="todo-filter-open" onclick="setTodoFilter('open')">Open</button>
                    <button class="filter-btn" id="todo-filter-done" onclick="setTodoFilter('done')">Done</button>
                </div>
                <div style="display:flex; gap: .5rem; align-items:center;">
                    <button class="btn btn-secondary" onclick="clearDoneTodos()">Clear done</button>
                </div>
            </div>

            <div id="todo-list" style="display:flex; flex-direction:column; gap: .5rem;"></div>
        </div>
    </div><!-- END view-todo -->

    <!-- DOCS VIEW -->
    <div id="view-docs" class="view" style="display: none;">
        <div class="docs-container" style="max-width: 900px; margin: 0 auto; padding: 2rem;">
            <h1 style="margin-bottom: 1.5rem;">üìö Mission Control Documentation</h1>

            <div class="docs-section" style="margin-bottom: 2rem; background: var(--bg-secondary); padding: 1.5rem; border-radius: 12px; border-left: 4px solid var(--accent);">
                <h2 style="color: var(--accent); margin-bottom: 0.5rem;">üìå Demo Mode</h2>
                <p style="color: var(--text-secondary); line-height: 1.6;">
                    You're currently viewing <strong>sample data</strong>. To manage your own tasks, click <strong>"Connect GitHub"</strong> in the top right corner to link your repository.
                </p>
            </div>

            <div class="docs-section" style="margin-bottom: 2rem;">
                <h2 style="color: var(--accent); margin-bottom: 1rem;">üöÄ Getting Started</h2>

                <h3 style="margin: 1rem 0 0.5rem;">Installation</h3>
                <p style="color: var(--text-secondary); line-height: 1.6;">
                    Add Mission Control to your existing MoltBot workspace:
                </p>
                <ol style="color: var(--text-secondary); line-height: 1.8; margin-left: 1.5rem;">
                    <li><strong>Fork</strong> this repository to your GitHub account</li>
                    <li><strong>Copy dashboard files</strong> to your workspace: <code>index.html</code>, <code>data/</code>, <code>canvas/</code>, <code>scripts/</code>, <code>.github/</code></li>
                    <li>Enable <strong>GitHub Pages</strong> in your repo settings (Settings ‚Üí Pages ‚Üí Branch: main)</li>
                    <li>Visit <code>https://[username].github.io/mission-control/</code></li>
                </ol>

                <h3 style="margin: 1.5rem 0 0.5rem;">Connect to GitHub</h3>
                <p style="color: var(--text-secondary); line-height: 1.6;">
                    Click <strong>"Connect GitHub"</strong> in the top right corner. You'll need a GitHub Personal Access Token with <code>repo</code> permissions.
                </p>
                <ol style="color: var(--text-secondary); line-height: 1.8; margin-left: 1.5rem;">
                    <li>Go to <a href="https://github.com/settings/tokens" target="_blank" style="color: var(--accent);">GitHub Settings ‚Üí Tokens</a></li>
                    <li>Click "Generate new token (classic)"</li>
                    <li>Select scope: <code>repo</code> (Full control of private repositories)</li>
                    <li>Copy the token and paste it in Mission Control</li>
                </ol>

                <h3 style="margin: 1.5rem 0 0.5rem;">Understanding the Board</h3>
                <p style="color: var(--text-secondary); line-height: 1.6;">
                    Mission Control uses a Kanban-style board with 5 columns:
                </p>
                <ul style="color: var(--text-secondary); line-height: 1.8; margin-left: 1.5rem;">
                    <li><strong>üîÑ Permanent</strong> - Repeating tasks (daily, weekly checks)</li>
                    <li><strong>üìã Backlog</strong> - Tasks waiting to be started</li>
                    <li><strong>üöÄ In Progress</strong> - Currently being worked on</li>
                    <li><strong>üëÄ Review</strong> - Done, awaiting approval</li>
                    <li><strong>‚úÖ Done</strong> - Completed tasks</li>
                </ul>
            </div>

            <div class="docs-section" style="margin-bottom: 2rem;">
                <h2 style="color: var(--accent); margin-bottom: 1rem;">‚ú® Features</h2>

                <h3 style="margin: 1rem 0 0.5rem;">Auto-Save</h3>
                <p style="color: var(--text-secondary); line-height: 1.6;">
                    All changes are <strong>automatically saved</strong> to GitHub. No manual "Save" button needed!
                </p>
                <ul style="color: var(--text-secondary); line-height: 1.8; margin-left: 1.5rem;">
                    <li>Drag & drop tasks between columns ‚Üí instant save</li>
                    <li>Edit task details ‚Üí instant save</li>
                    <li>Add/remove subtasks ‚Üí instant save</li>
                    <li>Add comments ‚Üí instant save</li>
                </ul>

                <h3 style="margin: 1.5rem 0 0.5rem;">Drag & Drop</h3>
                <p style="color: var(--text-secondary); line-height: 1.6;">
                    Click and drag any task card to move it between columns. The status updates automatically.
                </p>

                <h3 style="margin: 1.5rem 0 0.5rem;">Subtasks</h3>
                <p style="color: var(--text-secondary); line-height: 1.6;">
                    Break down tasks into smaller steps. Click on a subtask to edit it inline.
                </p>

                <h3 style="margin: 1.5rem 0 0.5rem;">Comments</h3>
                <p style="color: var(--text-secondary); line-height: 1.6;">
                    Add comments to tasks for context or feedback. Comments on <strong>Review</strong> tasks trigger notifications to MoltBot.
                </p>

                <h3 style="margin: 1.5rem 0 0.5rem;">Projects & Tags</h3>
                <p style="color: var(--text-secondary); line-height: 1.6;">
                    Organize tasks by project. Use the ‚öôÔ∏è Settings to add new projects. Filter tasks using the project buttons.
                </p>
            </div>

            <div class="docs-section" style="margin-bottom: 2rem;">
                <h2 style="color: var(--accent); margin-bottom: 1rem;">ü§ñ MoltBot Integration</h2>
                <p style="color: var(--text-secondary); line-height: 1.6;">
                    Mission Control is connected to MoltBot via webhooks. When you make changes:
                </p>
                <ul style="color: var(--text-secondary); line-height: 1.8; margin-left: 1.5rem;">
                    <li><strong>Move task to "In Progress"</strong> ‚Üí MoltBot receives a work order and starts processing</li>
                    <li><strong>Add comment on Review task</strong> ‚Üí MoltBot sees your feedback</li>
                    <li><strong>MoltBot completes work</strong> ‚Üí Task moves to "Review" automatically</li>
                </ul>

                <div style="background: var(--bg-secondary); padding: 1rem; border-radius: 8px; margin-top: 1rem;">
                    <strong>üí° Pro Tip:</strong> Write clear task descriptions and subtasks. The more detail you provide, the better MoltBot can execute the task.
                </div>
            </div>

            <div class="docs-section" style="margin-bottom: 2rem;">
                <h2 style="color: var(--accent); margin-bottom: 1rem;">‚å®Ô∏è Keyboard Shortcuts</h2>
                <table style="width: 100%; border-collapse: collapse;">
                    <tr style="border-bottom: 1px solid var(--border-color);">
                        <td style="padding: 0.5rem; color: var(--text-secondary);"><code>Cmd/Ctrl + Shift + R</code></td>
                        <td style="padding: 0.5rem;">Hard refresh (clear cache)</td>
                    </tr>
                    <tr style="border-bottom: 1px solid var(--border-color);">
                        <td style="padding: 0.5rem; color: var(--text-secondary);"><code>Escape</code></td>
                        <td style="padding: 0.5rem;">Close modals</td>
                    </tr>
                    <tr style="border-bottom: 1px solid var(--border-color);">
                        <td style="padding: 0.5rem; color: var(--text-secondary);"><code>Enter</code></td>
                        <td style="padding: 0.5rem;">Save inline edits</td>
                    </tr>
                </table>
            </div>

            <div class="docs-section">
                <h2 style="color: var(--accent); margin-bottom: 1rem;">‚ùì FAQ</h2>

                <details style="margin-bottom: 1rem;">
                    <summary style="cursor: pointer; font-weight: 500;">Why don't I see my changes?</summary>
                    <p style="color: var(--text-secondary); padding: 0.5rem 0 0 1rem;">
                        GitHub Pages can cache content. Try a hard refresh (Cmd+Shift+R) or open in an incognito window.
                    </p>
                </details>

                <details style="margin-bottom: 1rem;">
                    <summary style="cursor: pointer; font-weight: 500;">How do I create a new project?</summary>
                    <p style="color: var(--text-secondary); padding: 0.5rem 0 0 1rem;">
                        Click the ‚öôÔ∏è Settings button (when logged in) ‚Üí Add a new project with ID, name, icon, and color.
                    </p>
                </details>

                <details style="margin-bottom: 1rem;">
                    <summary style="cursor: pointer; font-weight: 500;">Can multiple people use this?</summary>
                    <p style="color: var(--text-secondary); padding: 0.5rem 0 0 1rem;">
                        Yes! Anyone with repo access can connect their GitHub token. Changes from all users sync automatically.
                    </p>
                </details>
            </div>
        </div>
    </div><!-- END view-docs -->

    <!-- PEOPLE VIEW -->
    <div id="view-people" class="view" style="display: none;">
        <div class="people-container">
            <div class="people-header">
                <h1>üë• Team</h1>
                <div class="people-stats" id="people-stats">
                    <!-- Stats filled by JS -->
                </div>
            </div>
            <div id="collaborators-container">
                <div class="people-loading">
                    <div class="spinner"></div>
                    <p>Loading collaborators...</p>
                </div>
            </div>
        </div>
    </div><!-- END view-people -->

    <!-- NOTES VIEW -->
    <div id="view-notes" class="view" style="display: none;">
        <div class="notes-container" id="notes-container">
            <div class="notes-header">
                <h1>üìù Notes</h1>
                <div class="notes-actions">
                    <button class="btn btn-primary" onclick="createNewNote()">+ New Note</button>
                </div>
            </div>

            <!-- Notes List View -->
            <div class="notes-list" id="notes-list">
                <div class="notes-grid" id="notes-grid">
                    <!-- Note cards populated by JS -->
                </div>
            </div>

            <!-- Notes Editor View -->
            <div class="notes-editor" id="notes-editor">
                <!-- Toolbar -->
                <div class="notes-toolbar">
                    <div class="notes-toolbar-group">
                        <button class="notes-tool-btn" onclick="closeNoteEditor()" title="Back to notes">‚Üê</button>
                    </div>

                    <div class="notes-toolbar-group">
                        <input type="text" class="notes-title-input" id="note-title-input" placeholder="Note title..." onchange="updateNoteTitle()">
                    </div>

                    <div class="notes-toolbar-group">
                        <button class="notes-tool-btn active" id="tool-pen" onclick="setNoteTool('pen')" title="Pen">‚úèÔ∏è</button>
                        <button class="notes-tool-btn" id="tool-eraser" onclick="setNoteTool('eraser')" title="Eraser">üßπ</button>
                    </div>

                    <div class="notes-toolbar-group">
                        <button class="notes-color-btn active" id="color-black" style="background: #000000;" onclick="setNoteColor('#000000')" title="Black"></button>
                        <button class="notes-color-btn" id="color-blue" style="background: #2563eb;" onclick="setNoteColor('#2563eb')" title="Blue"></button>
                        <button class="notes-color-btn" id="color-red" style="background: #dc2626;" onclick="setNoteColor('#dc2626')" title="Red"></button>
                        <button class="notes-color-btn" id="color-green" style="background: #16a34a;" onclick="setNoteColor('#16a34a')" title="Green"></button>
                        <button class="notes-color-btn" id="color-yellow" style="background: #eab308;" onclick="setNoteColor('#eab308')" title="Yellow"></button>
                        <button class="notes-color-btn" id="color-white" style="background: #ffffff; border: 1px solid #ccc;" onclick="setNoteColor('#ffffff')" title="White"></button>
                    </div>

                    <div class="notes-toolbar-group">
                        <input type="range" class="notes-width-slider" id="stroke-width-slider" min="1" max="20" value="3" oninput="setNoteStrokeWidth(this.value)">
                        <span class="notes-width-value" id="stroke-width-value">3px</span>
                    </div>

                    <div class="notes-toolbar-group">
                        <select class="notes-bg-select" id="note-bg-select" onchange="setNoteBackground(this.value)">
                            <option value="plain">Plain White</option>
                            <option value="lined">Lined Paper</option>
                            <option value="grid">Grid / Dots</option>
                            <option value="dark">Dark Mode</option>
                        </select>
                    </div>

                    <div class="notes-toolbar-group">
                        <button class="notes-tool-btn" id="tool-undo" onclick="noteUndo()" title="Undo" disabled>‚Ü©Ô∏è</button>
                        <button class="notes-tool-btn" id="tool-redo" onclick="noteRedo()" title="Redo" disabled>‚Ü™Ô∏è</button>
                        <button class="notes-tool-btn" onclick="noteClear()" title="Clear All">üóëÔ∏è</button>
                    </div>

                    <div class="notes-toolbar-group">
                        <button class="notes-tool-btn" onclick="toggleNotesFullscreen()" title="Fullscreen">‚õ∂</button>
                        <button class="btn btn-primary btn-small" onclick="saveCurrentNote()">üíæ Save</button>
                    </div>
                </div>

                <!-- Canvas -->
                <div class="notes-canvas-container" id="notes-canvas-container">
                    <canvas class="notes-canvas" id="notes-canvas"></canvas>
                </div>
            </div>
        </div>
    </div><!-- END view-notes -->

    <!-- Auth Modal -->
    <div class="modal-overlay" id="auth-modal" onclick="if(event.target===this)hideAuthModal()">
        <div class="modal">
            <div class="modal-header">
                <h2 class="modal-title">üîê Connect to GitHub</h2>
                <button class="modal-close" onclick="hideAuthModal()">&times;</button>
            </div>
            <div class="modal-body">
                <p style="color: var(--text-secondary); margin-bottom: 1.5rem;">
                    Connect your GitHub account to create, edit, and save tasks directly to the repository.
                </p>

                <div class="steps">
                    <div class="step">
                        <span class="step-number">1</span>
                        <div class="step-content">
                            <div class="step-title">Create a Personal Access Token</div>
                            <div class="step-description">
                                <a href="https://github.com/settings/tokens/new?scopes=repo&description=Mission%20Control%20Dashboard" target="_blank">
                                    Click here to create a token ‚Üí
                                </a>
                            </div>
                        </div>
                    </div>
                    <div class="step">
                        <span class="step-number">2</span>
                        <div class="step-content">
                            <div class="step-title">Select "repo" scope</div>
                            <div class="step-description">This allows read/write access to repositories</div>
                        </div>
                    </div>
                    <div class="step">
                        <span class="step-number">3</span>
                        <div class="step-content">
                            <div class="step-title">Paste your token below</div>
                            <div class="step-description">The token starts with "ghp_"</div>
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">GitHub Personal Access Token</label>
                    <input type="password" class="form-input" id="token-input" placeholder="ghp_xxxxxxxxxxxxxxxxxxxx" autocomplete="off">
                    <div class="form-hint">
                        üîí Your token is stored locally and never sent anywhere except GitHub.
                    </div>
                    <div class="validation-loading" id="validation-loading">
                        <div class="spinner"></div>
                        <span>Validating token...</span>
                    </div>
                    <div class="validation-success" id="validation-success">
                        <span>‚úì</span>
                        <span>Connected as <strong id="validated-user"></strong></span>
                    </div>
                    <div class="validation-error" id="validation-error">
                        <span>‚úó</span>
                        <span id="error-message">Invalid token</span>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="hideAuthModal()">Cancel</button>
                <button class="btn btn-primary" id="btn-save-token" onclick="validateAndSaveToken()" disabled>Connect</button>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="modal-overlay" id="settings-modal" onclick="if(event.target===this)hideSettingsModal()">
        <div class="modal" style="max-width: 500px;">
            <div class="modal-header">
                <h2 class="modal-title">‚öôÔ∏è Settings</h2>
                <button class="modal-close" onclick="hideSettingsModal()">&times;</button>
            </div>
            <div class="modal-body">
                <h3 style="margin-bottom: 12px; font-size: 1rem;">Storage</h3>
                <div style="padding: 12px; background: var(--bg-card); border: 1px solid var(--border-color); border-radius: 10px; margin-bottom: 16px;">
                    <div style="display:flex; align-items:center; justify-content:space-between; gap: 12px;">
                        <div>
                            <div style="font-weight: 600;">Data store</div>
                            <div style="color: var(--text-secondary); font-size: .875rem; line-height: 1.4;">
                                <strong>Internal</strong> = uses this server‚Äôs <code>data/tasks.json</code> via <code>/api/tasks</code> (recommended for now).
                                <br />
                                <strong>GitHub</strong> = browser writes directly to GitHub using a token.
                            </div>
                        </div>
                        <select class="form-input" id="storage-mode" style="width: 190px;" onchange="setStorageMode(this.value)">
                            <option value="internal">Internal</option>
                            <option value="github">GitHub</option>
                        </select>
                    </div>
                </div>

                <h3 style="margin-bottom: 12px; font-size: 1rem;">Projects</h3>
                <div id="projects-list" class="projects-list"></div>

                <div class="add-project-form" style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border-color);">
                    <h4 style="margin-bottom: 8px; font-size: 0.9rem;" id="project-form-title">Add New Project</h4>
                    <div style="display: grid; gap: 8px;">
                        <input type="text" class="form-input" id="new-project-id" placeholder="ID (z.B. marketing)">
                        <input type="text" class="form-input" id="new-project-name" placeholder="Name (z.B. Marketing)">
                        <div style="margin-bottom: 8px;">
                            <label style="font-size: 0.8rem; color: var(--text-secondary);">Icon</label>
                            <div class="emoji-picker" style="display: flex; flex-wrap: wrap; gap: 4px; margin-top: 4px;">
                                <button type="button" class="emoji-btn" onclick="selectEmoji('üìÅ')">üìÅ</button>
                                <button type="button" class="emoji-btn" onclick="selectEmoji('üìä')">üìä</button>
                                <button type="button" class="emoji-btn" onclick="selectEmoji('üíº')">üíº</button>
                                <button type="button" class="emoji-btn" onclick="selectEmoji('üöÄ')">üöÄ</button>
                                <button type="button" class="emoji-btn" onclick="selectEmoji('üí°')">üí°</button>
                                <button type="button" class="emoji-btn" onclick="selectEmoji('üéØ')">üéØ</button>
                                <button type="button" class="emoji-btn" onclick="selectEmoji('üì£')">üì£</button>
                                <button type="button" class="emoji-btn" onclick="selectEmoji('üõ†Ô∏è')">üõ†Ô∏è</button>
                                <button type="button" class="emoji-btn" onclick="selectEmoji('üì±')">üì±</button>
                                <button type="button" class="emoji-btn" onclick="selectEmoji('üåê')">üåê</button>
                                <button type="button" class="emoji-btn" onclick="selectEmoji('üí∞')">üí∞</button>
                                <button type="button" class="emoji-btn" onclick="selectEmoji('üìù')">üìù</button>
                                <button type="button" class="emoji-btn" onclick="selectEmoji('üè†')">üè†</button>
                                <button type="button" class="emoji-btn" onclick="selectEmoji('‚ù§Ô∏è')">‚ù§Ô∏è</button>
                                <button type="button" class="emoji-btn" onclick="selectEmoji('‚≠ê')">‚≠ê</button>
                                <input type="text" class="form-input" id="new-project-icon" placeholder="or custom..." style="width: 100px; font-size: 1.1rem;">
                            </div>
                        </div>
                        <div style="display: flex; gap: 8px; align-items: center;">
                            <label style="font-size: 0.8rem; color: var(--text-secondary);">Farbe:</label>
                            <input type="color" id="new-project-color" value="#6366f1" style="width: 50px; height: 32px; border: none; cursor: pointer; border-radius: 4px;">
                            <button class="btn btn-secondary" id="btn-cancel-project" onclick="cancelEditProject()" style="display: none;">Cancel</button>
                            <button class="btn btn-primary" id="btn-save-project" onclick="saveProject()" style="flex: 1;">+ Add Project</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Commit Modal -->
    <div class="modal-overlay" id="commit-modal" onclick="if(event.target===this)hideCommitModal()">
        <div class="modal">
            <div class="modal-header">
                <h2 class="modal-title">üíæ Save Changes to GitHub</h2>
                <button class="modal-close" onclick="hideCommitModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Commit Message</label>
                    <input type="text" class="form-input" id="commit-message" placeholder="Update tasks" autocomplete="off">
                    <div class="form-hint">
                        Describe what you changed (optional - will use default if empty)
                    </div>
                </div>
                <div id="changes-summary" style="margin-top: 1rem; padding: 1rem; background: var(--bg-card); border-radius: 6px; font-size: 0.875rem;">
                    <!-- Changes will be listed here -->
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="hideCommitModal()">Cancel</button>
                <button class="btn btn-primary" id="btn-commit" onclick="commitChanges()">
                    <span id="commit-btn-text">Commit & Push</span>
                    <div class="spinner" id="commit-spinner" style="display: none;"></div>
                </button>
            </div>
        </div>
    </div>

    <!-- Task Edit Modal -->
    <div class="modal-overlay" id="task-modal" onclick="if(event.target===this)hideTaskModal()">
        <div class="modal" style="max-width: 600px;">
            <div class="modal-header">
                <h2 class="modal-title" id="task-modal-title">Edit Task</h2>
                <button class="modal-close" onclick="hideTaskModal()">&times;</button>
            </div>
            <div class="modal-body">
                <!-- Voice Recording Indicator -->
                <div class="recording-indicator" id="modal-recording-indicator">
                    <div class="recording-dot"></div>
                    <span>Recording... Speak your task</span>
                </div>
                <div class="form-group">
                    <label class="form-label">Title</label>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <input type="text" class="form-input" id="task-title" placeholder="Task title" style="flex: 1;">
                        <button class="voice-mic-btn" id="modal-voice-btn" onclick="startModalVoiceInput()" title="Speak task title">üé§</button>
                    </div>
                </div>
                <div class="form-group">
                    <label class="form-label">Description</label>
                    <textarea class="form-input" id="task-description" rows="3" placeholder="Task description" style="resize: vertical;"></textarea>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                    <div class="form-group">
                        <label class="form-label">Status</label>
                        <select class="form-input" id="task-status">
                            <option value="permanent">Permanent</option>
                            <option value="scheduled">Scheduled</option>
                            <option value="backlog">Backlog</option>
                            <option value="in_progress">In Progress</option>
                            <option value="review">Review</option>
                            <option value="done">Done</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Priority</label>
                        <select class="form-input" id="task-priority">
                            <option value="low">Low</option>
                            <option value="medium">Medium</option>
                            <option value="high">High</option>
                        </select>
                    </div>
                </div>
                <div class="form-group">
                    <label class="form-label">Project</label>
                    <select class="form-input" id="task-project">
                        <!-- Populated dynamically from STATE.data.projects -->
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">Tags</label>
                    <div id="tags-chips" class="tags-chips-container" style="display: flex; flex-wrap: wrap; gap: 6px; margin-bottom: 8px;"></div>
                    <div style="display: flex; gap: 8px;">
                        <input type="text" class="form-input" id="new-tag-input" placeholder="Add tag..." style="flex: 1;" onkeydown="if(event.key==='Enter'){event.preventDefault();addTag();}">
                        <button class="btn btn-secondary btn-small" onclick="addTag()">+ Add</button>
                    </div>
                    <input type="hidden" id="task-tags">
                </div>

                <!-- Subtasks Section -->
                <div class="form-group" id="subtasks-section">
                    <label class="form-label">Subtasks</label>
                    <div class="subtasks-list" id="subtasks-list"></div>
                    <div class="subtask-add">
                        <input type="text" class="form-input" id="new-subtask-input" placeholder="Add new subtask...">
                        <button class="btn btn-secondary btn-small" onclick="addSubtask()">+ Add</button>
                    </div>
                </div>

                <!-- Comments Section -->
                <div class="form-group" id="comments-section">
                    <label class="form-label">Comments</label>
                    <div class="comments-list" id="comments-list"></div>
                    <div class="comment-add">
                        <textarea class="form-input" id="new-comment-input" rows="2" placeholder="Add a comment..."></textarea>
                        <button class="btn btn-secondary btn-small" onclick="addComment()">Post Comment</button>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-danger" id="btn-delete-task" onclick="deleteTask()" style="margin-right: auto;">Delete</button>
                <button class="btn btn-secondary" id="btn-task-to-cron" onclick="openTaskToCronWizard(currentEditingTaskId)" title="Convert to recurring cron job">‚è∞ As Cron</button>
                <button class="btn btn-secondary" onclick="hideTaskModal()">Cancel</button>
                <button class="btn btn-primary" onclick="saveTask()">Save Task</button>
            </div>
        </div>
    </div>

    <!-- Toast Container -->
    <div class="toast-container" id="toast-container"></div>

    <!-- Voice Input Modal -->
    <div class="voice-modal-overlay" id="voice-modal" onclick="if(event.target===this)cancelVoiceInput()">
        <div class="voice-modal">
            <div class="voice-modal-icon" id="voice-modal-icon">üé§</div>
            <div class="voice-modal-status" id="voice-modal-status">Listening...</div>
            <div class="voice-modal-hint" id="voice-modal-hint">
                Say something like "Add buy milk to backlog"
            </div>
            <div class="voice-modal-transcript" id="voice-modal-transcript">
                <span style="color: var(--text-secondary); font-style: italic;">Waiting for speech...</span>
            </div>
            <div class="voice-modal-buttons">
                <button class="btn btn-secondary" onclick="cancelVoiceInput()">Cancel</button>
                <button class="btn btn-primary" id="voice-create-btn" onclick="createTaskFromVoice()" disabled>Create Task</button>
            </div>
        </div>
    </div>

    <!-- Voice Note Recording Modal -->
    <div class="voice-note-modal-overlay" id="voice-note-modal" onclick="if(event.target===this)cancelVoiceNote()">
        <div class="voice-note-modal">
            <div class="voice-note-modal-title" id="voice-note-modal-title">üéôÔ∏è Record Voice Note</div>
            <div class="voice-note-modal-subtitle" id="voice-note-modal-subtitle">Tap to start recording</div>
            
            <div class="voice-note-record-area">
                <button class="voice-note-record-btn" id="voice-note-record-btn" onclick="toggleVoiceNoteRecording()">
                    <span id="voice-note-record-icon">üî¥</span>
                </button>
                <div class="voice-note-timer" id="voice-note-timer">0:00</div>
                <div class="voice-note-waveform" id="voice-note-waveform">
                    <div class="bar"></div>
                    <div class="bar"></div>
                    <div class="bar"></div>
                    <div class="bar"></div>
                    <div class="bar"></div>
                    <div class="bar"></div>
                    <div class="bar"></div>
                    <div class="bar"></div>
                </div>
            </div>
            
            <!-- Playback area (shown after recording) -->
            <div class="voice-note-playback" id="voice-note-playback">
                <div class="voice-note-playback-controls">
                    <button class="voice-note-play-btn" id="voice-note-play-btn" onclick="toggleVoiceNotePlayback()">‚ñ∂</button>
                    <div class="voice-note-progress" id="voice-note-progress" onclick="seekVoiceNote(event)">
                        <div class="voice-note-progress-fill" id="voice-note-progress-fill"></div>
                    </div>
                    <span class="voice-note-duration" id="voice-note-duration">0:00</span>
                </div>
                <div class="voice-note-transcript-preview" id="voice-note-transcript-preview" style="display: none;">
                    Transcribing...
                </div>
            </div>
            
            <div class="voice-note-modal-buttons">
                <button class="btn btn-secondary" onclick="cancelVoiceNote()">Cancel</button>
                <button class="btn btn-danger" id="voice-note-discard-btn" onclick="discardVoiceNote()" style="display: none;">üóëÔ∏è Discard</button>
                <button class="btn btn-primary" id="voice-note-save-btn" onclick="saveVoiceNote()" disabled>üíæ Save</button>
            </div>
        </div>
    </div>

    <script>
        // === CONFIG ===
        const CONFIG = {
            owner: 'ustaaa',
            repo: 'mission-control',
            branch: 'main',
            tasksFile: 'data/tasks.json',
            useProxy: true // internal server datastore via /api/tasks
        };

        // Storage mode:
        // - internal: use proxy (/api/tasks)
        // - github: direct GitHub API via token
        const STORAGE_MODE_KEY = 'mc_storage_mode';
        function getStorageMode() {
            const stored = localStorage.getItem(STORAGE_MODE_KEY);
            if (stored === 'github' || stored === 'internal') return stored;
            return 'internal';
        }
        function setStorageMode(mode) {
            if (mode !== 'github' && mode !== 'internal') return;
            localStorage.setItem(STORAGE_MODE_KEY, mode);
            CONFIG.useProxy = mode === 'internal';
            showToast('success', `Storage set to: ${mode}`);
            // safest: reload to ensure all loads/saves use the same backend
            setTimeout(() => window.location.reload(), 250);
        }

        // Apply mode early
        CONFIG.useProxy = getStorageMode() === 'internal';

        // === THEME SYSTEM ===
        const THEME_KEY = 'mc_theme';
        const THEMES = ['gruvbox', 'nord', 'claude', 'opencode', 'gnome'];
        
        function getTheme() {
            const stored = localStorage.getItem(THEME_KEY);
            if (stored && THEMES.includes(stored)) return stored;
            return 'gruvbox'; // Default
        }
        
        function setTheme(theme) {
            if (!THEMES.includes(theme)) return;
            
            // Apply theme via data attribute
            if (theme === 'gruvbox') {
                document.body.removeAttribute('data-theme');
            } else {
                document.body.setAttribute('data-theme', theme);
            }
            
            // Persist preference
            localStorage.setItem(THEME_KEY, theme);
            
            // Update dropdown if it exists
            const select = document.getElementById('theme-select');
            if (select && select.value !== theme) {
                select.value = theme;
            }
            
            console.log('Theme set to:', theme);
        }
        
        function initTheme() {
            const theme = getTheme();
            setTheme(theme);
            
            // Sync dropdown with current theme
            const select = document.getElementById('theme-select');
            if (select) {
                select.value = theme;
            }
        }
        
        // Apply theme immediately to prevent flash
        (function() {
            const theme = localStorage.getItem(THEME_KEY);
            if (theme && theme !== 'gruvbox') {
                document.body.setAttribute('data-theme', theme);
            }
        })();

        // === MOBILE COLUMN SELECTOR ===
        const MOBILE_COLUMN_KEY = 'mc_mobile_column';
        const MOBILE_COLUMNS = [
            { id: 'recurring', name: 'üîÑ Recurring', class: 'column-recurring' },
            { id: 'scheduled', name: 'üìÖ Scheduled', class: 'column-scheduled' },
            { id: 'templates', name: 'üìë Templates', class: 'column-templates' },
            { id: 'permanent', name: 'üü£ Permanent', class: '' },
            { id: 'backlog', name: 'üìã Backlog', class: '' },
            { id: 'in_progress', name: 'üöÄ In Progress', class: '' },
            { id: 'review', name: 'üëÄ Review', class: '' },
            { id: 'done', name: '‚úÖ Done', class: '' }
        ];
        
        function getMobileColumn() {
            const stored = sessionStorage.getItem(MOBILE_COLUMN_KEY);
            return stored || 'backlog';
        }
        
        function selectMobileColumn(columnId) {
            // Persist selection in session
            sessionStorage.setItem(MOBILE_COLUMN_KEY, columnId);
            
            // Update dropdown
            const select = document.getElementById('mobile-column-select');
            if (select && select.value !== columnId) {
                select.value = columnId;
            }
            
            // Remove mobile-active from all columns
            document.querySelectorAll('.kanban .column').forEach(col => {
                col.classList.remove('mobile-active');
            });
            
            // Find and activate the correct column using data-column attribute
            const targetColumn = document.querySelector(`.kanban .column[data-column="${columnId}"]`);
            if (targetColumn) {
                targetColumn.classList.add('mobile-active');
            }
        }
        
        function initMobileColumnSelector() {
            const savedColumn = getMobileColumn();
            selectMobileColumn(savedColumn);
            
            // Set up swipe gestures
            const kanban = document.getElementById('kanban-board');
            if (kanban) {
                let touchStartX = 0;
                let touchEndX = 0;
                
                kanban.addEventListener('touchstart', (e) => {
                    touchStartX = e.changedTouches[0].screenX;
                }, { passive: true });
                
                kanban.addEventListener('touchend', (e) => {
                    touchEndX = e.changedTouches[0].screenX;
                    handleSwipe();
                }, { passive: true });
                
                function handleSwipe() {
                    const swipeThreshold = 50;
                    const diff = touchStartX - touchEndX;
                    
                    if (Math.abs(diff) < swipeThreshold) return;
                    
                    const currentColumn = getMobileColumn();
                    const currentIndex = MOBILE_COLUMNS.findIndex(c => c.id === currentColumn);
                    
                    if (diff > 0 && currentIndex < MOBILE_COLUMNS.length - 1) {
                        // Swipe left ‚Üí next column
                        selectMobileColumn(MOBILE_COLUMNS[currentIndex + 1].id);
                    } else if (diff < 0 && currentIndex > 0) {
                        // Swipe right ‚Üí previous column
                        selectMobileColumn(MOBILE_COLUMNS[currentIndex - 1].id);
                    }
                }
            }
        }
        
        // Initialize mobile selector on load
        document.addEventListener('DOMContentLoaded', () => {
            if (window.innerWidth <= 640) {
                initMobileColumnSelector();
            }
        });
        
        // Re-initialize on resize
        window.addEventListener('resize', () => {
            if (window.innerWidth <= 640) {
                initMobileColumnSelector();
            }
        });

        // === STATE ===
        let STATE = {
            user: null,
            token: null,
            data: null,  // Loaded from GitHub or fallback
            originalData: null,  // For detecting changes
            hasUnsavedChanges: false,
            isLoading: false,
            gatewayUrl: null  // Set via config or auto-detected
        };

        // === VERSION CHECK ===
        const VERSION_FILE = 'data/version.json';
        const VERSION_CHECK_INTERVAL = 5 * 60 * 1000; // 5 minutes
        let currentVersion = null;
        let versionCheckInterval = null;
        
        // Gateway URL detection
        function getGatewayUrl() {
            // 1. Check if manually configured
            if (STATE.gatewayUrl) return STATE.gatewayUrl;
            
            // 2. Check localStorage
            const stored = localStorage.getItem('mc_gateway_url');
            if (stored) return stored;
            
            // 3. Auto-detect for local development
            const isLocal = location.hostname === 'localhost' || 
                           location.hostname === '127.0.0.1' ||
                           location.protocol === 'file:';
            if (isLocal) return 'http://localhost:3033';
            
            // 4. Not available on remote (GitHub Pages)
            return null;
        }
        
        function setGatewayUrl(url) {
            STATE.gatewayUrl = url;
            if (url) {
                localStorage.setItem('mc_gateway_url', url);
            } else {
                localStorage.removeItem('mc_gateway_url');
            }
        }
// === EMBEDDED DATA (fallback when not logged in) ===
        const FALLBACK_DATA = {
            tasks: [
                // === PERMANENT (recurring tasks) ===
                {
                    id: "task_p01",
                    title: "Weekly backup check",
                    description: "Verify all automated backups completed successfully",
                    status: "permanent",
                    project: "devops",
                    tags: ["devops", "maintenance"],
                    subtasks: [
                        { id: "sub_001", title: "Check database backups", done: false },
                        { id: "sub_002", title: "Verify file storage sync", done: false },
                        { id: "sub_003", title: "Test restore procedure", done: false }
                    ],
                    priority: "high",
                    createdAt: "2026-01-15T09:00:00Z"
                },
                {
                    id: "task_p02",
                    title: "Review analytics dashboard",
                    description: "Check KPIs and identify trends or anomalies",
                    status: "permanent",
                    project: "growth",
                    tags: ["growth", "analytics"],
                    subtasks: [],
                    priority: "medium",
                    createdAt: "2026-01-15T09:00:00Z"
                },
                // === BACKLOG ===
                {
                    id: "task_001",
                    title: "Redesign landing page",
                    description: "Modern refresh with improved conversion focus and mobile-first approach",
                    status: "backlog",
                    project: "design",
                    tags: ["design", "growth"],
                    subtasks: [
                        { id: "sub_001", title: "Competitor analysis", done: false },
                        { id: "sub_002", title: "Wireframe concepts", done: false },
                        { id: "sub_003", title: "Design mockups", done: false },
                        { id: "sub_004", title: "Get stakeholder feedback", done: false }
                    ],
                    priority: "high",
                    createdAt: "2026-01-20T10:00:00Z"
                },
                {
                    id: "task_002",
                    title: "Plan weekend hiking trip",
                    description: "Research trails, check weather, prepare gear for Saturday adventure",
                    status: "backlog",
                    project: "personal",
                    tags: ["personal", "wellness"],
                    subtasks: [
                        { id: "sub_001", title: "Choose trail (moderate difficulty)", done: false },
                        { id: "sub_002", title: "Check weather forecast", done: false },
                        { id: "sub_003", title: "Pack essentials", done: false }
                    ],
                    priority: "low",
                    createdAt: "2026-01-25T18:00:00Z"
                },
                {
                    id: "task_003",
                    title: "Set up CI/CD pipeline",
                    description: "Automate testing and deployment for the main project repository",
                    status: "backlog",
                    project: "devops",
                    tags: ["devops", "automation"],
                    subtasks: [
                        { id: "sub_001", title: "Configure GitHub Actions", done: false },
                        { id: "sub_002", title: "Add test coverage reports", done: false },
                        { id: "sub_003", title: "Set up staging environment", done: false },
                        { id: "sub_004", title: "Document deployment process", done: false }
                    ],
                    priority: "high",
                    createdAt: "2026-01-22T14:00:00Z"
                },
                {
                    id: "task_004",
                    title: "Research email automation tools",
                    description: "Compare options for newsletter and drip campaigns",
                    status: "backlog",
                    project: "growth",
                    tags: ["growth", "research"],
                    subtasks: [],
                    priority: "medium",
                    createdAt: "2026-01-24T11:00:00Z"
                },
                // === IN PROGRESS ===
                {
                    id: "task_005",
                    title: "Implement dark mode",
                    description: "Add theme toggle with system preference detection and persistence",
                    status: "in_progress",
                    project: "devops",
                    tags: ["devops", "design"],
                    subtasks: [
                        { id: "sub_001", title: "Define color variables", done: true },
                        { id: "sub_002", title: "Create theme toggle component", done: true },
                        { id: "sub_003", title: "Persist preference in localStorage", done: false },
                        { id: "sub_004", title: "Test across browsers", done: false }
                    ],
                    priority: "medium",
                    createdAt: "2026-01-23T09:00:00Z"
                },
                {
                    id: "task_006",
                    title: "Write Q1 blog post",
                    description: "Industry trends article for company blog, target 1500 words",
                    status: "in_progress",
                    project: "growth",
                    tags: ["growth", "content"],
                    subtasks: [
                        { id: "sub_001", title: "Outline key points", done: true },
                        { id: "sub_002", title: "Write first draft", done: true },
                        { id: "sub_003", title: "Add visuals and examples", done: false },
                        { id: "sub_004", title: "SEO optimization", done: false }
                    ],
                    priority: "medium",
                    createdAt: "2026-01-21T10:00:00Z"
                },
                {
                    id: "task_007",
                    title: "Organize home office",
                    description: "Declutter desk, improve cable management, add plants",
                    status: "in_progress",
                    project: "personal",
                    tags: ["personal", "wellness"],
                    subtasks: [
                        { id: "sub_001", title: "Sort through papers", done: true },
                        { id: "sub_002", title: "Order cable organizers", done: true },
                        { id: "sub_003", title: "Buy desk plant", done: false }
                    ],
                    priority: "low",
                    createdAt: "2026-01-26T15:00:00Z"
                },
                // === REVIEW ===
                {
                    id: "task_008",
                    title: "API documentation update",
                    description: "Complete overhaul of REST API docs with examples and error codes",
                    status: "review",
                    project: "devops",
                    tags: ["devops", "documentation"],
                    subtasks: [
                        { id: "sub_001", title: "Document all endpoints", done: true },
                        { id: "sub_002", title: "Add request/response examples", done: true },
                        { id: "sub_003", title: "Include authentication guide", done: true },
                        { id: "sub_004", title: "Peer review", done: false }
                    ],
                    priority: "high",
                    createdAt: "2026-01-18T09:00:00Z"
                },
                {
                    id: "task_009",
                    title: "New logo concepts",
                    description: "Three variations for brand refresh, awaiting team vote",
                    status: "review",
                    project: "design",
                    tags: ["design", "branding"],
                    subtasks: [
                        { id: "sub_001", title: "Minimalist version", done: true },
                        { id: "sub_002", title: "Bold/modern version", done: true },
                        { id: "sub_003", title: "Classic refined version", done: true }
                    ],
                    priority: "medium",
                    createdAt: "2026-01-19T11:00:00Z"
                },
                // === DONE ===
                {
                    id: "task_010",
                    title: "Fix login redirect bug",
                    description: "Users were redirected to wrong page after OAuth login",
                    status: "done",
                    project: "devops",
                    tags: ["devops", "bugfix"],
                    subtasks: [
                        { id: "sub_001", title: "Reproduce issue", done: true },
                        { id: "sub_002", title: "Identify root cause", done: true },
                        { id: "sub_003", title: "Implement fix", done: true },
                        { id: "sub_004", title: "Write regression test", done: true }
                    ],
                    priority: "high",
                    createdAt: "2026-01-17T08:00:00Z"
                },
                {
                    id: "task_011",
                    title: "Quarterly tax prep",
                    description: "Gather documents and submit to accountant",
                    status: "done",
                    project: "personal",
                    tags: ["personal", "finance"],
                    subtasks: [
                        { id: "sub_001", title: "Export bank statements", done: true },
                        { id: "sub_002", title: "Organize receipts", done: true },
                        { id: "sub_003", title: "Send to accountant", done: true }
                    ],
                    priority: "high",
                    createdAt: "2026-01-10T09:00:00Z"
                },
                {
                    id: "task_012",
                    title: "Social media content calendar",
                    description: "Plan posts for February across all platforms",
                    status: "done",
                    project: "growth",
                    tags: ["growth", "content"],
                    subtasks: [
                        { id: "sub_001", title: "Identify key dates/events", done: true },
                        { id: "sub_002", title: "Draft post ideas", done: true },
                        { id: "sub_003", title: "Schedule in buffer", done: true }
                    ],
                    priority: "medium",
                    createdAt: "2026-01-12T14:00:00Z"
                }
            ],
            todos: [
                { id: "todo_001", title: "Example todo (separate from Kanban tasks)", done: false, createdAt: "2026-01-01T00:00:00Z" }
            ],
            projects: [
                { id: "devops", name: "DevOps", color: "#3b82f6", icon: "üíª" },
                { id: "growth", name: "Growth", color: "#10b981", icon: "üìà" },
                { id: "design", name: "Design", color: "#f59e0b", icon: "üé®" },
                { id: "personal", name: "Personal", color: "#8b5cf6", icon: "üè†" },
                { id: "wellness", name: "Wellness", color: "#ec4899", icon: "üßò" }
            ],
            activities: [
                { type: "completed", actor: "You", task: "Social media content calendar", time: "2 hours ago" },
                { type: "moved", actor: "AI Assistant", task: "API documentation update", from: "in_progress", to: "review", time: "4 hours ago" },
                { type: "created", actor: "You", task: "Plan weekend hiking trip", time: "yesterday" },
                { type: "completed", actor: "You", task: "Fix login redirect bug", time: "2 days ago" },
                { type: "moved", actor: "AI Assistant", task: "Implement dark mode", from: "backlog", to: "in_progress", time: "3 days ago" }
            ],
            lastUpdated: new Date().toISOString()
        };
        function getProxyBasePath() {
            // If the app is mounted under a prefix (e.g. /kanban via Tailscale Serve),
            // API calls must include that same prefix.
            const parts = location.pathname.split('/').filter(Boolean);
            if (parts.length === 0) return '';
            return `/${parts[0]}`;
        }

        function proxyUrl(path) {
            return `${getProxyBasePath()}${path}`;
        }

        async function loadTasksFromGitHub() {
            STATE.isLoading = true;
            
            // PROXY MODE (Self-Hosted)
            if (CONFIG.useProxy) {
                try {
                    console.log('Fetching from local proxy...');
                    const response = await fetch(proxyUrl('/api/tasks'));
                    if (!response.ok) throw new Error('Proxy error');
                    
                    const data = await response.json();
                    STATE.data = data;
                    STATE.originalData = JSON.parse(JSON.stringify(data));
                    console.log('Loaded tasks from Proxy:', data.tasks.length);
                    showToast('success', `‚úì Loaded ${data.tasks.length} tasks`);
                    
                    // Mock auth state so UI looks logged in
                    if (!STATE.user) {
                        STATE.user = { login: 'admin', avatar_url: 'https://github.com/github.png', name: 'Admin' };
                        updateAuthUI();
                    }
                    
                } catch (error) {
                    console.error('Proxy load error:', error);
                    showToast('error', 'Could not load tasks');
                    STATE.data = JSON.parse(JSON.stringify(FALLBACK_DATA));
                }
                STATE.isLoading = false;
                renderAll();
                return;
            }

            // GITHUB API MODE (Legacy)
            if (!STATE.token) {
                console.log('No token, using fallback data');
                STATE.data = JSON.parse(JSON.stringify(FALLBACK_DATA));
                return;
            }

            STATE.isLoading = true;
            // DEBUG: Visual feedback
            showToast('info', `Connecting to ${CONFIG.owner}/${CONFIG.repo}...`);

            try {
                const url = `https://api.github.com/repos/${CONFIG.owner}/${CONFIG.repo}/contents/${CONFIG.tasksFile}`;
                console.log('Fetching:', url);

                const response = await fetch(url, {
                        headers: {
                            'Authorization': `token ${STATE.token}`,
                            'Accept': 'application/vnd.github.v3+json'
                        }
                    }
                );

                if (!response.ok) {
                    const errText = await response.text();
                    throw new Error(`HTTP ${response.status}: ${errText}`);
                }

                const fileData = await response.json();
                
                if (!fileData.content) {
                    throw new Error('API returned no content field. Is this a file?');
                }

                // UTF-8 safe base64 decode
                const cleanContent = fileData.content.replace(/\n/g, '');
                const bytes = Uint8Array.from(atob(cleanContent), c => c.charCodeAt(0));
                const content = new TextDecoder().decode(bytes);
                const data = JSON.parse(content);

                STATE.data = data;
                STATE.originalData = JSON.parse(JSON.stringify(data));
                STATE.fileSha = fileData.sha;

                console.log('Loaded tasks from GitHub:', data.tasks.length, 'tasks');
                showToast('success', `‚úì Loaded ${data.tasks.length} tasks from GitHub`);

            } catch (error) {
                console.error('Error loading from GitHub:', error);
                // CRITICAL DEBUG: Show alert so user sees it
                alert(`GitHub Error:\n${error.message}\n\nCheck token permissions!`);
                showToast('error', `GitHub Error: ${error.message}`);
                STATE.data = JSON.parse(JSON.stringify(FALLBACK_DATA));
            }

            STATE.isLoading = false;
            renderAll();
        }

        async function saveTasksToGitHub(commitMessage) {
            // PROXY MODE
            if (CONFIG.useProxy) {
                try {
                    const response = await fetch(proxyUrl('/api/tasks'), {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(STATE.data)
                    });
                    
                    if (!response.ok) throw new Error('Save failed');
                    
                    STATE.originalData = JSON.parse(JSON.stringify(STATE.data));
                    STATE.hasUnsavedChanges = false;
                    document.getElementById('unsaved-banner').classList.remove('visible');
                    showToast('success', '‚úì Saved to Server');
                    return true;
                } catch (error) {
                    showToast('error', 'Save failed');
                    return false;
                }
            }

            if (!STATE.token || !STATE.data) {
                showToast('error', 'Not logged in');
                return false;
            }

            try {
                const content = btoa(unescape(encodeURIComponent(JSON.stringify(STATE.data, null, 2))));

                const response = await fetch(
                    `https://api.github.com/repos/${CONFIG.owner}/${CONFIG.repo}/contents/${CONFIG.tasksFile}`,
                    {
                        method: 'PUT',
                        headers: {
                            'Authorization': `token ${STATE.token}`,
                            'Accept': 'application/vnd.github.v3+json',
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            message: commitMessage || 'Update tasks via Mission Control',
                            content: content,
                            sha: STATE.fileSha,
                            branch: CONFIG.branch
                        })
                    }
                );

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.message || 'Failed to save');
                }

                const result = await response.json();
                STATE.fileSha = result.content.sha;
                STATE.originalData = JSON.parse(JSON.stringify(STATE.data));
                STATE.hasUnsavedChanges = false;
                document.getElementById('unsaved-banner').classList.remove('visible');

                showToast('success', '‚úì Saved to GitHub!');
                return true;

            } catch (error) {
                console.error('Error saving to GitHub:', error);
                showToast('error', `Failed to save: ${error.message}`);
                return false;
            }
        }

        function renderAll() {
            ensureTodos();
            renderFilters();
            renderTasks();
            renderTodos();
            renderCrons();
            renderTemplates();
            renderScheduledTasks();
            renderActivity();
            updateStats();
            updateProjectDropdown();
            
            // Initialize mobile column selector after rendering
            if (window.innerWidth <= 640) {
                initMobileColumnSelector();
            }
        }

        // === CRON RENDERING ===
        async function loadCronsFromGitHub() {
            try {
                const token = STATE.token || localStorage.getItem('gh_token');
                const response = await fetch(
                    `https://api.github.com/repos/${CONFIG.owner}/${CONFIG.repo}/contents/data/crons.json`,
                    { headers: { 'Authorization': `token ${token}` } }
                );
                
                if (response.ok) {
                    const data = await response.json();
                    const content = JSON.parse(decodeURIComponent(escape(atob(data.content))));
                    STATE.crons = content.crons || [];
                    STATE.cronsSha = data.sha; // Save SHA for later updates
                    renderCrons();
                }
            } catch (e) {
                console.log('No crons.json found or error loading:', e);
                STATE.crons = [];
            }
        }
        
        // Save crons to GitHub (for fallback when Gateway unavailable)
        async function saveCronsToGitHub(commitMessage) {
            if (!STATE.token) {
                showToast('error', 'Not logged in - cannot save crons');
                return false;
            }
            
            try {
                const content = btoa(unescape(encodeURIComponent(JSON.stringify({ crons: STATE.crons }, null, 2))));
                
                const response = await fetch(
                    `https://api.github.com/repos/${CONFIG.owner}/${CONFIG.repo}/contents/data/crons.json`,
                    {
                        method: 'PUT',
                        headers: {
                            'Authorization': `token ${STATE.token}`,
                            'Accept': 'application/vnd.github.v3+json',
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            message: commitMessage || 'Update crons via Mission Control',
                            content: content,
                            sha: STATE.cronsSha,
                            branch: CONFIG.branch
                        })
                    }
                );
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.message || 'Failed to save crons');
                }
                
                const result = await response.json();
                STATE.cronsSha = result.content.sha;
                return true;
                
            } catch (error) {
                console.error('Error saving crons to GitHub:', error);
                showToast('error', `Failed to save crons: ${error.message}`);
                return false;
            }
        }

        function renderCrons() {
            const container = document.getElementById('tasks-recurring');
            const countEl = document.getElementById('count-recurring');
            const crons = STATE.crons || [];
            
            countEl.textContent = crons.filter(c => c.enabled).length;
            
            if (crons.length === 0) {
                container.innerHTML = '<div class="empty-state">No recurring jobs</div>';
                return;
            }
            
            container.innerHTML = crons.map(cron => {
                const statusClass = cron.pending ? 'pending' :
                                   !cron.enabled ? 'disabled' : 
                                   cron.lastStatus === 'error' ? 'error' : 
                                   isRunning(cron) ? 'running' : 'ok';
                const statusText = cron.pending ? 'Pending sync' :
                                  !cron.enabled ? 'Disabled' :
                                  isRunning(cron) ? 'Running...' :
                                  cron.lastStatus === 'error' ? 'Error' : 'Active';
                const nextRun = cron.pending ? '‚è≥' : (cron.nextRunAt ? formatRelativeTime(new Date(cron.nextRunAt)) : 'N/A');
                
                return `
                    <div class="cron-card" 
                         data-cron-id="${cron.id}"
                         draggable="true"
                         ondragstart="handleCronDragStart(event, '${cron.id}')"
                         ondragend="handleCronDragEnd(event)"
                         onclick="openCronDetail('${cron.id}')">
                        <div class="cron-name">${cron.name}</div>
                        <div class="cron-schedule">${cron.scheduleHuman || cron.schedule}</div>
                        <div class="cron-status">
                            <span class="cron-status-dot ${statusClass}"></span>
                            <span>${statusText}</span>
                        </div>
                        <div class="cron-next">Next: ${nextRun}</div>
                    </div>
                `;
            }).join('');
        }

        function isRunning(cron) {
            if (!cron.nextRunAt) return false;
            const nextRun = new Date(cron.nextRunAt).getTime();
            const now = Date.now();
            // Smart running detection:
            // 1. nextRunAt is in the past (job should have started)
            // 2. Within expected duration window (avgDurationMs or fallback to 5 min)
            const expectedDuration = cron.avgDurationMs || 300000; // Default 5 minutes
            const maxRunTime = Math.max(expectedDuration, 60000); // At least 1 minute window
            return nextRun <= now && (now - nextRun) < maxRunTime;
        }

        function formatRelativeTime(date) {
            const now = new Date();
            const diff = date - now;
            const minutes = Math.floor(diff / 60000);
            const hours = Math.floor(diff / 3600000);
            const days = Math.floor(diff / 86400000);
            
            if (diff < 0) return 'overdue';
            if (minutes < 60) return `in ${minutes}m`;
            if (hours < 24) return `in ${hours}h`;
            return `in ${days}d`;
        }

        // === AUTH FUNCTIONS ===
        function showAuthModal() {
            document.getElementById('auth-modal').classList.add('visible');
            document.getElementById('token-input').focus();
        }

        function hideAuthModal() {
            document.getElementById('auth-modal').classList.remove('visible');
            document.getElementById('token-input').value = '';
            hideValidationStates();
        }

        function hideValidationStates() {
            document.getElementById('validation-loading').classList.remove('visible');
            document.getElementById('validation-success').classList.remove('visible');
            document.getElementById('validation-error').classList.remove('visible');
        }

        async function validateAndSaveToken() {
            const token = document.getElementById('token-input').value.trim();

            if (!token) {
                showValidationError('Please enter a token');
                return;
            }

            hideValidationStates();
            document.getElementById('validation-loading').classList.add('visible');
            document.getElementById('btn-save-token').disabled = true;

            try {
                // Validate token by fetching user info
                const response = await fetch('https://api.github.com/user', {
                    headers: {
                        'Authorization': `token ${token}`,
                        'Accept': 'application/vnd.github.v3+json'
                    }
                });

                if (!response.ok) {
                    throw new Error('Invalid token');
                }

                const user = await response.json();

                // Check repo access
                const repoResponse = await fetch(`https://api.github.com/repos/${CONFIG.owner}/${CONFIG.repo}`, {
                    headers: {
                        'Authorization': `token ${token}`,
                        'Accept': 'application/vnd.github.v3+json'
                    }
                });

                if (!repoResponse.ok) {
                    throw new Error('No access to repository. Make sure you have "repo" scope.');
                }

                // Success!
                document.getElementById('validation-loading').classList.remove('visible');
                document.getElementById('validation-success').classList.add('visible');
                document.getElementById('validated-user').textContent = user.login;

                // Save to localStorage
                localStorage.setItem('github_token', token);
                localStorage.setItem('github_user', JSON.stringify({
                    login: user.login,
                    avatar_url: user.avatar_url,
                    name: user.name || user.login
                }));

                STATE.token = token;
                STATE.user = user;

                // Update UI and load data
                setTimeout(async () => {
                    hideAuthModal();
                    updateAuthUI();
                    await loadTasksFromGitHub();
                    await loadCronsFromGitHub();
                }, 1000);

            } catch (error) {
                showValidationError(error.message);
            }
        }

        function showValidationError(message) {
            document.getElementById('validation-loading').classList.remove('visible');
            document.getElementById('validation-error').classList.add('visible');
            document.getElementById('error-message').textContent = message;
            document.getElementById('btn-save-token').disabled = false;
        }

        function logout() {
            localStorage.removeItem('github_token');
            localStorage.removeItem('github_user');
            STATE.token = null;
            STATE.user = null;
            STATE.data = JSON.parse(JSON.stringify(FALLBACK_DATA));
            STATE.hasUnsavedChanges = false;
            document.getElementById('unsaved-banner').classList.remove('visible');
            updateAuthUI();
            renderAll();
            showToast('success', 'Logged out');
        }

        function updateAuthUI() {
            const connectBtn = document.getElementById('btn-connect');
            const userProfile = document.getElementById('user-profile');

            if (STATE.user) {
                connectBtn.style.display = 'none';
                userProfile.style.display = 'flex';
                document.getElementById('user-avatar').src = STATE.user.avatar_url;
                document.getElementById('user-name').textContent = STATE.user.name || STATE.user.login;
            } else {
                connectBtn.style.display = 'inline-flex';
                userProfile.style.display = 'none';
            }
        }

        function checkSavedAuth() {
            const token = localStorage.getItem('github_token');
            const userJson = localStorage.getItem('github_user');

            if (token && userJson) {
                STATE.token = token;
                STATE.user = JSON.parse(userJson);
                updateAuthUI();
            }
        }

        // === TOKEN INPUT HANDLING ===
        document.getElementById('token-input').addEventListener('input', function() {
            const value = this.value.trim();
            document.getElementById('btn-save-token').disabled = !value;
            hideValidationStates();
        });

        document.getElementById('token-input').addEventListener('keypress', function(e) {
            if (e.key === 'Enter' && this.value.trim()) {
                validateAndSaveToken();
            }
        });

        // === TOAST NOTIFICATIONS ===
        function showToast(type, message) {
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.innerHTML = `
                <span>${type === 'success' ? '‚úì' : '‚úó'}</span>
                <span>${message}</span>
            `;
            container.appendChild(toast);

            setTimeout(() => {
                toast.remove();
            }, 3000);
        }

        // === MARKDOWN RENDERER ===
        function renderMarkdown(text) {
            if (!text) return '';
            
            // Escape HTML first to prevent XSS
            let html = text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
            
            // Bold: **text** or __text__
            html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
            html = html.replace(/__(.+?)__/g, '<strong>$1</strong>');
            
            // Italic: *text* or _text_ (but not inside words)
            html = html.replace(/(?<!\w)\*(?!\*)(.+?)(?<!\*)\*(?!\w)/g, '<em>$1</em>');
            html = html.replace(/(?<!\w)_(?!_)(.+?)(?<!_)_(?!\w)/g, '<em>$1</em>');
            
            // Inline code: `code`
            html = html.replace(/`([^`]+)`/g, '<code style="background: var(--bg-secondary); padding: 2px 6px; border-radius: 3px; font-family: monospace; font-size: 0.9em;">$1</code>');
            
            // Links: [text](url)
            html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" style="color: var(--accent-blue);">$1</a>');
            
            // URLs without markdown (auto-link)
            html = html.replace(/(^|[^"=])(https?:\/\/[^\s<]+)/g, '$1<a href="$2" target="_blank" style="color: var(--accent-blue);">$2</a>');
            
            // Checkboxes: ‚úÖ and ‚òëÔ∏è (already rendered, just style them)
            // Keep emojis as-is
            
            // Tables: | col | col |
            if (html.includes('|') && html.split('\n').some(line => line.trim().startsWith('|'))) {
                const lines = html.split('\n');
                let inTable = false;
                let tableHtml = '';
                const result = [];
                
                for (const line of lines) {
                    const trimmed = line.trim();
                    if (trimmed.startsWith('|') && trimmed.endsWith('|')) {
                        if (!inTable) {
                            inTable = true;
                            tableHtml = '<table style="border-collapse: collapse; margin: 8px 0; font-size: 0.85em; width: 100%;">';
                        }
                        // Skip separator rows (|---|---|)
                        if (trimmed.match(/^\|[\s\-:]+\|$/)) continue;
                        
                        const cells = trimmed.slice(1, -1).split('|').map(c => c.trim());
                        const isHeader = !tableHtml.includes('<tr>');
                        const cellTag = isHeader ? 'th' : 'td';
                        const cellStyle = isHeader 
                            ? 'style="border: 1px solid var(--border); padding: 6px 10px; background: var(--bg-secondary); text-align: left;"'
                            : 'style="border: 1px solid var(--border); padding: 6px 10px;"';
                        tableHtml += `<tr>${cells.map(c => `<${cellTag} ${cellStyle}>${c}</${cellTag}>`).join('')}</tr>`;
                    } else {
                        if (inTable) {
                            inTable = false;
                            tableHtml += '</table>';
                            result.push(tableHtml);
                            tableHtml = '';
                        }
                        result.push(line);
                    }
                }
                if (inTable) {
                    tableHtml += '</table>';
                    result.push(tableHtml);
                }
                html = result.join('\n');
            }
            
            // Line breaks
            html = html.replace(/\n/g, '<br>');
            
            return html;
        }

        // === RENDER FUNCTIONS ===
        function renderTasks(animate = false) {
            const columns = ['permanent', 'backlog', 'in_progress', 'review', 'done'];
            const data = STATE.data || FALLBACK_DATA;
            const priorityOrder = { high: 0, medium: 1, low: 2 };

            // FLIP Animation: Capture old positions
            const oldPositions = {};
            if (animate) {
                document.querySelectorAll('.task-card').forEach(card => {
                    const taskId = card.getAttribute('data-task-id');
                    if (taskId) {
                        oldPositions[taskId] = card.getBoundingClientRect();
                    }
                });
            }

            columns.forEach(status => {
                const container = document.getElementById(`tasks-${status}`);
                let tasks = data.tasks.filter(t => t.status === status && !t.isTemplate && t.status !== 'scheduled');

                // Filter out archived tasks (unless searching with archive enabled)
                if (!(showArchivedInSearch && searchQuery)) {
                    tasks = tasks.filter(t => !t.archived);
                }

                // Apply project filter
                if (currentFilter !== 'all') {
                    tasks = tasks.filter(t => t.project === currentFilter || (t.tags && t.tags.includes(currentFilter)));
                }

                // Sort: Done column by completedAt (newest first), others by priority + sortOrder
                if (status === 'done') {
                    // Done: newest completed tasks first
                    tasks.sort((a, b) => {
                        const dateA = a.completedAt ? new Date(a.completedAt).getTime() : 0;
                        const dateB = b.completedAt ? new Date(b.completedAt).getTime() : 0;
                        return dateB - dateA; // Descending (newest first)
                    });
                } else {
                    // Other columns: priority first, then sortOrder
                    tasks.sort((a, b) => {
                        const prioA = priorityOrder[a.priority] ?? 1;
                        const prioB = priorityOrder[b.priority] ?? 1;
                        if (prioA !== prioB) return prioA - prioB;
                        const orderA = a.sortOrder ?? 999999;
                        const orderB = b.sortOrder ?? 999999;
                        return orderA - orderB;
                    });
                }

                const count = document.getElementById(`count-${status}`);
                count.textContent = tasks.length;
                container.innerHTML = tasks.length === 0
                    ? '<div class="empty-state">No tasks</div>'
                    : tasks.map(renderTaskCard).join('');
            });

            // FLIP Animation: Animate from old to new positions
            if (animate && Object.keys(oldPositions).length > 0) {
                document.querySelectorAll('.task-card').forEach(card => {
                    const taskId = card.getAttribute('data-task-id');
                    if (taskId && oldPositions[taskId]) {
                        const oldPos = oldPositions[taskId];
                        const newPos = card.getBoundingClientRect();
                        const deltaY = oldPos.top - newPos.top;

                        if (Math.abs(deltaY) > 5) {
                            card.style.transform = `translateY(${deltaY}px)`;
                            card.style.transition = 'none';

                            requestAnimationFrame(() => {
                                card.style.transition = 'transform 0.4s cubic-bezier(0.2, 0, 0.2, 1)';
                                card.style.transform = 'translateY(0)';
                            });
                        }
                    }
                });
            }

            updateStats();
            
            // Re-apply search filter after rendering
            if (searchQuery) {
                applySearchFilter();
            }
            
            // Re-initialize Lucide icons after DOM update
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        }

        function renderTaskCard(task) {
            const subtasksDone = task.subtasks.filter(s => s.done).length;
            const subtasksTotal = task.subtasks.length;
            const progress = subtasksTotal > 0 ? Math.round((subtasksDone / subtasksTotal) * 100) : 0;
            const commentsCount = (task.comments || []).length;
            const voiceNotesCount = (task.comments || []).filter(c => c.type === 'voice_note').length;
            const isArchived = task.archived === true;

            // Review actions
            const reviewActions = task.status === 'review' ? `
                <div class="task-actions" onclick="event.stopPropagation()">
                    <button class="task-action-btn done" onclick="quickMoveTask('${task.id}', 'done')" title="Mark as Done">‚úì Done</button>
                    <button class="task-action-btn backlog" onclick="quickMoveTask('${task.id}', 'backlog')" title="Move to Backlog">‚Ü© Backlog</button>
                </div>
            ` : '';

            // Archive/Unarchive actions for done tasks
            const archiveActions = task.status === 'done' && !isArchived ? `
                <div class="task-actions" onclick="event.stopPropagation()">
                    <button class="task-action-btn archive" onclick="archiveTask('${task.id}')" title="Archive this task">üì¶ Archive</button>
                </div>
            ` : '';

            // Unarchive button for archived tasks
            const unarchiveActions = isArchived ? `
                <div class="task-actions" onclick="event.stopPropagation()">
                    <button class="task-action-btn unarchive" onclick="unarchiveTask('${task.id}')" title="Restore from archive">üì§ Unarchive</button>
                </div>
            ` : '';

            // Archived badge
            const archivedBadge = isArchived ? `
                <span class="archived-badge">üì¶ Archived</span>
            ` : '';

            // Comment indicator
            const commentIndicator = commentsCount > 0 ? `
                <div class="task-comment-indicator" title="${commentsCount} comment${commentsCount > 1 ? 's' : ''}">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
                    </svg>
                    <span>${commentsCount}</span>
                </div>
            ` : '';
            
            // Voice note indicator
            const voiceNoteIndicator = voiceNotesCount > 0 ? `
                <div class="task-comment-indicator" title="${voiceNotesCount} voice note${voiceNotesCount > 1 ? 's' : ''}" style="color: var(--accent-blue);">
                    üé§ <span>${voiceNotesCount}</span>
                </div>
            ` : '';
            
            // Voice note button (shown on hover, for adding voice notes to task)
            const voiceNoteButton = !isArchived ? `
                <button class="voice-note-btn" onclick="event.stopPropagation(); openVoiceNoteModal('${task.id}')" title="Add voice note">
                    üé§
                </button>
            ` : '';
            
            // Processing spinner (shown when agent is working on this task)
            const isProcessing = (task.processingStartedAt || task.processing) && task.status === 'in_progress';
            let processingIndicator = '';
            let processingCardClass = '';
            
            if (isProcessing) {
                const startTime = new Date(task.processingStartedAt || Date.now());
                const now = new Date();
                const minutesElapsed = Math.floor((now - startTime) / 60000);
                const isTimeout = minutesElapsed >= 30;
                
                // Format time display
                let timeDisplay = '';
                if (minutesElapsed < 1) {
                    timeDisplay = 'just started';
                } else if (minutesElapsed < 60) {
                    timeDisplay = `${minutesElapsed} min`;
                } else {
                    const hours = Math.floor(minutesElapsed / 60);
                    const mins = minutesElapsed % 60;
                    timeDisplay = `${hours}h ${mins}m`;
                }
                
                // Set card class for border effect
                processingCardClass = isTimeout ? 'processing-timeout' : 'processing-active';
                
                // Different text for cron execution tasks
                const spinnerText = task.isCronExecution ? 'Executing...' : 'Processing...';
                
                processingIndicator = `
                    <div class="task-processing${isTimeout ? ' timeout-warning' : ''}" title="${isTimeout ? '‚ö†Ô∏è Processing for over 30 minutes!' : 'Jeannie is working on this task...'}">
                        <div class="processing-spinner"></div>
                        <span>${spinnerText}</span>
                        <span class="processing-time">(${timeDisplay})</span>
                    </div>
                `;
            }

            return `
                <div class="task-card priority-${task.priority}${isArchived ? ' archived' : ''}${processingCardClass ? ' ' + processingCardClass : ''}" data-task-id="${task.id}"
                     draggable="${!isArchived}"
                     ondragstart="handleDragStart(event, '${task.id}')"
                     ondragend="handleDragEnd(event)"
                     onclick="openTaskDetail('${task.id}')">
                    <div class="task-title">
                        <span class="task-title-text">${task.title}</span>
                        ${archivedBadge}
                    </div>
                    ${processingIndicator}
                    <div class="task-description">${task.description}</div>
                    <div class="task-meta">
                        <div class="task-tags">
                            ${task.tags.map(tag => `<span class="task-tag ${tag}">${tag}</span>`).join('')}
                        </div>
                        ${voiceNoteIndicator}
                        ${commentIndicator}
                        ${voiceNoteButton}
                    </div>
                    ${subtasksTotal > 0 ? `
                        <div class="task-subtasks">
                            <div class="subtask-progress">
                                <span>${subtasksDone}/${subtasksTotal}</span>
                                <div class="progress-bar">
                                    <div class="progress-fill" style="width: ${progress}%"></div>
                                </div>
                                <span>${progress}%</span>
                            </div>
                        </div>
                    ` : ''}
                    ${reviewActions}
                    ${archiveActions}
                    ${unarchiveActions}
                </div>
            `;
        }

        function quickMoveTask(taskId, newStatus) {
            const task = STATE.data.tasks.find(t => t.id === taskId);
            if (task) {
                const oldStatus = task.status;
                task.status = newStatus;
                // Set completedAt when moving to done
                if (newStatus === 'done') {
                    task.completedAt = new Date().toISOString();
                } else if (oldStatus === 'done') {
                    delete task.completedAt; // Remove if moving out of done
                }
                STATE.data.lastUpdated = new Date().toISOString();
                renderTasks();

                // AUTO-SAVE
                autoSave(`Move "${task.title}" ‚Üí ${newStatus}`);
            }
        }

        // === DRAG & DROP (Trello-style smooth) ===
        let draggedTaskId = null;
        let draggedElement = null;
        let dropTargetInfo = null;
        let lastDropTargetInfo = null;
        let dragOverThrottle = null;

        function handleDragStart(event, taskId) {
            draggedTaskId = taskId;
            draggedElement = event.target;

            // Small delay before adding dragging class for smoother pickup
            requestAnimationFrame(() => {
                event.target.classList.add('dragging');
            });

            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', taskId);
        }

        function handleDragEnd(event) {
            event.target.classList.remove('dragging');

            // Clear all space indicators
            document.querySelectorAll('.task-card').forEach(card => {
                card.classList.remove('make-space-above', 'make-space-below');
            });
            document.querySelectorAll('.column-tasks').forEach(col => {
                col.classList.remove('drag-over');
            });
            document.querySelectorAll('.drop-indicator').forEach(el => {
                el.classList.remove('visible');
            });

            draggedTaskId = null;
            draggedElement = null;
            dropTargetInfo = null;
            lastDropTargetInfo = null;
        }

        function handleDragOver(event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';

            // Throttle to reduce jank
            if (dragOverThrottle) return;
            dragOverThrottle = setTimeout(() => { dragOverThrottle = null; }, 50);

            const container = event.currentTarget;

            // Only add drag-over to the hovered container
            document.querySelectorAll('.column-tasks').forEach(col => {
                if (col !== container) col.classList.remove('drag-over');
            });
            container.classList.add('drag-over');

            // Find insert position based on mouse Y
            const cards = [...container.querySelectorAll('.task-card:not(.dragging)')];
            const mouseY = event.clientY;

            // Clear space classes from cards not in this container
            document.querySelectorAll('.column-tasks').forEach(col => {
                if (col !== container) {
                    col.querySelectorAll('.task-card').forEach(card => {
                        card.classList.remove('make-space-above', 'make-space-below');
                    });
                }
            });

            // Find which card we're hovering over/between
            let insertBeforeId = null;
            let insertIndex = cards.length;
            let targetCard = null;

            for (let i = 0; i < cards.length; i++) {
                const card = cards[i];
                const rect = card.getBoundingClientRect();
                const cardMiddle = rect.top + rect.height / 2;

                if (mouseY < cardMiddle) {
                    insertBeforeId = card.getAttribute('data-task-id');
                    insertIndex = i;
                    targetCard = card;
                    break;
                }
            }

            // Check if position changed
            const newDropInfo = JSON.stringify({ insertBeforeId, insertIndex, containerId: container.id });
            if (newDropInfo === JSON.stringify(lastDropTargetInfo)) return;
            lastDropTargetInfo = { insertBeforeId, insertIndex, containerId: container.id };

            // Clear all space classes in this container first
            cards.forEach(card => {
                card.classList.remove('make-space-above', 'make-space-below');
            });

            // Add space above the target card (Trello-style gap opening)
            if (targetCard) {
                targetCard.classList.add('make-space-above');
            }

            dropTargetInfo = { insertBeforeId, insertIndex };
        }

        function handleDragLeave(event) {
            // Only remove if actually leaving the container (not entering a child)
            const rect = event.currentTarget.getBoundingClientRect();
            const x = event.clientX;
            const y = event.clientY;

            if (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {
                event.currentTarget.classList.remove('drag-over');
                event.currentTarget.querySelectorAll('.task-card').forEach(card => {
                    card.classList.remove('make-space-above', 'make-space-below');
                });
            }
        }

        function handleDrop(event, newStatus) {
            event.preventDefault();

            const container = event.currentTarget;
            container.classList.remove('drag-over');

            // Clear all spacing classes
            document.querySelectorAll('.task-card').forEach(card => {
                card.classList.remove('make-space-above', 'make-space-below');
            });

            if (!draggedTaskId || !STATE.user) return;

            const task = STATE.data.tasks.find(t => t.id === draggedTaskId);
            if (!task) return;

            const oldStatus = task.status;
            const statusChanged = task.status !== newStatus;
            task.status = newStatus;

            // Set completedAt when moving to done
            if (newStatus === 'done') {
                task.completedAt = new Date().toISOString();
            } else if (oldStatus === 'done') {
                delete task.completedAt;
            }

            // Calculate new sortOrder based on drop position
            const priorityOrder = { high: 0, medium: 1, low: 2 };
            let tasksInColumn = STATE.data.tasks
                .filter(t => t.status === newStatus && t.id !== task.id)
                .sort((a, b) => {
                    const prioA = priorityOrder[a.priority] ?? 1;
                    const prioB = priorityOrder[b.priority] ?? 1;
                    if (prioA !== prioB) return prioA - prioB;
                    return (a.sortOrder ?? 999999) - (b.sortOrder ?? 999999);
                });

            // Find insert position
            let insertIdx = tasksInColumn.length;
            if (dropTargetInfo?.insertBeforeId) {
                const targetIdx = tasksInColumn.findIndex(t => t.id === dropTargetInfo.insertBeforeId);
                if (targetIdx >= 0) insertIdx = targetIdx;
            }

            // Insert task at position
            tasksInColumn.splice(insertIdx, 0, task);

            // Recalculate sortOrder for all tasks in this column (within same priority groups)
            let currentPriority = null;
            let orderCounter = 0;
            tasksInColumn.forEach(t => {
                if (t.priority !== currentPriority) {
                    currentPriority = t.priority;
                    orderCounter = 0;
                }
                t.sortOrder = orderCounter++;
            });

            STATE.data.lastUpdated = new Date().toISOString();

            // Add activity if status changed
            if (statusChanged) {
                STATE.data.activities = STATE.data.activities || [];
                STATE.data.activities.unshift({
                    type: 'moved',
                    actor: STATE.user?.login || 'User',
                    task: task.title,
                    from: oldStatus,
                    to: newStatus,
                    time: 'just now'
                });
                renderActivity();
            }

            // Smooth re-render without full board animation
            renderTasksSmooth(oldStatus, newStatus, task.id);

            // AUTO-SAVE
            const action = statusChanged
                ? `Move "${task.title}" ‚Üí ${newStatus}`
                : `Reorder "${task.title}"`;
            autoSave(action);

            dropTargetInfo = null;
            lastDropTargetInfo = null;
        }

        // Smooth render that only animates affected columns
        function renderTasksSmooth(oldStatus, newStatus, movedTaskId) {
            const affectedColumns = oldStatus === newStatus
                ? [newStatus]
                : [oldStatus, newStatus];

            const priorityOrder = { high: 0, medium: 1, low: 2 };
            const data = STATE.data || FALLBACK_DATA;

            // Capture old positions for FLIP animation
            const oldPositions = {};
            affectedColumns.forEach(status => {
                const container = document.getElementById(`tasks-${status}`);
                container.querySelectorAll('.task-card').forEach(card => {
                    const taskId = card.getAttribute('data-task-id');
                    if (taskId) {
                        oldPositions[taskId] = card.getBoundingClientRect();
                    }
                });
            });

            // Re-render only affected columns
            affectedColumns.forEach(status => {
                const container = document.getElementById(`tasks-${status}`);
                let tasks = data.tasks.filter(t => t.status === status);

                // Apply project filter
                if (currentFilter !== 'all') {
                    tasks = tasks.filter(t => t.project === currentFilter || (t.tags && t.tags.includes(currentFilter)));
                }

                // Sort: Done column by completedAt (newest first), others by priority + sortOrder
                if (status === 'done') {
                    tasks.sort((a, b) => {
                        const dateA = a.completedAt ? new Date(a.completedAt).getTime() : 0;
                        const dateB = b.completedAt ? new Date(b.completedAt).getTime() : 0;
                        return dateB - dateA;
                    });
                } else {
                    tasks.sort((a, b) => {
                        const prioA = priorityOrder[a.priority] ?? 1;
                        const prioB = priorityOrder[b.priority] ?? 1;
                        if (prioA !== prioB) return prioA - prioB;
                        return (a.sortOrder ?? 999999) - (b.sortOrder ?? 999999);
                    });
                }

                // Update count
                const count = document.getElementById(`count-${status}`);
                count.textContent = tasks.length;

                // Disable transitions during DOM update
                container.classList.add('no-transition');
                container.innerHTML = tasks.length === 0
                    ? '<div class="empty-state">No tasks</div>'
                    : tasks.map(renderTaskCard).join('');

                // Force reflow
                container.offsetHeight;
                container.classList.remove('no-transition');
            });

            // FLIP animation for smooth movement
            requestAnimationFrame(() => {
                affectedColumns.forEach(status => {
                    const container = document.getElementById(`tasks-${status}`);
                    container.querySelectorAll('.task-card').forEach(card => {
                        const taskId = card.getAttribute('data-task-id');
                        if (taskId && oldPositions[taskId]) {
                            const oldPos = oldPositions[taskId];
                            const newPos = card.getBoundingClientRect();
                            // Only animate Y-axis (vertical) - no horizontal movement
                            const deltaY = oldPos.top - newPos.top;

                            if (Math.abs(deltaY) > 5) {
                                card.style.transform = `translateY(${deltaY}px)`;
                                card.style.transition = 'none';

                                requestAnimationFrame(() => {
                                    card.style.transition = 'transform 0.25s cubic-bezier(0.2, 0, 0.2, 1)';
                                    card.style.transform = 'translateY(0)';
                                });
                            }
                        } else if (taskId === movedTaskId) {
                            // New card entering - just fade in, no scale
                            card.style.opacity = '0';
                            requestAnimationFrame(() => {
                                card.style.transition = 'opacity 0.2s ease';
                                card.style.opacity = '1';
                            });
                        }
                    });
                });
            });

            updateStats();
        }

        // === AUTO-SAVE FUNKTION ===
        async function autoSave(action) {
            if (!STATE.token || !STATE.user) {
                showToast('warning', 'Not logged in - changes not saved');
                markAsChanged();
                return;
            }

            const commitMessage = `${action} (via Mission Control)`;
            showToast('info', 'üíæ Saving...');

            const success = await saveTasksToGitHub(commitMessage);
            if (!success) {
                markAsChanged(); // Show "unsaved changes" if failed
            }
        }

        function renderActivity() {
            const container = document.getElementById('activity-list');
            const data = STATE.data || FALLBACK_DATA;
            const activities = data.activities || FALLBACK_DATA.activities;
            container.innerHTML = activities.map(a => `
                <div class="activity-item">
                    <div class="activity-dot ${a.type}"></div>
                    <div class="activity-content">
                        <span class="activity-actor">${a.actor}</span>
                        <span class="activity-action">${getActionText(a)}</span>
                        <span class="activity-task">${a.task}</span>
                        <div class="activity-time">${a.time}</div>
                    </div>
                </div>
            `).join('');
        }

        function getActionText(activity) {
            switch(activity.type) {
                case 'created': return ' created ';
                case 'moved': return ` moved to ${activity.to} `;
                case 'completed': return ' completed ';
                case 'deleted': return ' deleted ';
                case 'archive': return ' archived ';
                case 'unarchive': return ' unarchived ';
                default: return ' updated ';
            }
        }

        // Add activity to the activity feed
        function addActivity(text, type = 'updated') {
            STATE.data.activities = STATE.data.activities || [];
            
            // Parse the text to extract task name (format: "üì¶ Archived: Task Name" or similar)
            const taskMatch = text.match(/:\s*(.+)$/) || text.match(/Archived\s+\d+\s+tasks?/);
            const taskName = taskMatch ? taskMatch[1] || taskMatch[0] : text;
            
            STATE.data.activities.unshift({
                type: type,
                actor: STATE.user?.login || 'User',
                task: taskName,
                time: 'just now'
            });
            
            renderActivity();
        }

        function renderFilters() {
            const container = document.getElementById('filters');
            const data = STATE.data || FALLBACK_DATA;
            const projects = data.projects || FALLBACK_DATA.projects;
            const projectButtons = projects.map(p =>
                `<button class="filter-btn" data-filter="${p.id}" onclick="filterByProject('${p.id}')">${p.icon} ${p.name}</button>`
            ).join('');
            container.innerHTML = `
                <button class="filter-btn active" data-filter="all" onclick="filterByProject('all')">All projects</button>
                ${projectButtons}
            `;
        }

        let currentFilter = 'all';
        let searchQuery = '';
        let showArchivedInSearch = false;

        // === ARCHIVE FUNCTIONS ===
        function archiveTask(taskId) {
            const task = STATE.data.tasks.find(t => t.id === taskId);
            if (task) {
                task.archived = true;
                task.archivedAt = new Date().toISOString();
                addActivity(`üì¶ Archived: ${task.title}`, 'archive');
                renderTasks();
                saveToGitHub();
            }
        }

        function unarchiveTask(taskId) {
            const task = STATE.data.tasks.find(t => t.id === taskId);
            if (task) {
                delete task.archived;
                delete task.archivedAt;
                // Move back to done or backlog
                task.status = 'done';
                addActivity(`üì§ Unarchived: ${task.title}`, 'unarchive');
                renderTasks();
                saveToGitHub();
            }
        }

        function archiveAllDone() {
            const doneTasks = STATE.data.tasks.filter(t => t.status === 'done' && !t.archived);
            if (doneTasks.length === 0) {
                showToast('No tasks to archive', 'info');
                return;
            }
            
            const count = doneTasks.length;
            doneTasks.forEach(task => {
                task.archived = true;
                task.archivedAt = new Date().toISOString();
            });
            
            addActivity(`üì¶ Archived ${count} task${count > 1 ? 's' : ''} from Done`, 'archive');
            renderTasks();
            autoSave(`Archive ${count} task${count > 1 ? 's' : ''}`);
            showToast(`Archived ${count} task${count > 1 ? 's' : ''}`, 'success');
            
            // Check if we need to move old tasks to archive files
            checkAndMoveOldArchivedTasks();
        }
        
        // === TASK 6: ARCHIV-STRATEGIE ===
        let archivedTasksLoaded = false;
        let archiveIndex = null;
        
        async function checkAndMoveOldArchivedTasks() {
            const now = new Date();
            const cutoffDate = new Date(now.getTime() - (90 * 24 * 60 * 60 * 1000)); // 90 days ago
            
            const oldArchivedTasks = STATE.data.tasks.filter(t => 
                t.archived && 
                t.archivedAt && 
                new Date(t.archivedAt) < cutoffDate
            );
            
            if (oldArchivedTasks.length === 0) return;
            
            // Group by month
            const byMonth = {};
            oldArchivedTasks.forEach(task => {
                const date = new Date(task.archivedAt);
                const key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                if (!byMonth[key]) byMonth[key] = [];
                byMonth[key].push(task);
            });
            
            console.log(`Moving ${oldArchivedTasks.length} old archived tasks to archive files`);
            
            // For now, just mark them as offloaded (actual file operations would need backend)
            oldArchivedTasks.forEach(task => {
                task.offloadedToArchive = true;
            });
            
            // Update archive index
            await updateArchiveIndex(byMonth);
        }
        
        async function updateArchiveIndex(byMonth) {
            if (!archiveIndex) {
                archiveIndex = { archives: {}, lastUpdated: null };
            }
            
            Object.keys(byMonth).forEach(monthKey => {
                if (!archiveIndex.archives[monthKey]) {
                    archiveIndex.archives[monthKey] = { count: 0, tasks: [] };
                }
                archiveIndex.archives[monthKey].count += byMonth[monthKey].length;
                archiveIndex.archives[monthKey].tasks.push(...byMonth[monthKey].map(t => ({
                    id: t.id,
                    title: t.title,
                    archivedAt: t.archivedAt
                })));
            });
            
            archiveIndex.lastUpdated = new Date().toISOString();
        }
        
        async function loadArchivedTasks() {
            if (archivedTasksLoaded) return;
            
            showToast('info', 'Loading archived tasks...');
            
            try {
                // Load archive index from GitHub
                const token = STATE.token || localStorage.getItem('gh_token');
                const response = await fetch(
                    `https://api.github.com/repos/${CONFIG.owner}/${CONFIG.repo}/contents/archive/archive-index.json`,
                    { headers: { 'Authorization': `token ${token}` } }
                );
                
                if (response.ok) {
                    const data = await response.json();
                    archiveIndex = JSON.parse(atob(data.content));
                    archivedTasksLoaded = true;
                    showToast('success', `Loaded archive index`);
                }
            } catch (e) {
                console.log('No archive index found or error:', e);
            }
        }
        
        function exportArchivedTasksCSV() {
            const archivedTasks = STATE.data.tasks.filter(t => t.archived);
            
            if (archivedTasks.length === 0) {
                showToast('info', 'No archived tasks to export');
                return;
            }
            
            // CSV Header
            const headers = ['ID', 'Title', 'Description', 'Status', 'Priority', 'Project', 'Tags', 'Created', 'Completed', 'Archived'];
            
            // CSV Rows
            const rows = archivedTasks.map(task => [
                task.id,
                `"${(task.title || '').replace(/"/g, '""')}"`,
                `"${(task.description || '').replace(/"/g, '""').replace(/\n/g, ' ')}"`,
                task.status,
                task.priority,
                task.project || '',
                (task.tags || []).join(';'),
                task.createdAt || '',
                task.completedAt || '',
                task.archivedAt || ''
            ]);
            
            const csv = [headers.join(','), ...rows.map(r => r.join(','))].join('\n');
            
            // Download
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `archived-tasks-${new Date().toISOString().slice(0, 10)}.csv`;
            link.click();
            
            showToast('success', `Exported ${archivedTasks.length} archived tasks to CSV`);
        }
        
        function showArchiveView() {
            // Load archived tasks if not already loaded
            loadArchivedTasks();
            
            const archivedTasks = STATE.data.tasks.filter(t => t.archived);
            
            const dialog = document.createElement('div');
            dialog.className = 'modal-overlay visible';
            dialog.id = 'archive-view-dialog';
            dialog.innerHTML = `
                <div class="modal" style="max-width: 700px; max-height: 80vh;">
                    <div class="modal-header">
                        <h2 class="modal-title">üì¶ Archive (${archivedTasks.length} tasks)</h2>
                        <button class="modal-close" onclick="closeArchiveView()">&times;</button>
                    </div>
                    <div class="modal-body" style="overflow-y: auto; max-height: 50vh;">
                        ${archivedTasks.length === 0 ? '<div class="empty-state">No archived tasks</div>' : 
                          archivedTasks.map(task => `
                            <div style="padding: 0.75rem; background: var(--bg-secondary); border-radius: 6px; margin-bottom: 0.5rem; display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <strong>${task.title}</strong>
                                    <div style="font-size: 0.8rem; color: var(--text-secondary);">
                                        Archived: ${new Date(task.archivedAt).toLocaleDateString()}
                                    </div>
                                </div>
                                <button class="btn btn-secondary btn-small" onclick="unarchiveTask('${task.id}'); closeArchiveView();">
                                    üì§ Restore
                                </button>
                            </div>
                          `).join('')
                        }
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-secondary" onclick="exportArchivedTasksCSV()">üì• Export CSV</button>
                        <button class="btn btn-primary" onclick="closeArchiveView()">Close</button>
                    </div>
                </div>
            `;
            document.body.appendChild(dialog);
        }
        
        function closeArchiveView() {
            const dialog = document.getElementById('archive-view-dialog');
            if (dialog) dialog.remove();
        }

        function toggleArchiveSearch(enabled) {
            showArchivedInSearch = enabled;
            renderTasks();
            if (searchQuery) {
                applySearchFilter();
            }
        }

        function handleSearch(query) {
            searchQuery = query.toLowerCase().trim();
            
            // Re-render tasks if archive search is enabled (to show/hide archived tasks)
            if (showArchivedInSearch) {
                renderTasks();
            }
            
            applySearchFilter();
            
            const searchInput = document.getElementById('search-input');
            const clearBtn = document.querySelector('.search-clear');
            
            // Keep expanded when has content
            if (searchInput) {
                searchInput.classList.toggle('expanded', query.length > 0);
            }
            
            // Toggle clear button visibility
            if (clearBtn) {
                clearBtn.style.display = query.length > 0 ? 'block' : 'none';
            }
        }

        function applySearchFilter() {
            const cards = document.querySelectorAll('.task-card');
            const data = STATE.data || FALLBACK_DATA;
            
            cards.forEach(card => {
                const taskId = card.getAttribute('data-task-id');
                const task = data.tasks.find(t => t.id === taskId);
                
                if (!task || !searchQuery) {
                    card.classList.remove('search-dimmed');
                    return;
                }
                
                // Search in title, description, tags, and comments
                const titleMatch = task.title.toLowerCase().includes(searchQuery);
                const descMatch = task.description.toLowerCase().includes(searchQuery);
                const tagMatch = task.tags.some(tag => tag.toLowerCase().includes(searchQuery));
                const commentMatch = task.comments && task.comments.some(c => 
                    c.text.toLowerCase().includes(searchQuery) || 
                    c.author.toLowerCase().includes(searchQuery)
                );
                
                if (titleMatch || descMatch || tagMatch || commentMatch) {
                    card.classList.remove('search-dimmed');
                } else {
                    card.classList.add('search-dimmed');
                }
            });
            
            // Update search result count
            const matchCount = document.querySelectorAll('.task-card:not(.search-dimmed)').length;
            const totalCount = cards.length;
            const searchInfo = document.getElementById('search-info');
            if (searchInfo) {
                if (searchQuery) {
                    searchInfo.textContent = `${matchCount}/${totalCount}`;
                    searchInfo.style.display = 'inline';
                } else {
                    searchInfo.style.display = 'none';
                }
            }
        }

        function clearSearch() {
            const searchInput = document.getElementById('search-input');
            if (searchInput) {
                searchInput.value = '';
                searchInput.classList.remove('expanded');
                searchInput.blur();
            }
            searchQuery = '';
            
            // Re-render to hide archived tasks when search is cleared
            if (showArchivedInSearch) {
                renderTasks();
            }
            
            applySearchFilter();
        }

        function filterByProject(projectId) {
            currentFilter = projectId;

            // Update active state
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.filter === projectId);
            });

            renderTasks();
        }

        function updateStats() {
            const data = STATE.data || FALLBACK_DATA;
            // Exclude archived tasks from stats
            const activeTasks = data.tasks.filter(t => !t.archived);
            const total = activeTasks.filter(t => t.status !== 'permanent').length;
            const inProgress = activeTasks.filter(t => t.status === 'in_progress').length;
            const review = activeTasks.filter(t => t.status === 'review').length;
            const completion = total > 0 ? Math.round((review / total) * 100) : 0;

            document.getElementById('stat-total').textContent = total;
            document.getElementById('stat-progress').textContent = inProgress;
            document.getElementById('stat-week').textContent = review;
            document.getElementById('stat-completion').textContent = completion + '%';
        }

        // === TASK EDITING ===
        let currentEditingTaskId = null;
        let currentTaskTags = [];

        // === TAG FUNCTIONS ===
        function renderTagChips() {
            const container = document.getElementById('tags-chips');
            if (!container) return;

            if (currentTaskTags.length === 0) {
                container.innerHTML = '<span style="color: var(--text-secondary); font-size: 0.875rem;">No tags</span>';
                return;
            }

            container.innerHTML = currentTaskTags.map(tag => `
                <span class="tag-chip">
                    ${tag}
                    <span class="tag-remove" onclick="removeTag('${tag}')" title="Remove">‚úï</span>
                </span>
            `).join('');
        }

        function addTag() {
            const input = document.getElementById('new-tag-input');
            const tag = input.value.trim().toLowerCase();
            if (!tag) return;

            if (!currentTaskTags.includes(tag)) {
                currentTaskTags.push(tag);
                renderTagChips();
            }
            input.value = '';
        }

        function removeTag(tag) {
            currentTaskTags = currentTaskTags.filter(t => t !== tag);
            renderTagChips();
        }

        function openTaskDetail(taskId) {
            if (!STATE.user) {
                showToast('error', 'Login to edit tasks');
                return;
            }

            const data = STATE.data || FALLBACK_DATA;
            const task = data.tasks.find(t => t.id === taskId);

            if (!task) {
                showToast('error', 'Task not found');
                return;
            }

            currentEditingTaskId = taskId;
            isEditingTemplate = task.isTemplate === true;

            // Populate modal
            document.getElementById('task-modal-title').textContent = task.isTemplate ? 'üìë Edit Template' : 'Edit Task';
            document.getElementById('task-title').value = task.title;
            document.getElementById('task-description').value = task.description;
            document.getElementById('task-status').value = task.isTemplate ? (task.baseStatus || 'backlog') : task.status;
            document.getElementById('task-priority').value = task.priority;
            document.getElementById('task-project').value = task.project;
            document.getElementById('btn-delete-task').style.display = 'block';
            
            // Show/hide "As Cron" button based on task type
            const asCronBtn = document.getElementById('btn-task-to-cron');
            if (asCronBtn) {
                asCronBtn.style.display = task.isTemplate ? 'none' : 'inline-flex';
            }

            // Render tags as chips
            currentTaskTags = [...(task.tags || [])];
            renderTagChips();

            // Render subtasks
            renderSubtasks(task);

            // Render comments
            renderComments(task);

            document.getElementById('task-modal').classList.add('visible');
        }

        function renderSubtasks(task) {
            const container = document.getElementById('subtasks-list');
            if (!task.subtasks || task.subtasks.length === 0) {
                container.innerHTML = '<div style="color: var(--text-secondary); font-size: 0.875rem;">No subtasks yet</div>';
                return;
            }
            container.innerHTML = task.subtasks.map(sub => `
                <div class="subtask-item">
                    <input type="checkbox" ${sub.done ? 'checked' : ''} onchange="toggleSubtask('${task.id}', '${sub.id}')">
                    <span class="subtask-title ${sub.done ? 'done' : ''}"
                          onclick="startEditSubtask('${task.id}', '${sub.id}')"
                          title="Click to edit"
                          style="cursor: pointer;">${sub.title}</span>
                    <button class="subtask-delete" onclick="deleteSubtask('${task.id}', '${sub.id}')" title="Delete">‚úï</button>
                </div>
            `).join('');
        }

        function startEditSubtask(taskId, subtaskId) {
            const task = STATE.data.tasks.find(t => t.id === taskId);
            if (!task) return;
            const subtask = task.subtasks.find(s => s.id === subtaskId);
            if (!subtask) return;

            // Replace span with input
            const container = document.getElementById('subtasks-list');
            const items = container.querySelectorAll('.subtask-item');
            items.forEach(item => {
                const span = item.querySelector('.subtask-title');
                if (span && span.textContent === subtask.title) {
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.value = subtask.title;
                    input.className = 'subtask-edit-input';
                    input.style.cssText = 'flex: 1; padding: 4px 8px; border: 1px solid var(--accent); border-radius: 4px; background: var(--bg-secondary); color: var(--text-primary);';

                    input.onblur = () => saveSubtaskEdit(taskId, subtaskId, input.value);
                    input.onkeydown = (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            saveSubtaskEdit(taskId, subtaskId, input.value);
                        }
                        if (e.key === 'Escape') {
                            renderSubtasks(task);
                        }
                    };

                    span.replaceWith(input);
                    input.focus();
                    input.select();
                }
            });
        }

        function saveSubtaskEdit(taskId, subtaskId, newTitle) {
            newTitle = newTitle.trim();
            if (!newTitle) return;

            const task = STATE.data.tasks.find(t => t.id === taskId);
            if (!task) return;
            const subtask = task.subtasks.find(s => s.id === subtaskId);
            if (!subtask) return;

            if (subtask.title !== newTitle) {
                const oldTitle = subtask.title;
                subtask.title = newTitle;
                renderSubtasks(task);
                // AUTO-SAVE
                autoSave(`Rename subtask "${oldTitle}" ‚Üí "${newTitle}"`);
            } else {
                renderSubtasks(task);
            }
        }

        function renderComments(task) {
            const container = document.getElementById('comments-list');
            const comments = task.comments || [];
            if (comments.length === 0) {
                container.innerHTML = '<div style="color: var(--text-secondary); font-size: 0.875rem;">No comments yet</div>';
                return;
            }
            container.innerHTML = comments.map((c, idx) => {
                // Voice note comment
                if (c.type === 'voice_note') {
                    return `
                        <div class="voice-note-comment" data-comment-idx="${idx}">
                            <div class="voice-note-comment-header">
                                <span class="voice-note-comment-label">üé§ Voice Note</span>
                                <span class="voice-note-comment-time">${formatTimeAgo(c.createdAt)} ‚Ä¢ ${formatDuration(c.duration || 0)}</span>
                            </div>
                            <div class="voice-note-player" data-audio="${c.audio}" data-idx="${idx}">
                                <button class="voice-note-player-btn" onclick="playVoiceNoteComment(${idx}, '${task.id}')" id="vn-play-${idx}">‚ñ∂</button>
                                <div class="voice-note-player-progress" onclick="seekVoiceNoteComment(event, ${idx})">
                                    <div class="voice-note-player-progress-fill" id="vn-progress-${idx}"></div>
                                </div>
                                <span class="voice-note-player-duration" id="vn-duration-${idx}">${formatDuration(c.duration || 0)}</span>
                            </div>
                            ${c.transcript ? `<div class="voice-note-transcript">"${c.transcript}"</div>` : ''}
                            <div style="text-align: right; margin-top: 0.5rem;">
                                <button class="comment-action-btn" onclick="deleteComment('${task.id}', ${idx})" title="Delete">üóëÔ∏è</button>
                            </div>
                        </div>
                    `;
                }
                
                // Regular text comment
                return `
                    <div class="comment-item" data-comment-idx="${idx}">
                        <div class="comment-header">
                            <span class="comment-author">${c.author}</span>
                            <span class="comment-time">${formatTimeAgo(c.createdAt)}</span>
                            <span class="comment-actions">
                                <button class="comment-action-btn" onclick="editComment('${task.id}', ${idx})" title="Edit">‚úèÔ∏è</button>
                                <button class="comment-action-btn" onclick="deleteComment('${task.id}', ${idx})" title="Delete">üóëÔ∏è</button>
                            </span>
                        </div>
                        <div class="comment-text" id="comment-text-${idx}">${renderMarkdown(c.text)}</div>
                    </div>
                `;
            }).join('');
        }
        
        // Format duration in mm:ss
        function formatDuration(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function editComment(taskId, commentIdx) {
            const task = STATE.data.tasks.find(t => t.id === taskId);
            if (!task || !task.comments || !task.comments[commentIdx]) return;

            const comment = task.comments[commentIdx];
            const textEl = document.getElementById(`comment-text-${commentIdx}`);
            if (!textEl) return;

            const textarea = document.createElement('textarea');
            textarea.value = comment.text;
            textarea.className = 'comment-edit-textarea';
            textarea.style.cssText = 'width: 100%; min-height: 60px; padding: 8px; border: 1px solid var(--accent); border-radius: 4px; background: var(--bg-secondary); color: var(--text-primary); resize: vertical;';

            const saveBtn = document.createElement('button');
            saveBtn.textContent = 'Save';
            saveBtn.className = 'btn btn-primary btn-small';
            saveBtn.style.marginTop = '8px';
            saveBtn.onclick = () => saveCommentEdit(taskId, commentIdx, textarea.value);

            const cancelBtn = document.createElement('button');
            cancelBtn.textContent = 'Cancel';
            cancelBtn.className = 'btn btn-secondary btn-small';
            cancelBtn.style.cssText = 'margin-top: 8px; margin-left: 8px;';
            cancelBtn.onclick = () => renderComments(task);

            textEl.innerHTML = '';
            textEl.appendChild(textarea);
            textEl.appendChild(saveBtn);
            textEl.appendChild(cancelBtn);
            textarea.focus();
        }

        function saveCommentEdit(taskId, commentIdx, newText) {
            newText = newText.trim();
            if (!newText) return;

            const task = STATE.data.tasks.find(t => t.id === taskId);
            if (!task || !task.comments || !task.comments[commentIdx]) return;

            const oldText = task.comments[commentIdx].text;
            if (oldText !== newText) {
                task.comments[commentIdx].text = newText;
                task.comments[commentIdx].editedAt = new Date().toISOString();
                renderComments(task);
                autoSave(`Edit comment on "${task.title}"`);
            } else {
                renderComments(task);
            }
        }

        function deleteComment(taskId, commentIdx) {
            if (!confirm('Delete this comment?')) return;

            const task = STATE.data.tasks.find(t => t.id === taskId);
            if (!task || !task.comments) return;

            task.comments.splice(commentIdx, 1);
            renderComments(task);
            autoSave(`Delete comment from "${task.title}"`);
        }

        function formatTimeAgo(dateString) {
            const date = new Date(dateString);
            const now = new Date();
            const diffMs = now - date;
            const diffMin = Math.floor(diffMs / 60000);
            const diffHour = Math.floor(diffMs / 3600000);
            const diffDay = Math.floor(diffMs / 86400000);

            if (diffMin < 1) return 'just now';
            if (diffMin < 60) return diffMin + ' min ago';
            if (diffHour < 24) return diffHour + ' hours ago';
            return diffDay + ' days ago';
        }

        function toggleSubtask(taskId, subtaskId) {
            const task = STATE.data.tasks.find(t => t.id === taskId);
            if (task) {
                const subtask = task.subtasks.find(s => s.id === subtaskId);
                if (subtask) {
                    subtask.done = !subtask.done;
                    renderSubtasks(task);
                    renderTasks();
                    // AUTO-SAVE mit Debounce
                    debouncedAutoSave(`${subtask.done ? '‚úì' : '‚óã'} "${subtask.title}" in "${task.title}"`);
                }
            }
        }

        function deleteSubtask(taskId, subtaskId) {
            const task = STATE.data.tasks.find(t => t.id === taskId);
            if (task) {
                const subtask = task.subtasks.find(s => s.id === subtaskId);
                const subtaskTitle = subtask?.title || 'Subtask';
                task.subtasks = task.subtasks.filter(s => s.id !== subtaskId);
                renderSubtasks(task);
                renderTasks();
                // AUTO-SAVE
                autoSave(`Remove subtask "${subtaskTitle}" from "${task.title}"`);
            }
        }

        function addSubtask() {
            if (!currentEditingTaskId) return;
            const input = document.getElementById('new-subtask-input');
            const title = input.value.trim();
            if (!title) return;

            const task = STATE.data.tasks.find(t => t.id === currentEditingTaskId);
            if (task) {
                const newId = 'sub_' + Date.now();
                task.subtasks.push({ id: newId, title: title, done: false });
                renderSubtasks(task);
                renderTasks();
                input.value = '';
                // AUTO-SAVE
                autoSave(`Add subtask "${title}" to "${task.title}"`);
            }
        }

        // === DEBOUNCED AUTO-SAVE (for rapid changes) ===
        let autoSaveTimeout = null;
        function debouncedAutoSave(action) {
            if (autoSaveTimeout) clearTimeout(autoSaveTimeout);
            autoSaveTimeout = setTimeout(() => {
                autoSave(action);
            }, 1000); // 1 Sekunde warten
        }

        function addComment() {
            if (!currentEditingTaskId) return;
            const input = document.getElementById('new-comment-input');
            const text = input.value.trim();
            if (!text) return;

            const task = STATE.data.tasks.find(t => t.id === currentEditingTaskId);
            if (task) {
                if (!task.comments) task.comments = [];
                task.comments.push({
                    id: 'c_' + Date.now(),
                    author: STATE.user?.login || 'User',
                    text: text,
                    createdAt: new Date().toISOString()
                });
                renderComments(task);
                input.value = '';

                // AUTO-SAVE mit speziellem Hinweis bei Review-Tasks
                let commitMsg = `Comment on "${task.title}": ${text.substring(0, 50)}${text.length > 50 ? '...' : ''}`;
                if (task.status === 'review') {
                    commitMsg = `üí¨ FEEDBACK on "${task.title}": ${text.substring(0, 50)}${text.length > 50 ? '...' : ''}`;
                }
                autoSave(commitMsg);
            }
        }

        function openNewTask(status = 'backlog') {
            if (!STATE.user) {
                showToast('error', 'Login to add tasks');
                return;
            }

            currentEditingTaskId = null;

            // Reset modal
            document.getElementById('task-modal-title').textContent = 'New Task';
            document.getElementById('task-title').value = '';
            document.getElementById('task-description').value = '';
            document.getElementById('task-status').value = status;
            document.getElementById('task-priority').value = 'medium';
            document.getElementById('task-project').value = 'system';
            document.getElementById('btn-delete-task').style.display = 'none';

            // Reset tags
            currentTaskTags = [];
            renderTagChips();

            // Clear subtasks and comments for new task
            document.getElementById('subtasks-list').innerHTML = '<div style="color: var(--text-secondary); font-size: 0.875rem;">No subtasks yet</div>';
            document.getElementById('comments-list').innerHTML = '<div style="color: var(--text-secondary); font-size: 0.875rem;">No comments yet</div>';

            document.getElementById('task-modal').classList.add('visible');
        }

        function hideTaskModal() {
            document.getElementById('task-modal').classList.remove('visible');
            currentEditingTaskId = null;
            isEditingTemplate = false;
        }

        function saveTask() {
            const title = document.getElementById('task-title').value.trim();
            const description = document.getElementById('task-description').value.trim();
            const status = document.getElementById('task-status').value;
            const priority = document.getElementById('task-priority').value;
            const project = document.getElementById('task-project').value;
            const tags = currentTaskTags.length > 0 ? [...currentTaskTags] : [project];

            if (!title) {
                showToast('error', 'Title is required');
                return;
            }

            if (currentEditingTaskId) {
                // Update existing task or template
                const task = STATE.data.tasks.find(t => t.id === currentEditingTaskId);
                if (task) {
                    task.title = title;
                    task.description = description;
                    task.priority = priority;
                    task.project = project;
                    task.tags = tags.length > 0 ? tags : [project];
                    
                    if (isEditingTemplate) {
                        task.baseStatus = status; // Store the status to use when executing
                    } else {
                        task.status = status;
                    }
                }
            } else {
                // Create new task or template
                const newItem = {
                    id: (isEditingTemplate ? 'template_' : 'task_') + Date.now(),
                    title: title,
                    description: description,
                    project: project,
                    tags: tags.length > 0 ? tags : [project],
                    subtasks: [],
                    priority: priority,
                    createdAt: new Date().toISOString()
                };
                
                if (isEditingTemplate) {
                    newItem.isTemplate = true;
                    newItem.baseStatus = status;
                    newItem.executionCount = 0;
                } else {
                    newItem.status = status;
                }
                
                STATE.data.tasks.push(newItem);
            }

            STATE.data.lastUpdated = new Date().toISOString();
            hideTaskModal();
            
            if (isEditingTemplate) {
                renderTemplates();
            } else {
                renderTasks(true); // Animate reorder
            }
            
            isEditingTemplate = false;

            // AUTO-SAVE
            const itemType = isEditingTemplate ? 'template' : 'task';
            const action = currentEditingTaskId ? `Update ${itemType} "${title}"` : `Create ${itemType} "${title}"`;
            autoSave(action);
        }

        function deleteTask() {
            if (!currentEditingTaskId) return;

            if (!confirm('Are you sure you want to delete this task?')) return;

            const task = STATE.data.tasks.find(t => t.id === currentEditingTaskId);
            const taskTitle = task?.title || 'Task';

            STATE.data.tasks = STATE.data.tasks.filter(t => t.id !== currentEditingTaskId);
            STATE.data.lastUpdated = new Date().toISOString();
            hideTaskModal();
            renderTasks();

            // AUTO-SAVE
            autoSave(`Delete "${taskTitle}"`);
        }

        function markAsChanged() {
            STATE.hasUnsavedChanges = true;
            document.getElementById('unsaved-banner').classList.add('visible');
        }

        function discardChanges() {
            if (STATE.originalData) {
                STATE.data = JSON.parse(JSON.stringify(STATE.originalData));
            }
            STATE.hasUnsavedChanges = false;
            document.getElementById('unsaved-banner').classList.remove('visible');
            renderTasks();
            showToast('success', 'Changes discarded');
        }

        // === COMMIT MODAL ===
        function showCommitModal() {
            if (!STATE.hasUnsavedChanges) {
                showToast('error', 'No changes to save');
                return;
            }

            document.getElementById('commit-message').value = '';
            document.getElementById('changes-summary').innerHTML = generateChangesSummary();
            document.getElementById('commit-modal').classList.add('visible');
        }

        function hideCommitModal() {
            document.getElementById('commit-modal').classList.remove('visible');
        }

        // === SETTINGS MODAL ===
        function showSettingsModal() {
            renderProjectsList();
            const select = document.getElementById('storage-mode');
            if (select) select.value = getStorageMode();
            document.getElementById('settings-modal').classList.add('visible');
        }

        function hideSettingsModal() {
            document.getElementById('settings-modal').classList.remove('visible');
        }

        function renderProjectsList() {
            const container = document.getElementById('projects-list');
            const projects = STATE.data?.projects || [];

            if (projects.length === 0) {
                container.innerHTML = '<div style="color: var(--text-secondary);">No projects yet</div>';
                return;
            }

            container.innerHTML = projects.map(p => `
                <div class="project-item">
                    <span class="project-icon">${p.icon}</span>
                    <span class="project-color" style="background: ${p.color}"></span>
                    <span class="project-name">${p.name}</span>
                    <span class="project-id">${p.id}</span>
                    <div class="project-actions">
                        <button onclick="editProject('${p.id}')" title="Edit">‚úèÔ∏è</button>
                        <button onclick="deleteProject('${p.id}')" title="Delete">üóëÔ∏è</button>
                    </div>
                </div>
            `).join('');

            // Update project dropdown in task modal
            updateProjectDropdown();
        }

        let editingProjectId = null;

        function saveProject() {
            const id = document.getElementById('new-project-id').value.trim().toLowerCase().replace(/\s+/g, '-');
            const name = document.getElementById('new-project-name').value.trim();
            const icon = document.getElementById('new-project-icon').value.trim() || 'üìÅ';
            const color = document.getElementById('new-project-color').value;

            if (!id || !name) {
                showToast('error', 'ID and Name are required');
                return;
            }

            if (editingProjectId) {
                // UPDATE existing project
                const project = STATE.data.projects.find(p => p.id === editingProjectId);
                if (project) {
                    // If ID changed, update all tasks using this project
                    if (editingProjectId !== id) {
                        STATE.data.tasks.forEach(t => {
                            if (t.project === editingProjectId) t.project = id;
                        });
                    }
                    project.id = id;
                    project.name = name;
                    project.icon = icon;
                    project.color = color;
                    autoSave(`Update project "${name}"`);
                }
            } else {
                // ADD new project
                if (STATE.data.projects.some(p => p.id === id)) {
                    showToast('error', 'Project ID already exists');
                    return;
                }
                STATE.data.projects.push({ id, name, icon, color });
                autoSave(`Add project "${name}"`);
            }

            // Reset form
            clearProjectForm();
            renderProjectsList();
            renderFilters();
        }

        function editProject(projectId) {
            const project = STATE.data.projects.find(p => p.id === projectId);
            if (!project) return;

            // Load data into form
            editingProjectId = projectId;
            document.getElementById('new-project-id').value = project.id;
            document.getElementById('new-project-name').value = project.name;
            document.getElementById('new-project-icon').value = project.icon;
            document.getElementById('new-project-color').value = project.color;

            // Update UI
            document.getElementById('project-form-title').textContent = `Edit Project: ${project.name}`;
            document.getElementById('btn-save-project').textContent = 'üíæ Save Changes';
            document.getElementById('btn-cancel-project').style.display = 'block';

            // Clear emoji selection
            document.querySelectorAll('.emoji-btn').forEach(btn => {
                btn.classList.toggle('selected', btn.textContent.trim() === project.icon);
            });

            // Scroll to form
            document.querySelector('.add-project-form').scrollIntoView({ behavior: 'smooth' });
        }

        function cancelEditProject() {
            clearProjectForm();
        }

        function clearProjectForm() {
            editingProjectId = null;
            document.getElementById('new-project-id').value = '';
            document.getElementById('new-project-name').value = '';
            document.getElementById('new-project-icon').value = '';
            document.getElementById('new-project-color').value = '#6366f1';
            document.getElementById('project-form-title').textContent = 'Add New Project';
            document.getElementById('btn-save-project').textContent = '+ Add Project';
            document.getElementById('btn-cancel-project').style.display = 'none';
            document.querySelectorAll('.emoji-btn').forEach(btn => btn.classList.remove('selected'));
        }

        function deleteProject(projectId) {
            const project = STATE.data.projects.find(p => p.id === projectId);
            if (!project) return;

            // Check if any tasks use this project
            const tasksUsingProject = STATE.data.tasks.filter(t => t.project === projectId);
            if (tasksUsingProject.length > 0) {
                if (!confirm(`${tasksUsingProject.length} task(s) use this project. Delete anyway? Tasks will be moved to "system".`)) {
                    return;
                }
                // Move tasks to system
                tasksUsingProject.forEach(t => t.project = 'system');
            }

            STATE.data.projects = STATE.data.projects.filter(p => p.id !== projectId);

            renderProjectsList();
            renderFilters();
            autoSave(`Delete project "${project.name}"`);
        }

        function updateProjectDropdown() {
            const select = document.getElementById('task-project');
            if (!select) return;

            const projects = STATE.data?.projects || [];
            select.innerHTML = projects.map(p =>
                `<option value="${p.id}">${p.icon} ${p.name}</option>`
            ).join('');
        }

        function selectEmoji(emoji) {
            document.getElementById('new-project-icon').value = emoji;
            // Visual feedback
            document.querySelectorAll('.emoji-btn').forEach(btn => btn.classList.remove('selected'));
            event.target.classList.add('selected');
        }

        // === VIEW SWITCHING ===
        function switchView(viewName) {
            // Hide all views
            document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
            document.querySelectorAll('.view').forEach(v => v.style.display = 'none');

            // Show selected view
            const view = document.getElementById('view-' + viewName);
            if (view) {
                view.classList.add('active');
                view.style.display = 'block';
            }

            // Update nav tabs
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.view === viewName);
            });

            // Render on demand
            if (viewName === 'todo') {
                ensureTodos();
                renderTodos();
                setTimeout(() => {
                    const input = document.getElementById('todo-input');
                    if (input) input.focus();
                }, 50);
            }
            
            // Notes view handling
            if (viewName === 'notes') {
                renderNotesList();
                // Initialize canvas if editor is active
                if (document.getElementById('notes-editor')?.classList.contains('active') && !notesCanvas) {
                    initNotesCanvas();
                }
            }
        }

        // === TODO LIST (simple, separate from Kanban tasks) ===
        let TODO_FILTER = 'all';

        function ensureTodos() {
            const data = STATE.data || FALLBACK_DATA;
            if (!data.todos) data.todos = [];
            if (STATE.data && !STATE.data.todos) STATE.data.todos = data.todos;
        }

        function setTodoFilter(filter) {
            TODO_FILTER = filter;
            ['all', 'open', 'done'].forEach(f => {
                const el = document.getElementById(`todo-filter-${f}`);
                if (el) el.classList.toggle('active', f === filter);
            });
            renderTodos();
        }

        function addTodoFromInput() {
            if (!STATE.user) {
                showToast('error', 'Login to add todos');
                return;
            }
            const input = document.getElementById('todo-input');
            const title = (input?.value || '').trim();
            if (!title) return;

            ensureTodos();
            const todo = { id: 'todo_' + Date.now(), title, done: false, createdAt: new Date().toISOString() };
            STATE.data.todos.unshift(todo);
            STATE.data.lastUpdated = new Date().toISOString();
            if (input) input.value = '';
            renderTodos();
            autoSave(`Add todo "${title}"`);
        }

        function toggleTodo(todoId) {
            ensureTodos();
            const todo = STATE.data.todos.find(t => t.id === todoId);
            if (!todo) return;
            todo.done = !todo.done;
            STATE.data.lastUpdated = new Date().toISOString();
            renderTodos();
            autoSave(`Todo ${todo.done ? 'done' : 'reopened'}: "${todo.title}"`);
        }

        function deleteTodo(todoId) {
            ensureTodos();
            const todo = STATE.data.todos.find(t => t.id === todoId);
            const title = todo?.title || 'todo';
            STATE.data.todos = STATE.data.todos.filter(t => t.id !== todoId);
            STATE.data.lastUpdated = new Date().toISOString();
            renderTodos();
            autoSave(`Delete todo "${title}"`);
        }

        function clearDoneTodos() {
            ensureTodos();
            const before = STATE.data.todos.length;
            STATE.data.todos = STATE.data.todos.filter(t => !t.done);
            const removed = before - STATE.data.todos.length;
            if (removed > 0) {
                STATE.data.lastUpdated = new Date().toISOString();
                renderTodos();
                autoSave(`Clear ${removed} done todo(s)`);
            }
        }

        function renderTodos() {
            const container = document.getElementById('todo-list');
            if (!container) return;

            const data = STATE.data || FALLBACK_DATA;
            const todos = (data.todos || []).slice();

            const filtered = todos.filter(t => {
                if (TODO_FILTER === 'open') return !t.done;
                if (TODO_FILTER === 'done') return t.done;
                return true;
            });

            if (filtered.length === 0) {
                container.innerHTML = `<div style="color: var(--text-secondary); padding: 1rem;">No todos here.</div>`;
                return;
            }

            container.innerHTML = filtered.map(t => {
                const checked = t.done ? 'checked' : '';
                const titleStyle = t.done ? 'text-decoration: line-through; opacity: .7;' : '';
                return `
                    <div style="display:flex; align-items:center; justify-content:space-between; gap:.75rem; padding:.75rem 1rem; background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 12px;">
                        <label style="display:flex; align-items:center; gap:.75rem; cursor:pointer; flex: 1;">
                            <input type="checkbox" ${checked} onchange="toggleTodo('${t.id}')" />
                            <span style="${titleStyle}">${escapeHtml(t.title)}</span>
                        </label>
                        <button class="btn btn-secondary btn-small" onclick="deleteTodo('${t.id}')">Delete</button>
                    </div>
                `;
            }).join('');
        }

        function generateChangesSummary() {
            const current = STATE.data.tasks.length;
            const original = STATE.originalData ? STATE.originalData.tasks.length : current;
            const diff = current - original;

            let html = '<strong>Changes to commit:</strong><br>';
            if (diff > 0) {
                html += `‚Ä¢ Added ${diff} new task(s)<br>`;
            } else if (diff < 0) {
                html += `‚Ä¢ Deleted ${Math.abs(diff)} task(s)<br>`;
            }
            html += `‚Ä¢ Total tasks: ${current}`;

            return html;
        }

        async function commitChanges() {
            const message = document.getElementById('commit-message').value.trim() || 'Update tasks via Mission Control';

            document.getElementById('commit-btn-text').textContent = 'Saving...';
            document.getElementById('commit-spinner').style.display = 'inline-block';
            document.getElementById('btn-commit').disabled = true;

            const success = await saveTasksToGitHub(message);

            document.getElementById('commit-btn-text').textContent = 'Commit & Push';
            document.getElementById('commit-spinner').style.display = 'none';
            document.getElementById('btn-commit').disabled = false;

            if (success) {
                hideCommitModal();
            }
        }

        // === ACTIVITY TOGGLE ===
        function toggleActivity() {
            const sidebar = document.getElementById('activity-sidebar');
            const icon = document.getElementById('activity-toggle-icon');
            const reopen = document.getElementById('activity-reopen');
            const isCollapsed = sidebar.classList.toggle('collapsed');
            icon.textContent = isCollapsed ? '‚ò∞' : '‚úï';
            reopen.style.display = isCollapsed ? 'flex' : 'none';
            localStorage.setItem('activity-collapsed', isCollapsed);
        }

        // === AUTO-POLLING ===
        let lastDataHash = null;
        let lastPollTime = Date.now();
        const POLL_INTERVAL = 30000; // 30 seconds

        function hashData(data) {
            return JSON.stringify(data);
        }

        async function pollForUpdates() {
            if (!STATE.token || STATE.hasUnsavedChanges || document.hidden) return;

            try {
                const response = await fetch(
                    `https://api.github.com/repos/${CONFIG.owner}/${CONFIG.repo}/contents/${CONFIG.tasksFile}`,
                    {
                        headers: {
                            'Authorization': `token ${STATE.token}`,
                            'Accept': 'application/vnd.github.v3+json',
                            'If-None-Match': ''  // Bypass cache
                        }
                    }
                );

                if (!response.ok) return;

                const fileData = await response.json();
                const bytes = Uint8Array.from(atob(fileData.content), c => c.charCodeAt(0));
                const content = new TextDecoder().decode(bytes);
                const newData = JSON.parse(content);

                const newHash = hashData(newData);
                if (lastDataHash && newHash !== lastDataHash) {
                    STATE.data = newData;
                    STATE.originalData = JSON.parse(JSON.stringify(newData));
                    STATE.fileSha = fileData.sha;
                    renderAll();
                    showToast('success', 'üîÑ Dashboard updated');
                }
                lastDataHash = newHash;
                lastPollTime = Date.now();
                updateLiveIndicator();

            } catch (error) {
                console.log('Poll error:', error);
            }
        }

        function updateLiveIndicator() {
            const indicator = document.getElementById('live-indicator');
            if (indicator) {
                const seconds = Math.round((Date.now() - lastPollTime) / 1000);
                indicator.textContent = seconds < 5 ? 'Live' : `${seconds}s ago`;
                indicator.className = 'live-indicator ' + (seconds < 35 ? 'live' : 'stale');
            }
        }

        // Start polling
        setInterval(pollForUpdates, POLL_INTERVAL);
        setInterval(updateLiveIndicator, 1000);

        // === TEMPLATES FUNCTIONS ===
        function renderTemplates() {
            const container = document.getElementById('tasks-templates');
            const countEl = document.getElementById('count-templates');
            const data = STATE.data || FALLBACK_DATA;
            const templates = data.tasks.filter(t => t.isTemplate === true);
            
            countEl.textContent = templates.length;
            
            if (templates.length === 0) {
                container.innerHTML = '<div class="empty-state">No templates yet</div>';
                return;
            }
            
            container.innerHTML = templates.map(template => {
                const execCount = template.executionCount || 0;
                return `
                    <div class="template-card" data-template-id="${template.id}" onclick="openTemplateDetail('${template.id}')">
                        <div class="template-name">${template.title}</div>
                        <div class="template-description">${template.description || ''}</div>
                        <div class="template-meta">
                            <span class="execution-count" title="Times executed">
                                ‚ñ∂ ${execCount}x
                            </span>
                            ${template.tags ? template.tags.map(t => `<span class="task-tag ${t}">${t}</span>`).join('') : ''}
                        </div>
                        <div class="template-actions" onclick="event.stopPropagation()">
                            <button class="template-action-btn run" onclick="executeTemplate('${template.id}')" title="Run template">‚ñ∂ Run</button>
                            <button class="template-action-btn" onclick="duplicateTemplate('${template.id}')" title="Duplicate">üìã Copy</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function openNewTemplate() {
            if (!STATE.user) {
                showToast('error', 'Login to create templates');
                return;
            }
            
            currentEditingTaskId = null;
            isEditingTemplate = true;
            
            document.getElementById('task-modal-title').textContent = 'üìë New Template';
            document.getElementById('task-title').value = '';
            document.getElementById('task-description').value = '';
            document.getElementById('task-status').value = 'backlog';
            document.getElementById('task-priority').value = 'medium';
            document.getElementById('task-project').value = 'system';
            document.getElementById('btn-delete-task').style.display = 'none';
            
            currentTaskTags = [];
            renderTagChips();
            
            document.getElementById('subtasks-list').innerHTML = '<div style="color: var(--text-secondary); font-size: 0.875rem;">No subtasks yet</div>';
            document.getElementById('comments-list').innerHTML = '<div style="color: var(--text-secondary); font-size: 0.875rem;">No comments yet</div>';
            
            document.getElementById('task-modal').classList.add('visible');
        }

        let isEditingTemplate = false;

        function openTemplateDetail(templateId) {
            if (!STATE.user) {
                showToast('error', 'Login to edit templates');
                return;
            }
            
            const data = STATE.data || FALLBACK_DATA;
            const template = data.tasks.find(t => t.id === templateId);
            
            if (!template) {
                showToast('error', 'Template not found');
                return;
            }
            
            currentEditingTaskId = templateId;
            isEditingTemplate = true;
            
            document.getElementById('task-modal-title').textContent = 'üìë Edit Template';
            document.getElementById('task-title').value = template.title;
            document.getElementById('task-description').value = template.description;
            document.getElementById('task-status').value = template.baseStatus || 'backlog';
            document.getElementById('task-priority').value = template.priority;
            document.getElementById('task-project').value = template.project;
            document.getElementById('btn-delete-task').style.display = 'block';
            
            currentTaskTags = [...(template.tags || [])];
            renderTagChips();
            
            renderSubtasks(template);
            renderComments(template);
            
            document.getElementById('task-modal').classList.add('visible');
        }

        function executeTemplate(templateId) {
            const data = STATE.data || FALLBACK_DATA;
            const template = data.tasks.find(t => t.id === templateId);
            
            if (!template) {
                showToast('error', 'Template not found');
                return;
            }
            
            // Create task from template
            const newTask = structuredClone(template);
            newTask.id = 'task_' + Date.now();
            newTask.isTemplate = false;
            newTask.status = template.baseStatus || 'backlog';
            newTask.createdAt = new Date().toISOString();
            newTask.createdFromTemplate = templateId;
            delete newTask.executionCount;
            delete newTask.baseStatus;
            
            // Clear subtask completion status
            if (newTask.subtasks) {
                newTask.subtasks = newTask.subtasks.map(s => ({
                    ...s,
                    id: 'sub_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                    done: false
                }));
            }
            
            STATE.data.tasks.push(newTask);
            
            // Increment execution counter
            template.executionCount = (template.executionCount || 0) + 1;
            
            renderTemplates();
            renderTasks();
            autoSave(`Execute template "${template.title}"`);
            showToast('success', `Created task from template: ${newTask.title}`);
        }

        // Task 8: Template-Duplikat
        function duplicateTemplate(templateId) {
            const data = STATE.data || FALLBACK_DATA;
            const template = data.tasks.find(t => t.id === templateId);
            
            if (!template) {
                showToast('error', 'Template not found');
                return;
            }
            
            // Deep copy
            const newTemplate = structuredClone(template);
            newTemplate.id = 'template_' + Date.now();
            newTemplate.createdAt = new Date().toISOString();
            newTemplate.executionCount = 0;
            
            // Generate suffix
            const baseName = template.title.replace(/ \(Kopie( \d+)?\)$/, '');
            const existingCopies = data.tasks.filter(t => 
                t.isTemplate && 
                (t.title === baseName + ' (Kopie)' || t.title.match(new RegExp(`^${baseName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')} \\(Kopie \\d+\\)$`)))
            );
            
            if (existingCopies.length === 0) {
                newTemplate.title = baseName + ' (Kopie)';
            } else {
                newTemplate.title = baseName + ' (Kopie ' + (existingCopies.length + 1) + ')';
            }
            
            // Reset subtask IDs
            if (newTemplate.subtasks) {
                newTemplate.subtasks = newTemplate.subtasks.map(s => ({
                    ...s,
                    id: 'sub_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9)
                }));
            }
            
            STATE.data.tasks.push(newTemplate);
            renderTemplates();
            autoSave(`Duplicate template "${template.title}"`);
            
            // Open edit modal with focus on title
            setTimeout(() => {
                openTemplateDetail(newTemplate.id);
                setTimeout(() => {
                    const titleInput = document.getElementById('task-title');
                    if (titleInput) {
                        titleInput.focus();
                        titleInput.select();
                    }
                }, 100);
            }, 200);
        }

        // Template Done Confirmation Dialog
        function showTemplateExecutionDialog(taskId) {
            const task = STATE.data.tasks.find(t => t.id === taskId);
            if (!task || !task.createdFromTemplate) {
                quickMoveTask(taskId, 'done');
                return;
            }
            
            const dialog = document.createElement('div');
            dialog.className = 'modal-overlay visible';
            dialog.id = 'template-execution-dialog';
            dialog.innerHTML = `
                <div class="modal" style="max-width: 400px;">
                    <div class="modal-header">
                        <h2 class="modal-title">‚úÖ Task Completed</h2>
                        <button class="modal-close" onclick="closeTemplateDialog()">&times;</button>
                    </div>
                    <div class="modal-body">
                        <p style="margin-bottom: 1rem;">This task was created from a template. What would you like to do?</p>
                    </div>
                    <div class="modal-footer" style="flex-direction: column; gap: 0.5rem;">
                        <button class="btn btn-primary" style="width: 100%;" onclick="executeOnlyFromDialog('${taskId}')">
                            ‚ñ∂ Just Execute (stays available)
                        </button>
                        <button class="btn btn-secondary" style="width: 100%;" onclick="archiveFromDialog('${taskId}')">
                            üì¶ Archive Task
                        </button>
                    </div>
                </div>
            `;
            document.body.appendChild(dialog);
        }

        function closeTemplateDialog() {
            const dialog = document.getElementById('template-execution-dialog');
            if (dialog) dialog.remove();
        }

        function executeOnlyFromDialog(taskId) {
            closeTemplateDialog();
            const task = STATE.data.tasks.find(t => t.id === taskId);
            if (task) {
                // Move to done but don't archive - will auto-return
                task.status = 'done';
                task.completedAt = new Date().toISOString();
                
                // Auto-return to backlog after marking done
                setTimeout(() => {
                    if (task.status === 'done' && !task.archived) {
                        task.status = task.baseStatus || 'backlog';
                        delete task.completedAt;
                        // Reset subtasks
                        if (task.subtasks) {
                            task.subtasks.forEach(s => s.done = false);
                        }
                        renderTasks();
                        showToast('success', `Task "${task.title}" returned to backlog`);
                    }
                }, 2000);
                
                renderTasks();
                autoSave(`Complete "${task.title}" (auto-return)`);
            }
        }

        function archiveFromDialog(taskId) {
            closeTemplateDialog();
            quickMoveTask(taskId, 'done');
        }

        // === SCHEDULED TASKS FUNCTIONS (Task 7) ===
        function renderScheduledTasks() {
            const container = document.getElementById('tasks-scheduled');
            const countEl = document.getElementById('count-scheduled');
            const data = STATE.data || FALLBACK_DATA;
            const scheduled = data.tasks.filter(t => t.scheduledAt && t.status === 'scheduled');
            
            countEl.textContent = scheduled.length;
            
            if (scheduled.length === 0) {
                container.innerHTML = '<div class="empty-state">No scheduled tasks</div>';
                return;
            }
            
            // Sort by scheduledAt
            scheduled.sort((a, b) => new Date(a.scheduledAt) - new Date(b.scheduledAt));
            
            container.innerHTML = scheduled.map(task => {
                const scheduledDate = new Date(task.scheduledAt);
                const now = new Date();
                const isOverdue = scheduledDate < now;
                const countdown = formatScheduledCountdown(scheduledDate);
                
                return `
                    <div class="scheduled-card ${isOverdue ? 'overdue' : ''}" data-task-id="${task.id}" onclick="openTaskDetail('${task.id}')">
                        <div class="scheduled-name">${task.title}</div>
                        <div class="scheduled-time">
                            <span class="countdown ${isOverdue ? 'overdue' : ''}">
                                ${isOverdue ? '‚ö†Ô∏è Overdue' : '‚è∞ ' + countdown}
                            </span>
                        </div>
                        <div class="task-description">${task.description || ''}</div>
                    </div>
                `;
            }).join('');
            
            // Check for overdue tasks
            checkScheduledTasks();
        }

        function formatScheduledCountdown(date) {
            const now = new Date();
            const diff = date - now;
            
            if (diff < 0) return 'Overdue';
            
            const minutes = Math.floor(diff / 60000);
            const hours = Math.floor(diff / 3600000);
            const days = Math.floor(diff / 86400000);
            
            if (days > 0) return `in ${days}d ${hours % 24}h`;
            if (hours > 0) return `in ${hours}h ${minutes % 60}m`;
            return `in ${minutes}m`;
        }

        function checkScheduledTasks() {
            const data = STATE.data || FALLBACK_DATA;
            const scheduled = data.tasks.filter(t => t.scheduledAt && t.status === 'scheduled');
            const now = new Date();
            
            scheduled.forEach(task => {
                const scheduledDate = new Date(task.scheduledAt);
                if (scheduledDate <= now) {
                    // Auto-execute overdue task
                    executeScheduledTask(task.id);
                }
            });
        }

        function executeScheduledTask(taskId) {
            const task = STATE.data.tasks.find(t => t.id === taskId);
            if (!task) return;
            
            task.status = 'in_progress';
            delete task.scheduledAt;
            
            renderScheduledTasks();
            renderTasks();
            autoSave(`Auto-execute scheduled task "${task.title}"`);
            showToast('success', `Scheduled task "${task.title}" is now in progress!`);
        }

        function openScheduledTaskModal() {
            if (!STATE.user) {
                showToast('error', 'Login to schedule tasks');
                return;
            }
            
            const dialog = document.createElement('div');
            dialog.className = 'modal-overlay visible';
            dialog.id = 'scheduled-task-dialog';
            
            const now = new Date();
            const defaultDate = new Date(now.getTime() + 24 * 60 * 60 * 1000); // Tomorrow
            const dateStr = defaultDate.toISOString().slice(0, 16);
            
            dialog.innerHTML = `
                <div class="modal" style="max-width: 500px;">
                    <div class="modal-header">
                        <h2 class="modal-title">üìÖ Schedule Task</h2>
                        <button class="modal-close" onclick="closeScheduledTaskDialog()">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div class="form-group">
                            <label class="form-label">Title</label>
                            <input type="text" class="form-input" id="scheduled-title" placeholder="Task title">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Description</label>
                            <textarea class="form-input" id="scheduled-description" rows="2" placeholder="Task description"></textarea>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Scheduled For</label>
                            <input type="datetime-local" class="form-input" id="scheduled-datetime" value="${dateStr}">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Priority</label>
                            <select class="form-input" id="scheduled-priority">
                                <option value="low">Low</option>
                                <option value="medium" selected>Medium</option>
                                <option value="high">High</option>
                            </select>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-secondary" onclick="closeScheduledTaskDialog()">Cancel</button>
                        <button class="btn btn-primary" onclick="saveScheduledTask()">Schedule Task</button>
                    </div>
                </div>
            `;
            document.body.appendChild(dialog);
            document.getElementById('scheduled-title').focus();
        }

        function closeScheduledTaskDialog() {
            const dialog = document.getElementById('scheduled-task-dialog');
            if (dialog) dialog.remove();
        }

        function saveScheduledTask() {
            const title = document.getElementById('scheduled-title').value.trim();
            const description = document.getElementById('scheduled-description').value.trim();
            const datetime = document.getElementById('scheduled-datetime').value;
            const priority = document.getElementById('scheduled-priority').value;
            
            if (!title) {
                showToast('error', 'Title is required');
                return;
            }
            
            if (!datetime) {
                showToast('error', 'Please select a date and time');
                return;
            }
            
            const scheduledAt = new Date(datetime).toISOString();
            
            const newTask = {
                id: 'task_' + Date.now(),
                title,
                description,
                status: 'scheduled',
                scheduledAt,
                priority,
                project: 'system',
                tags: ['scheduled'],
                subtasks: [],
                createdAt: new Date().toISOString()
            };
            
            STATE.data.tasks.push(newTask);
            closeScheduledTaskDialog();
            renderScheduledTasks();
            autoSave(`Schedule task "${title}"`);
            showToast('success', `Task scheduled for ${new Date(scheduledAt).toLocaleString()}`);
        }

        // Check scheduled tasks every minute
        setInterval(() => {
            if (STATE.data) checkScheduledTasks();
        }, 60000);
        
        // Update scheduled task countdowns every 30 seconds
        setInterval(() => {
            if (STATE.data) renderScheduledTasks();
        }, 30000);
        
        // Update processing task timers every 30 seconds (for elapsed time display)
        setInterval(() => {
            if (STATE.data) {
                const processingTasks = STATE.data.tasks.filter(t => 
                    (t.processingStartedAt || t.processing) && t.status === 'in_progress'
                );
                if (processingTasks.length > 0) {
                    renderTasks();
                }
            }
        }, 30000);

        // === TASK 1: CRON DRAG & DROP ===
        let draggedCronId = null;
        
        function handleCronDragStart(event, cronId) {
            draggedCronId = cronId;
            event.target.classList.add('dragging');
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', 'cron:' + cronId);
        }
        
        function handleCronDragEnd(event) {
            event.target.classList.remove('dragging');
            draggedCronId = null;
            document.querySelectorAll('.column-tasks').forEach(col => {
                col.classList.remove('drag-over');
            });
        }
        
        function handleCronDragOver(event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';
        }
        
        function handleCronDragLeave(event) {
            const rect = event.currentTarget.getBoundingClientRect();
            const x = event.clientX;
            const y = event.clientY;
            if (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {
                event.currentTarget.classList.remove('drag-over');
            }
        }
        
        function handleCronDrop(event) {
            event.preventDefault();
            event.currentTarget.classList.remove('drag-over');
            // Crons dropped back on Recurring - do nothing
        }
        
        // Extended handleDrop for Cron drops
        const originalHandleDrop = handleDrop;
        handleDrop = function(event, newStatus) {
            event.preventDefault();
            const container = event.currentTarget;
            container.classList.remove('drag-over');
            
            const data = event.dataTransfer.getData('text/plain');
            
            // Check if it's a cron being dropped
            if (data.startsWith('cron:')) {
                const cronId = data.replace('cron:', '');
                const cron = STATE.crons?.find(c => c.id === cronId);
                
                if (!cron) return;
                
                if (newStatus === 'in_progress') {
                    // Execute cron via Gateway API
                    executeCronJob(cronId);
                } else if (newStatus === 'done') {
                    // Disable the cron
                    disableCronJob(cronId);
                } else {
                    showToast('info', 'Drop on "In Progress" to execute, "Done" to disable');
                }
                return;
            }
            
            // Regular task drop
            document.querySelectorAll('.task-card').forEach(card => {
                card.classList.remove('make-space-above', 'make-space-below');
            });

            if (!draggedTaskId || !STATE.user) return;

            const task = STATE.data.tasks.find(t => t.id === draggedTaskId);
            if (!task) return;

            const oldStatus = task.status;
            const statusChanged = task.status !== newStatus;
            
            // Check if this is a template-created task being moved to Done
            if (newStatus === 'done' && task.createdFromTemplate) {
                showTemplateExecutionDialog(draggedTaskId);
                draggedTaskId = null;
                return;
            }
            
            task.status = newStatus;

            // Set completedAt when moving to done
            if (newStatus === 'done') {
                task.completedAt = new Date().toISOString();
            } else if (oldStatus === 'done') {
                delete task.completedAt;
            }

            // Calculate new sortOrder based on drop position
            const priorityOrder = { high: 0, medium: 1, low: 2 };
            let tasksInColumn = STATE.data.tasks
                .filter(t => t.status === newStatus && t.id !== task.id)
                .sort((a, b) => {
                    const prioA = priorityOrder[a.priority] ?? 1;
                    const prioB = priorityOrder[b.priority] ?? 1;
                    if (prioA !== prioB) return prioA - prioB;
                    return (a.sortOrder ?? 999999) - (b.sortOrder ?? 999999);
                });

            // Find insert position
            let insertIdx = tasksInColumn.length;
            if (dropTargetInfo?.insertBeforeId) {
                const targetIdx = tasksInColumn.findIndex(t => t.id === dropTargetInfo.insertBeforeId);
                if (targetIdx >= 0) insertIdx = targetIdx;
            }

            // Insert task at position
            tasksInColumn.splice(insertIdx, 0, task);

            // Recalculate sortOrder for all tasks in this column
            let currentPriority = null;
            let orderCounter = 0;
            tasksInColumn.forEach(t => {
                if (t.priority !== currentPriority) {
                    currentPriority = t.priority;
                    orderCounter = 0;
                }
                t.sortOrder = orderCounter++;
            });

            STATE.data.lastUpdated = new Date().toISOString();

            if (statusChanged) {
                STATE.data.activities = STATE.data.activities || [];
                STATE.data.activities.unshift({
                    type: 'moved',
                    actor: STATE.user?.login || 'User',
                    task: task.title,
                    from: oldStatus,
                    to: newStatus,
                    time: 'just now'
                });
                renderActivity();
            }

            renderTasksSmooth(oldStatus, newStatus, task.id);

            const action = statusChanged
                ? `Move "${task.title}" ‚Üí ${newStatus}`
                : `Reorder "${task.title}"`;
            autoSave(action);

            dropTargetInfo = null;
            lastDropTargetInfo = null;
        };
        
        async function executeCronJob(cronId) {
            const cron = STATE.crons?.find(c => c.id === cronId);
            if (!cron) return;
            
            const gatewayUrl = getGatewayUrl();
            
            if (!gatewayUrl) {
                // No gateway available - show CLI command
                showToast('info', `üöÄ To execute "${cron.name}":`);
                setTimeout(() => {
                    showToast('info', `Run: clawdbot cron run ${cronId}`, 8000);
                }, 500);
                // Copy command to clipboard
                navigator.clipboard?.writeText(`clawdbot cron run ${cronId}`);
                return;
            }
            
            showToast('info', `üöÄ Executing "${cron.name}"...`);
            
            try {
                // Call Gateway API to execute cron
                const response = await fetch(gatewayUrl + '/api/crons/' + cronId + '/run', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                if (response.ok) {
                    showToast('success', `‚úì Cron "${cron.name}" started`);
                    // Start polling for status
                    pollCronStatus(cronId);
                } else {
                    showToast('error', `Failed to execute cron`);
                }
            } catch (e) {
                // Fallback: Show CLI command
                showToast('info', `Gateway not reachable. Run: clawdbot cron run ${cronId}`, 8000);
                navigator.clipboard?.writeText(`clawdbot cron run ${cronId}`);
            }
        }
        
        let cronPollingIntervals = {};
        
        function pollCronStatus(cronId) {
            // Poll every 2 seconds
            if (cronPollingIntervals[cronId]) {
                clearInterval(cronPollingIntervals[cronId]);
            }
            
            cronPollingIntervals[cronId] = setInterval(async () => {
                try {
                    await loadCronsFromGitHub();
                    const cron = STATE.crons?.find(c => c.id === cronId);
                    
                    if (cron && cron.lastStatus === 'ok') {
                        clearInterval(cronPollingIntervals[cronId]);
                        delete cronPollingIntervals[cronId];
                        showToast('success', `‚úÖ Cron "${cron.name}" completed`);
                        renderCrons();
                    }
                } catch (e) {
                    console.log('Polling error:', e);
                }
            }, 2000);
            
            // Stop polling after 5 minutes
            setTimeout(() => {
                if (cronPollingIntervals[cronId]) {
                    clearInterval(cronPollingIntervals[cronId]);
                    delete cronPollingIntervals[cronId];
                }
            }, 5 * 60 * 1000);
        }
        
        async function disableCronJob(cronId) {
            const cron = STATE.crons?.find(c => c.id === cronId);
            if (!cron) return;
            
            const gatewayUrl = getGatewayUrl();
            if (!gatewayUrl) {
                showToast('info', `Run: clawdbot cron update ${cronId} --disabled`, 8000);
                navigator.clipboard?.writeText(`clawdbot cron update ${cronId} --disabled`);
                return;
            }
            
            try {
                const response = await fetch(gatewayUrl + '/api/crons/' + cronId, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ enabled: false })
                });
                
                if (response.ok) {
                    cron.enabled = false;
                    renderCrons();
                    showToast('success', `Disabled cron "${cron.name}"`);
                } else {
                    showToast('error', 'Failed to disable cron');
                }
            } catch (e) {
                showToast('info', `Run: clawdbot cron update ${cronId} --disabled`, 8000);
            }
        }

        // === TASK 2: CRON EDITOR ===
        function openCronDetail(cronId) {
            const cron = STATE.crons?.find(c => c.id === cronId);
            if (!cron) {
                showToast('error', 'Cron not found');
                return;
            }
            
            const dialog = document.createElement('div');
            dialog.className = 'modal-overlay visible';
            dialog.id = 'cron-editor-dialog';
            dialog.innerHTML = `
                <div class="modal" style="max-width: 550px;">
                    <div class="modal-header">
                        <h2 class="modal-title">üîÑ Edit Cron Job</h2>
                        <button class="modal-close" onclick="closeCronEditor()">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div class="form-group">
                            <label class="form-label">Name</label>
                            <input type="text" class="form-input" id="cron-name" value="${escapeHtml(cron.name)}">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Prompt / Command</label>
                            <textarea class="form-input" id="cron-prompt" rows="4" placeholder="What should this cron do?">${escapeHtml(cron.prompt || '')}</textarea>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Schedule (Cron Expression)</label>
                            <input type="text" class="form-input" id="cron-schedule" value="${cron.schedule}" placeholder="0 8 * * *">
                            <div class="form-hint" id="cron-schedule-hint">
                                Human readable: <strong>${cron.scheduleHuman || 'Unknown'}</strong>
                            </div>
                            <div id="cron-validation-error" style="color: var(--accent-red); font-size: 0.8rem; margin-top: 0.25rem; display: none;"></div>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Timezone</label>
                            <select class="form-input" id="cron-timezone">
                                <option value="Europe/Berlin" ${cron.timezone === 'Europe/Berlin' ? 'selected' : ''}>Europe/Berlin</option>
                                <option value="UTC" ${cron.timezone === 'UTC' ? 'selected' : ''}>UTC</option>
                                <option value="America/New_York" ${cron.timezone === 'America/New_York' ? 'selected' : ''}>America/New_York</option>
                                <option value="America/Los_Angeles" ${cron.timezone === 'America/Los_Angeles' ? 'selected' : ''}>America/Los_Angeles</option>
                                <option value="Asia/Tokyo" ${cron.timezone === 'Asia/Tokyo' ? 'selected' : ''}>Asia/Tokyo</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                                <input type="checkbox" id="cron-enabled" ${cron.enabled ? 'checked' : ''}>
                                <span>Enabled</span>
                            </label>
                        </div>
                        <div class="form-group" style="background: var(--bg-secondary); padding: 1rem; border-radius: 8px;">
                            <label class="form-label" style="margin-bottom: 0.5rem;">üìÖ Next 5 Runs</label>
                            <div id="cron-next-runs" style="font-size: 0.85rem; color: var(--text-secondary);">
                                ${generateNextRuns(cron.schedule, cron.timezone)}
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-secondary" style="margin-right: auto;" onclick="convertCronToTask('${cronId}')">üìã As Task</button>
                        <button class="btn btn-secondary" onclick="closeCronEditor()">Cancel</button>
                        <button class="btn btn-primary" onclick="saveCronChanges('${cronId}')">Save Changes</button>
                    </div>
                </div>
            `;
            document.body.appendChild(dialog);
            
            // Add schedule validation on input
            document.getElementById('cron-schedule').addEventListener('input', function() {
                validateCronSchedule(this.value);
            });
        }
        
        function escapeHtml(text) {
            if (!text) return '';
            return text.replace(/&/g, '&amp;')
                       .replace(/</g, '&lt;')
                       .replace(/>/g, '&gt;')
                       .replace(/"/g, '&quot;');
        }
        
        function validateCronSchedule(schedule) {
            const errorEl = document.getElementById('cron-validation-error');
            const hintEl = document.getElementById('cron-schedule-hint');
            const nextRunsEl = document.getElementById('cron-next-runs');
            
            // Simple cron validation (5 fields)
            const parts = schedule.trim().split(/\s+/);
            if (parts.length !== 5) {
                errorEl.textContent = 'Cron expression must have 5 fields (minute hour day month weekday)';
                errorEl.style.display = 'block';
                return false;
            }
            
            // Validate each field
            const ranges = [
                { min: 0, max: 59, name: 'minute' },
                { min: 0, max: 23, name: 'hour' },
                { min: 1, max: 31, name: 'day' },
                { min: 1, max: 12, name: 'month' },
                { min: 0, max: 7, name: 'weekday' }
            ];
            
            for (let i = 0; i < 5; i++) {
                if (!isValidCronField(parts[i], ranges[i])) {
                    errorEl.textContent = `Invalid ${ranges[i].name} field: ${parts[i]}`;
                    errorEl.style.display = 'block';
                    return false;
                }
            }
            
            errorEl.style.display = 'none';
            const humanReadable = cronToHuman(schedule);
            hintEl.innerHTML = `Human readable: <strong>${humanReadable}</strong>`;
            nextRunsEl.innerHTML = generateNextRuns(schedule, document.getElementById('cron-timezone')?.value || 'Europe/Berlin');
            return true;
        }
        
        function isValidCronField(field, range) {
            if (field === '*') return true;
            if (field.includes('/')) {
                const [base, step] = field.split('/');
                if (base !== '*' && !isValidCronField(base, range)) return false;
                const stepNum = parseInt(step);
                return !isNaN(stepNum) && stepNum > 0;
            }
            if (field.includes('-')) {
                const [start, end] = field.split('-').map(Number);
                return !isNaN(start) && !isNaN(end) && start >= range.min && end <= range.max && start <= end;
            }
            if (field.includes(',')) {
                return field.split(',').every(f => isValidCronField(f.trim(), range));
            }
            const num = parseInt(field);
            return !isNaN(num) && num >= range.min && num <= range.max;
        }
        
        function cronToHuman(schedule) {
            const parts = schedule.trim().split(/\s+/);
            if (parts.length !== 5) return schedule;
            
            const [minute, hour, day, month, weekday] = parts;
            
            // Simple patterns
            if (minute !== '*' && hour !== '*' && day === '*' && month === '*' && weekday === '*') {
                return `Daily at ${hour.padStart(2, '0')}:${minute.padStart(2, '0')}`;
            }
            if (minute !== '*' && hour !== '*' && day === '*' && month === '*' && weekday !== '*') {
                const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
                const dayName = days[parseInt(weekday)] || weekday;
                return `${dayName} at ${hour.padStart(2, '0')}:${minute.padStart(2, '0')}`;
            }
            if (minute === '0' && hour === '*' && day === '*' && month === '*' && weekday === '*') {
                return 'Every hour';
            }
            if (minute.includes('/')) {
                const interval = minute.split('/')[1];
                return `Every ${interval} minutes`;
            }
            
            return schedule;
        }
        
        function generateNextRuns(schedule, timezone) {
            try {
                // Simple next run calculation (approximate)
                const runs = [];
                const now = new Date();
                let checkDate = new Date(now);
                
                const parts = schedule.trim().split(/\s+/);
                if (parts.length !== 5) return 'Invalid schedule';
                
                const [cronMin, cronHour, cronDay, cronMonth, cronWeekday] = parts;
                
                for (let i = 0; i < 100 && runs.length < 5; i++) {
                    checkDate = new Date(checkDate.getTime() + (i === 0 ? 60000 : 60000));
                    
                    const min = checkDate.getMinutes();
                    const hour = checkDate.getHours();
                    const day = checkDate.getDate();
                    const month = checkDate.getMonth() + 1;
                    const weekday = checkDate.getDay();
                    
                    if (matchesCronField(cronMin, min) &&
                        matchesCronField(cronHour, hour) &&
                        matchesCronField(cronDay, day) &&
                        matchesCronField(cronMonth, month) &&
                        matchesCronField(cronWeekday, weekday)) {
                        runs.push(checkDate.toLocaleString('de-DE', { 
                            weekday: 'short', 
                            day: '2-digit', 
                            month: '2-digit', 
                            hour: '2-digit', 
                            minute: '2-digit' 
                        }));
                        // Skip to next minute
                        checkDate = new Date(checkDate.getTime() + 60000);
                    }
                    
                    // Skip forward more aggressively for daily/weekly jobs
                    if (cronMin !== '*' && cronHour !== '*') {
                        checkDate = new Date(checkDate.getTime() + 3600000); // Skip 1 hour
                    }
                }
                
                return runs.length > 0 ? runs.map(r => `‚Ä¢ ${r}`).join('<br>') : 'Could not calculate next runs';
            } catch (e) {
                return 'Error calculating runs';
            }
        }
        
        function matchesCronField(field, value) {
            if (field === '*') return true;
            if (field.includes('/')) {
                const [base, step] = field.split('/');
                const stepNum = parseInt(step);
                if (base === '*') return value % stepNum === 0;
                return false; // Simplified
            }
            if (field.includes(',')) {
                return field.split(',').some(f => matchesCronField(f.trim(), value));
            }
            if (field.includes('-')) {
                const [start, end] = field.split('-').map(Number);
                return value >= start && value <= end;
            }
            return parseInt(field) === value;
        }
        
        function closeCronEditor() {
            const dialog = document.getElementById('cron-editor-dialog');
            if (dialog) dialog.remove();
        }
        
        async function saveCronChanges(cronId) {
            const name = document.getElementById('cron-name').value.trim();
            const prompt = document.getElementById('cron-prompt').value.trim();
            const schedule = document.getElementById('cron-schedule').value.trim();
            const timezone = document.getElementById('cron-timezone').value;
            const enabled = document.getElementById('cron-enabled').checked;
            
            if (!name) {
                showToast('error', 'Name is required');
                return;
            }
            
            if (!validateCronSchedule(schedule)) {
                showToast('error', 'Invalid cron schedule');
                return;
            }
            
            const gatewayUrl = getGatewayUrl();
            if (!gatewayUrl) {
                // Save locally and show CLI command
                const cron = STATE.crons?.find(c => c.id === cronId);
                if (cron) {
                    cron.name = name;
                    cron.prompt = prompt;
                    cron.schedule = schedule;
                    cron.scheduleHuman = cronToHuman(schedule);
                    cron.timezone = timezone;
                    cron.enabled = enabled;
                }
                closeCronEditor();
                renderCrons();
                showToast('info', 'Gateway not available. Changes saved locally only.');
                return;
            }
            
            try {
                const response = await fetch(gatewayUrl + '/api/crons/' + cronId, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name, prompt, schedule, timezone, enabled })
                });
                
                if (response.ok) {
                    const cron = STATE.crons?.find(c => c.id === cronId);
                    if (cron) {
                        cron.name = name;
                        cron.prompt = prompt;
                        cron.schedule = schedule;
                        cron.scheduleHuman = cronToHuman(schedule);
                        cron.timezone = timezone;
                        cron.enabled = enabled;
                    }
                    closeCronEditor();
                    renderCrons();
                    showToast('success', `Cron "${name}" updated`);
                } else {
                    showToast('error', 'Failed to save cron');
                }
            } catch (e) {
                showToast('info', 'Gateway not available. Changes saved locally only.');
                const cron = STATE.crons?.find(c => c.id === cronId);
                if (cron) {
                    cron.name = name;
                    cron.prompt = prompt;
                    cron.schedule = schedule;
                    cron.scheduleHuman = cronToHuman(schedule);
                    cron.timezone = timezone;
                    cron.enabled = enabled;
                }
                closeCronEditor();
                renderCrons();
            }
        }

        // === TASK 3: TASK ‚Üí CRON ===
        function openTaskToCronWizard(taskId) {
            const task = STATE.data.tasks.find(t => t.id === taskId);
            if (!task) return;
            
            const dialog = document.createElement('div');
            dialog.className = 'modal-overlay visible';
            dialog.id = 'task-to-cron-wizard';
            dialog.innerHTML = `
                <div class="modal" style="max-width: 500px;">
                    <div class="modal-header">
                        <h2 class="modal-title">‚è∞ Convert to Cron</h2>
                        <button class="modal-close" onclick="closeTaskToCronWizard()">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div class="steps" style="margin-bottom: 1rem;">
                            <div class="step">
                                <span class="step-number">1</span>
                                <div class="step-content">
                                    <div class="step-title">Choose Schedule Type</div>
                                </div>
                            </div>
                        </div>
                        
                        <div id="wizard-step-1">
                            <div style="display: grid; gap: 0.5rem;">
                                <button class="btn btn-secondary" style="justify-content: flex-start;" onclick="setScheduleType('daily')">
                                    üìÖ Daily
                                </button>
                                <button class="btn btn-secondary" style="justify-content: flex-start;" onclick="setScheduleType('weekly')">
                                    üìÜ Weekly
                                </button>
                                <button class="btn btn-secondary" style="justify-content: flex-start;" onclick="setScheduleType('monthly')">
                                    üóìÔ∏è Monthly
                                </button>
                                <button class="btn btn-secondary" style="justify-content: flex-start;" onclick="setScheduleType('custom')">
                                    ‚öôÔ∏è Custom Cron Expression
                                </button>
                            </div>
                        </div>
                        
                        <div id="wizard-step-2" style="display: none;">
                            <div class="form-group">
                                <label class="form-label">Time</label>
                                <input type="time" class="form-input" id="wizard-time" value="08:00">
                            </div>
                            <div class="form-group" id="wizard-weekday-group" style="display: none;">
                                <label class="form-label">Day of Week</label>
                                <select class="form-input" id="wizard-weekday">
                                    <option value="1">Monday</option>
                                    <option value="2">Tuesday</option>
                                    <option value="3">Wednesday</option>
                                    <option value="4">Thursday</option>
                                    <option value="5">Friday</option>
                                    <option value="6">Saturday</option>
                                    <option value="0">Sunday</option>
                                </select>
                            </div>
                            <div class="form-group" id="wizard-monthday-group" style="display: none;">
                                <label class="form-label">Day of Month</label>
                                <input type="number" class="form-input" id="wizard-monthday" min="1" max="31" value="1">
                            </div>
                            <div class="form-group" id="wizard-custom-group" style="display: none;">
                                <label class="form-label">Cron Expression</label>
                                <input type="text" class="form-input" id="wizard-custom-cron" placeholder="0 8 * * *">
                            </div>
                        </div>
                        
                        <div id="wizard-step-3" style="display: none;">
                            <div class="form-group">
                                <label class="form-label">Cron Name</label>
                                <input type="text" class="form-input" id="cron-wizard-title" value="${task.title}">
                            </div>
                            <div style="background: var(--bg-secondary); padding: 1rem; border-radius: 8px;">
                                <strong>Summary:</strong>
                                <div id="wizard-summary" style="margin-top: 0.5rem; color: var(--text-secondary);"></div>
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-secondary" id="wizard-back" onclick="wizardBack()" style="display: none;">Back</button>
                        <button class="btn btn-secondary" onclick="closeTaskToCronWizard()">Cancel</button>
                        <button class="btn btn-primary" id="wizard-next" onclick="wizardNext('${taskId}')" style="display: none;">Next</button>
                        <button class="btn btn-primary" id="wizard-create" onclick="createCronFromTask('${taskId}')" style="display: none;">Create Cron</button>
                    </div>
                </div>
            `;
            document.body.appendChild(dialog);
            
            window.wizardState = { step: 1, type: null, taskId };
        }
        
        function setScheduleType(type) {
            window.wizardState.type = type;
            document.getElementById('wizard-step-1').style.display = 'none';
            document.getElementById('wizard-step-2').style.display = 'block';
            document.getElementById('wizard-back').style.display = 'inline-flex';
            document.getElementById('wizard-next').style.display = 'inline-flex';
            
            // Show relevant fields
            document.getElementById('wizard-weekday-group').style.display = type === 'weekly' ? 'block' : 'none';
            document.getElementById('wizard-monthday-group').style.display = type === 'monthly' ? 'block' : 'none';
            document.getElementById('wizard-custom-group').style.display = type === 'custom' ? 'block' : 'none';
            
            window.wizardState.step = 2;
        }
        
        function wizardBack() {
            if (window.wizardState.step === 2) {
                document.getElementById('wizard-step-2').style.display = 'none';
                document.getElementById('wizard-step-1').style.display = 'block';
                document.getElementById('wizard-back').style.display = 'none';
                document.getElementById('wizard-next').style.display = 'none';
                window.wizardState.step = 1;
            } else if (window.wizardState.step === 3) {
                document.getElementById('wizard-step-3').style.display = 'none';
                document.getElementById('wizard-step-2').style.display = 'block';
                document.getElementById('wizard-next').style.display = 'inline-flex';
                document.getElementById('wizard-create').style.display = 'none';
                window.wizardState.step = 2;
            }
        }
        
        function wizardNext(taskId) {
            const task = STATE.data.tasks.find(t => t.id === taskId);
            const type = window.wizardState.type;
            const time = document.getElementById('wizard-time').value;
            const [hour, minute] = time.split(':');
            
            let schedule;
            let scheduleDesc;
            
            if (type === 'daily') {
                schedule = `${minute} ${hour} * * *`;
                scheduleDesc = `Daily at ${time}`;
            } else if (type === 'weekly') {
                const weekday = document.getElementById('wizard-weekday').value;
                const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                schedule = `${minute} ${hour} * * ${weekday}`;
                scheduleDesc = `Every ${dayNames[parseInt(weekday)]} at ${time}`;
            } else if (type === 'monthly') {
                const monthday = document.getElementById('wizard-monthday').value;
                schedule = `${minute} ${hour} ${monthday} * *`;
                scheduleDesc = `Monthly on day ${monthday} at ${time}`;
            } else {
                schedule = document.getElementById('wizard-custom-cron').value;
                scheduleDesc = schedule;
            }
            
            window.wizardState.schedule = schedule;
            window.wizardState.scheduleDesc = scheduleDesc;
            
            // Build prompt from task
            let prompt = task.description || task.title;
            if (task.subtasks && task.subtasks.length > 0) {
                prompt += '\n\nSubtasks:\n' + task.subtasks.map(s => `- ${s.title}`).join('\n');
            }
            window.wizardState.prompt = prompt;
            
            // Show summary
            document.getElementById('wizard-step-2').style.display = 'none';
            document.getElementById('wizard-step-3').style.display = 'block';
            document.getElementById('wizard-next').style.display = 'none';
            document.getElementById('wizard-create').style.display = 'inline-flex';
            
            document.getElementById('wizard-summary').innerHTML = `
                <strong>Name:</strong> ${task.title}<br>
                <strong>Schedule:</strong> ${scheduleDesc}<br>
                <strong>Cron:</strong> <code>${schedule}</code><br>
                <strong>Original task will be archived.</strong>
            `;
            
            window.wizardState.step = 3;
        }
        
        async function createCronFromTask(taskId) {
            const task = STATE.data.tasks.find(t => t.id === taskId);
            if (!task) return;
            
            // Read current values from wizard inputs (not stored state)
            const titleInput = document.getElementById('cron-wizard-title');
            const cronTitle = titleInput ? titleInput.value.trim() : task.title;
            const { schedule, scheduleDesc, prompt } = window.wizardState;
            const gatewayUrl = getGatewayUrl();
            
            // Helper to create cron locally and save to GitHub
            async function createLocalCron() {
                const newCron = {
                    id: crypto.randomUUID ? crypto.randomUUID() : 'cron_' + Date.now(),
                    name: cronTitle,
                    prompt: prompt,
                    schedule: schedule,
                    scheduleHuman: scheduleDesc,
                    timezone: 'Europe/Berlin',
                    enabled: true,
                    pending: true, // Mark as pending - needs Gateway sync
                    createdAt: new Date().toISOString()
                };
                
                STATE.crons = STATE.crons || [];
                STATE.crons.push(newCron);
                
                // Archive original task
                task.archived = true;
                task.archivedAt = new Date().toISOString();
                task.archivedReason = 'Converted to cron: ' + newCron.id;
                
                // Save crons to GitHub
                const cronsSaved = await saveCronsToGitHub(`Add cron "${cronTitle}" (pending Gateway sync)`);
                
                closeTaskToCronWizard();
                renderCrons();
                renderTasks();
                autoSave(`Convert task "${task.title}" to cron`);
                
                if (cronsSaved) {
                    showToast('success', `‚úì Cron "${cronTitle}" saved (will activate on next sync)`);
                } else {
                    showToast('warning', `Cron created locally but failed to save to GitHub`);
                }
                return true;
            }
            
            if (!gatewayUrl) {
                // No Gateway available - save locally to GitHub
                await createLocalCron();
                return;
            }
            
            try {
                const response = await fetch(gatewayUrl + '/api/crons', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        name: cronTitle,
                        prompt: prompt,
                        schedule: schedule,
                        scheduleHuman: scheduleDesc,
                        timezone: 'Europe/Berlin',
                        enabled: true
                    })
                });
                
                if (response.ok) {
                    const newCron = await response.json();
                    STATE.crons = STATE.crons || [];
                    STATE.crons.push(newCron);
                    
                    // Archive original task
                    task.archived = true;
                    task.archivedAt = new Date().toISOString();
                    task.archivedReason = 'Converted to cron: ' + newCron.id;
                    
                    closeTaskToCronWizard();
                    renderCrons();
                    renderTasks();
                    autoSave(`Convert task "${task.title}" to cron`);
                    showToast('success', `Created cron "${cronTitle}"`);
                } else {
                    showToast('error', 'Failed to create cron via Gateway');
                }
            } catch (e) {
                // Gateway not reachable - fallback to local save
                console.log('Gateway not reachable, saving locally:', e);
                await createLocalCron();
            }
        }
        
        function closeTaskToCronWizard() {
            const dialog = document.getElementById('task-to-cron-wizard');
            if (dialog) dialog.remove();
            delete window.wizardState;
        }

        // === TASK 4: CRON ‚Üí TASK ===
        function convertCronToTask(cronId) {
            const cron = STATE.crons?.find(c => c.id === cronId);
            if (!cron) return;
            
            const dialog = document.createElement('div');
            dialog.className = 'modal-overlay visible';
            dialog.id = 'cron-to-task-dialog';
            dialog.innerHTML = `
                <div class="modal" style="max-width: 400px;">
                    <div class="modal-header">
                        <h2 class="modal-title">üìã Convert to Task</h2>
                        <button class="modal-close" onclick="closeCronToTaskDialog()">&times;</button>
                    </div>
                    <div class="modal-body">
                        <p style="margin-bottom: 1rem;">Create a task from cron "${cron.name}"?</p>
                        <div style="background: var(--bg-secondary); padding: 1rem; border-radius: 8px; margin-bottom: 1rem;">
                            <strong>Task will include:</strong>
                            <div style="color: var(--text-secondary); margin-top: 0.5rem;">
                                Schedule: ${cron.scheduleHuman || cron.schedule}<br>
                                ${cron.prompt ? `Prompt: ${cron.prompt.substring(0, 100)}${cron.prompt.length > 100 ? '...' : ''}` : ''}
                            </div>
                        </div>
                        <div class="form-group">
                            <label class="form-label">What to do with the cron?</label>
                            <select class="form-input" id="cron-action-select">
                                <option value="disable">Disable cron</option>
                                <option value="delete">Delete cron</option>
                                <option value="keep">Keep cron active</option>
                            </select>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-secondary" onclick="closeCronToTaskDialog()">Cancel</button>
                        <button class="btn btn-primary" onclick="executeConvertCronToTask('${cronId}')">Create Task</button>
                    </div>
                </div>
            `;
            document.body.appendChild(dialog);
        }
        
        function closeCronToTaskDialog() {
            const dialog = document.getElementById('cron-to-task-dialog');
            if (dialog) dialog.remove();
        }
        
        async function executeConvertCronToTask(cronId) {
            const cron = STATE.crons?.find(c => c.id === cronId);
            if (!cron) return;
            
            const action = document.getElementById('cron-action-select').value;
            
            // Create task
            const newTask = {
                id: 'task_' + Date.now(),
                title: cron.name,
                description: `Schedule: ${cron.scheduleHuman || cron.schedule}\n\n${cron.prompt || ''}`,
                status: 'backlog',
                project: 'system',
                tags: ['from-cron'],
                subtasks: [],
                priority: 'medium',
                createdAt: new Date().toISOString(),
                createdFromCron: cronId
            };
            
            STATE.data.tasks.push(newTask);
            
            // Handle cron action
            if (action === 'disable') {
                await disableCronJob(cronId);
            } else if (action === 'delete') {
                const gatewayUrl = getGatewayUrl();
                if (gatewayUrl) {
                    try {
                        await fetch(gatewayUrl + '/api/crons/' + cronId, { method: 'DELETE' });
                        STATE.crons = STATE.crons.filter(c => c.id !== cronId);
                    } catch (e) {
                        console.log('Could not delete cron via API');
                        showToast('info', `Run: clawdbot cron remove ${cronId}`, 8000);
                    }
                } else {
                    showToast('info', `Run: clawdbot cron remove ${cronId}`, 8000);
                    navigator.clipboard?.writeText(`clawdbot cron remove ${cronId}`);
                }
            }
            
            closeCronToTaskDialog();
            closeCronEditor();
            renderCrons();
            renderTasks();
            autoSave(`Create task from cron "${cron.name}"`);
            showToast('success', `Created task "${cron.name}"`);
        }

        // === COLLABORATORS / PEOPLE ===
        let collaboratorsLoaded = false;

        async function loadCollaborators() {
            if (collaboratorsLoaded) return;

            const container = document.getElementById('collaborators-container');
            const statsContainer = document.getElementById('people-stats');

            // Show loading
            container.innerHTML = `
                <div class="people-loading">
                    <div class="spinner"></div>
                    <p>Loading collaborators...</p>
                </div>
            `;

            const token = STATE.token || localStorage.getItem('github_token');

            if (!token) {
                container.innerHTML = `
                    <div class="people-empty">
                        <div class="people-empty-icon">üîí</div>
                        <p>Connect to GitHub to see team members</p>
                    </div>
                `;
                return;
            }

            try {
                const response = await fetch(
                    `https://api.github.com/repos/${CONFIG.owner}/${CONFIG.repo}/collaborators`,
                    {
                        headers: {
                            'Authorization': `token ${token}`,
                            'Accept': 'application/vnd.github.v3+json'
                        }
                    }
                );

                if (!response.ok) {
                    throw new Error(`GitHub API error: ${response.status}`);
                }

                const collaborators = await response.json();
                collaboratorsLoaded = true;

                if (collaborators.length === 0) {
                    container.innerHTML = `
                        <div class="people-empty">
                            <div class="people-empty-icon">üë§</div>
                            <p>No collaborators found</p>
                        </div>
                    `;
                    return;
                }

                // Count by role
                const roleCounts = { admin: 0, maintain: 0, write: 0, triage: 0, read: 0 };
                collaborators.forEach(c => {
                    const role = c.role_name?.toLowerCase() || 'read';
                    if (roleCounts[role] !== undefined) roleCounts[role]++;
                });

                // Render stats
                statsContainer.innerHTML = `
                    <div class="people-stat"><strong>${collaborators.length}</strong> members</div>
                    ${roleCounts.admin > 0 ? `<div class="people-stat"><strong>${roleCounts.admin}</strong> admins</div>` : ''}
                `;

                // Render collaborator cards
                const cardsHtml = collaborators.map(c => {
                    const role = c.role_name?.toLowerCase() || 'read';
                    const roleLabel = role.charAt(0).toUpperCase() + role.slice(1);
                    const roleIcon = {
                        admin: 'üëë',
                        maintain: 'üîß',
                        write: '‚úèÔ∏è',
                        triage: 'üìã',
                        read: 'üëÅÔ∏è'
                    }[role] || 'üë§';

                    return `
                        <div class="collaborator-card">
                            <img class="collaborator-avatar" src="${c.avatar_url}" alt="${c.login}" loading="lazy">
                            <div class="collaborator-info">
                                <div class="collaborator-name">${c.login}</div>
                                <div class="collaborator-username">
                                    <a href="${c.html_url}" target="_blank" rel="noopener">@${c.login}</a>
                                </div>
                                <span class="collaborator-role role-${role}">${roleIcon} ${roleLabel}</span>
                            </div>
                        </div>
                    `;
                }).join('');

                container.innerHTML = `<div class="collaborators-grid">${cardsHtml}</div>`;

            } catch (error) {
                console.error('Failed to load collaborators:', error);
                container.innerHTML = `
                    <div class="people-empty">
                        <div class="people-empty-icon">‚ö†Ô∏è</div>
                        <p>Failed to load collaborators</p>
                        <p style="font-size: 0.875rem; margin-top: 0.5rem;">${error.message}</p>
                    </div>
                `;
            }
        }

        // Extend switchView to load collaborators when People tab is selected
        const originalSwitchView = switchView;
        switchView = function(viewName) {
            originalSwitchView(viewName);
            if (viewName === 'people') {
                loadCollaborators();
            }
        };

        // === VOICE INPUT FUNCTIONS ===
        let voiceRecognition = null;
        let voiceTargetColumn = 'backlog';
        let voiceTranscript = '';
        let voiceIsListening = false;
        
        // Check browser support
        function isSpeechRecognitionSupported() {
            return 'webkitSpeechRecognition' in window || 'SpeechRecognition' in window;
        }
        
        // Initialize speech recognition
        function initVoiceRecognition() {
            if (!isSpeechRecognitionSupported()) {
                return null;
            }
            
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            const recognition = new SpeechRecognition();
            
            recognition.lang = 'en-US';
            recognition.continuous = false;
            recognition.interimResults = true;
            recognition.maxAlternatives = 1;
            
            recognition.onstart = () => {
                voiceIsListening = true;
                updateVoiceModalUI('listening');
            };
            
            recognition.onresult = (event) => {
                const results = event.results;
                const lastResult = results[results.length - 1];
                voiceTranscript = lastResult[0].transcript;
                
                // Update transcript display
                const transcriptEl = document.getElementById('voice-modal-transcript');
                if (transcriptEl) {
                    transcriptEl.innerHTML = voiceTranscript;
                }
                
                // If final result, enable create button
                if (lastResult.isFinal) {
                    updateVoiceModalUI('ready');
                }
            };
            
            recognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
                if (event.error === 'no-speech') {
                    updateVoiceModalUI('no-speech');
                } else if (event.error === 'not-allowed') {
                    showToast('error', 'Microphone access denied. Please allow microphone access.');
                    cancelVoiceInput();
                } else {
                    showToast('error', `Voice error: ${event.error}`);
                    updateVoiceModalUI('error');
                }
            };
            
            recognition.onend = () => {
                voiceIsListening = false;
                if (voiceTranscript) {
                    updateVoiceModalUI('ready');
                } else {
                    updateVoiceModalUI('ended');
                }
            };
            
            return recognition;
        }
        
        // Start voice input from column header button
        function startVoiceInput(column = 'backlog') {
            if (!STATE.user) {
                showToast('error', 'Login to add tasks by voice');
                return;
            }
            
            if (!isSpeechRecognitionSupported()) {
                showToast('error', 'Voice input not supported in this browser. Try Chrome or Edge.');
                return;
            }
            
            voiceTargetColumn = column;
            voiceTranscript = '';
            
            // Show voice modal
            const modal = document.getElementById('voice-modal');
            if (modal) {
                modal.classList.add('visible');
            }
            
            // Reset UI
            updateVoiceModalUI('starting');
            
            // Initialize and start recognition
            if (!voiceRecognition) {
                voiceRecognition = initVoiceRecognition();
            }
            
            if (voiceRecognition) {
                try {
                    voiceRecognition.start();
                } catch (e) {
                    console.log('Recognition already started or error:', e);
                }
            }
        }
        
        // Update voice modal UI state
        function updateVoiceModalUI(state) {
            const iconEl = document.getElementById('voice-modal-icon');
            const statusEl = document.getElementById('voice-modal-status');
            const hintEl = document.getElementById('voice-modal-hint');
            const transcriptEl = document.getElementById('voice-modal-transcript');
            const createBtn = document.getElementById('voice-create-btn');
            
            switch(state) {
                case 'starting':
                    iconEl.textContent = 'üé§';
                    iconEl.classList.add('recording');
                    statusEl.textContent = 'Starting...';
                    hintEl.textContent = 'Getting microphone access...';
                    transcriptEl.innerHTML = '<span style="color: var(--text-secondary); font-style: italic;">Waiting for speech...</span>';
                    createBtn.disabled = true;
                    break;
                    
                case 'listening':
                    iconEl.textContent = 'üé§';
                    iconEl.classList.add('recording');
                    statusEl.textContent = 'Listening...';
                    hintEl.innerHTML = `Speak your task. Target column: <strong>${formatColumnName(voiceTargetColumn)}</strong><br><small>Try: "Add buy groceries" or "Add fix bug to in progress"</small>`;
                    break;
                    
                case 'ready':
                    iconEl.textContent = '‚úÖ';
                    iconEl.classList.remove('recording');
                    statusEl.textContent = 'Got it!';
                    
                    // Parse the transcript to extract task and column
                    const parsed = parseVoiceCommand(voiceTranscript);
                    hintEl.innerHTML = `Task: <strong>${parsed.taskTitle}</strong><br>Column: <strong>${formatColumnName(parsed.column)}</strong>`;
                    createBtn.disabled = false;
                    break;
                    
                case 'no-speech':
                    iconEl.textContent = 'üîá';
                    iconEl.classList.remove('recording');
                    statusEl.textContent = 'No speech detected';
                    hintEl.textContent = 'Click to try again';
                    createBtn.disabled = true;
                    break;
                    
                case 'error':
                    iconEl.textContent = '‚ö†Ô∏è';
                    iconEl.classList.remove('recording');
                    statusEl.textContent = 'Error occurred';
                    hintEl.textContent = 'Please try again';
                    createBtn.disabled = true;
                    break;
                    
                case 'ended':
                    iconEl.textContent = 'üé§';
                    iconEl.classList.remove('recording');
                    if (!voiceTranscript) {
                        statusEl.textContent = 'No speech detected';
                        hintEl.textContent = 'Click the mic to try again';
                    }
                    break;
            }
        }
        
        // Parse voice command to extract task name and optional column
        function parseVoiceCommand(transcript) {
            let taskTitle = transcript.trim();
            let column = voiceTargetColumn;
            
            // Normalize transcript
            const lower = transcript.toLowerCase().trim();
            
            // Pattern: "add [task] to [column]"
            const addToMatch = lower.match(/^add\s+(.+?)\s+to\s+(backlog|in progress|in_progress|review|done|permanent)$/i);
            if (addToMatch) {
                taskTitle = addToMatch[1].trim();
                column = normalizeColumnName(addToMatch[2]);
                return { taskTitle: capitalizeFirst(taskTitle), column };
            }
            
            // Pattern: "add [task]" (uses default column)
            const addMatch = lower.match(/^add\s+(.+)$/i);
            if (addMatch) {
                taskTitle = addMatch[1].trim();
                return { taskTitle: capitalizeFirst(taskTitle), column };
            }
            
            // Pattern: "[task] to [column]"
            const toMatch = lower.match(/^(.+?)\s+to\s+(backlog|in progress|in_progress|review|done|permanent)$/i);
            if (toMatch) {
                taskTitle = toMatch[1].trim();
                column = normalizeColumnName(toMatch[2]);
                return { taskTitle: capitalizeFirst(taskTitle), column };
            }
            
            // No pattern matched - use as-is
            return { taskTitle: capitalizeFirst(taskTitle), column };
        }
        
        // Normalize column name variations
        function normalizeColumnName(name) {
            const lower = name.toLowerCase().trim();
            if (lower === 'in progress' || lower === 'in_progress') return 'in_progress';
            if (lower === 'backlog') return 'backlog';
            if (lower === 'review') return 'review';
            if (lower === 'done') return 'done';
            if (lower === 'permanent') return 'permanent';
            return 'backlog'; // default
        }
        
        // Format column name for display
        function formatColumnName(column) {
            const names = {
                'backlog': 'Backlog',
                'in_progress': 'In Progress',
                'review': 'Review',
                'done': 'Done',
                'permanent': 'Permanent'
            };
            return names[column] || column;
        }
        
        // Capitalize first letter
        function capitalizeFirst(str) {
            if (!str) return str;
            return str.charAt(0).toUpperCase() + str.slice(1);
        }
        
        // Cancel voice input
        function cancelVoiceInput() {
            if (voiceRecognition && voiceIsListening) {
                try {
                    voiceRecognition.stop();
                } catch (e) {}
            }
            
            const modal = document.getElementById('voice-modal');
            if (modal) {
                modal.classList.remove('visible');
            }
            
            voiceTranscript = '';
            voiceIsListening = false;
        }
        
        // Create task from voice transcript
        function createTaskFromVoice() {
            if (!voiceTranscript) {
                showToast('error', 'No transcript to create task from');
                return;
            }
            
            const parsed = parseVoiceCommand(voiceTranscript);
            
            if (!parsed.taskTitle) {
                showToast('error', 'Could not parse task title');
                return;
            }
            
            // Create the task
            const newTask = {
                id: 'task_' + Date.now(),
                title: parsed.taskTitle,
                description: '',
                status: parsed.column,
                project: 'system',
                tags: [],
                subtasks: [],
                priority: 'medium',
                createdAt: new Date().toISOString(),
                createdBy: 'voice'
            };
            
            STATE.data.tasks.push(newTask);
            STATE.data.lastUpdated = new Date().toISOString();
            
            // Close modal
            cancelVoiceInput();
            
            // Render and save
            renderTasks(true);
            autoSave(`üé§ Voice: Create "${parsed.taskTitle}"`);
            
            showToast('success', `Created: "${parsed.taskTitle}" in ${formatColumnName(parsed.column)}`);
        }
        
        // Add keyboard shortcut for voice input (Ctrl+Shift+V)
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.shiftKey && e.key === 'V') {
                e.preventDefault();
                startVoiceInput('backlog');
            }
            
            // Escape to cancel voice input
            if (e.key === 'Escape') {
                const voiceModal = document.getElementById('voice-modal');
                if (voiceModal && voiceModal.classList.contains('visible')) {
                    cancelVoiceInput();
                }
            }
        });
        
        // Modal voice input - directly fills the title field
        let modalVoiceRecognition = null;
        let modalVoiceIsListening = false;
        
        function startModalVoiceInput() {
            if (!isSpeechRecognitionSupported()) {
                showToast('error', 'Voice input not supported. Try Chrome or Edge.');
                return;
            }
            
            const indicator = document.getElementById('modal-recording-indicator');
            const micBtn = document.getElementById('modal-voice-btn');
            const titleInput = document.getElementById('task-title');
            
            // If already listening, stop
            if (modalVoiceIsListening && modalVoiceRecognition) {
                modalVoiceRecognition.stop();
                return;
            }
            
            // Initialize recognition
            if (!modalVoiceRecognition) {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                modalVoiceRecognition = new SpeechRecognition();
                
                modalVoiceRecognition.lang = 'en-US';
                modalVoiceRecognition.continuous = false;
                modalVoiceRecognition.interimResults = true;
                
                modalVoiceRecognition.onstart = () => {
                    modalVoiceIsListening = true;
                    if (indicator) indicator.classList.add('active');
                    if (micBtn) micBtn.classList.add('recording');
                };
                
                modalVoiceRecognition.onresult = (event) => {
                    const result = event.results[event.results.length - 1];
                    let transcript = result[0].transcript;
                    
                    // Remove "add" prefix if present
                    transcript = transcript.replace(/^add\s+/i, '');
                    
                    // Capitalize first letter
                    transcript = capitalizeFirst(transcript.trim());
                    
                    // Update title field
                    if (titleInput) {
                        titleInput.value = transcript;
                    }
                };
                
                modalVoiceRecognition.onerror = (event) => {
                    console.error('Modal voice error:', event.error);
                    if (event.error === 'not-allowed') {
                        showToast('error', 'Microphone access denied');
                    }
                };
                
                modalVoiceRecognition.onend = () => {
                    modalVoiceIsListening = false;
                    if (indicator) indicator.classList.remove('active');
                    if (micBtn) micBtn.classList.remove('recording');
                };
            }
            
            try {
                modalVoiceRecognition.start();
            } catch (e) {
                console.log('Modal recognition error:', e);
            }
        }

        // === VOICE NOTE RECORDING ===
        let voiceNoteMediaRecorder = null;
        let voiceNoteAudioChunks = [];
        let voiceNoteAudioBlob = null;
        let voiceNoteAudioUrl = null;
        let voiceNoteAudio = null;
        let voiceNoteIsRecording = false;
        let voiceNoteTimerInterval = null;
        let voiceNoteStartTime = null;
        let voiceNoteTargetTaskId = null;
        let voiceNoteTranscript = '';
        let voiceNoteTranscriptRecognition = null;
        
        // Audio context for waveform visualization
        let voiceNoteAudioContext = null;
        let voiceNoteAnalyser = null;
        
        // Open voice note modal
        function openVoiceNoteModal(taskId) {
            if (!STATE.user) {
                showToast('error', 'Login to add voice notes');
                return;
            }
            
            voiceNoteTargetTaskId = taskId;
            
            // Update modal title based on context
            const titleEl = document.getElementById('voice-note-modal-title');
            const subtitleEl = document.getElementById('voice-note-modal-subtitle');
            
            if (taskId) {
                const task = STATE.data.tasks.find(t => t.id === taskId);
                titleEl.textContent = 'üéôÔ∏è Add Voice Note';
                subtitleEl.textContent = `To: ${task ? task.title : 'Task'}`;
            } else {
                titleEl.textContent = 'üéôÔ∏è Voice Memo';
                subtitleEl.textContent = 'Record a standalone voice memo';
            }
            
            // Reset UI
            resetVoiceNoteModal();
            
            // Show modal
            document.getElementById('voice-note-modal').classList.add('visible');
        }
        
        // Reset voice note modal to initial state
        function resetVoiceNoteModal() {
            voiceNoteIsRecording = false;
            voiceNoteAudioChunks = [];
            voiceNoteAudioBlob = null;
            voiceNoteTranscript = '';
            
            if (voiceNoteAudioUrl) {
                URL.revokeObjectURL(voiceNoteAudioUrl);
                voiceNoteAudioUrl = null;
            }
            
            if (voiceNoteTimerInterval) {
                clearInterval(voiceNoteTimerInterval);
                voiceNoteTimerInterval = null;
            }
            
            // Reset UI elements
            document.getElementById('voice-note-timer').textContent = '0:00';
            document.getElementById('voice-note-timer').classList.remove('recording');
            document.getElementById('voice-note-record-btn').classList.remove('recording');
            document.getElementById('voice-note-record-icon').textContent = 'üî¥';
            document.getElementById('voice-note-waveform').classList.remove('recording');
            document.getElementById('voice-note-playback').classList.remove('visible');
            document.getElementById('voice-note-save-btn').disabled = true;
            document.getElementById('voice-note-discard-btn').style.display = 'none';
            document.getElementById('voice-note-transcript-preview').style.display = 'none';
        }
        
        // Toggle voice note recording
        async function toggleVoiceNoteRecording() {
            if (voiceNoteIsRecording) {
                stopVoiceNoteRecording();
            } else {
                await startVoiceNoteRecording();
            }
        }
        
        // Start recording
        async function startVoiceNoteRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                // Create MediaRecorder
                const mimeType = MediaRecorder.isTypeSupported('audio/webm;codecs=opus') 
                    ? 'audio/webm;codecs=opus' 
                    : 'audio/webm';
                
                voiceNoteMediaRecorder = new MediaRecorder(stream, { mimeType });
                voiceNoteAudioChunks = [];
                
                voiceNoteMediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        voiceNoteAudioChunks.push(event.data);
                    }
                };
                
                voiceNoteMediaRecorder.onstop = () => {
                    voiceNoteAudioBlob = new Blob(voiceNoteAudioChunks, { type: mimeType });
                    voiceNoteAudioUrl = URL.createObjectURL(voiceNoteAudioBlob);
                    
                    // Create audio element for playback
                    voiceNoteAudio = new Audio(voiceNoteAudioUrl);
                    voiceNoteAudio.onended = () => {
                        document.getElementById('voice-note-play-btn').textContent = '‚ñ∂';
                    };
                    voiceNoteAudio.ontimeupdate = () => {
                        const progress = (voiceNoteAudio.currentTime / voiceNoteAudio.duration) * 100;
                        document.getElementById('voice-note-progress-fill').style.width = `${progress}%`;
                        document.getElementById('voice-note-duration').textContent = formatDuration(voiceNoteAudio.currentTime);
                    };
                    
                    // Stop all tracks
                    stream.getTracks().forEach(track => track.stop());
                    
                    // Show playback controls
                    showVoiceNotePlayback();
                    
                    // Start transcription (optional)
                    transcribeVoiceNote();
                };
                
                // Start recording
                voiceNoteMediaRecorder.start(100); // Collect data every 100ms
                voiceNoteIsRecording = true;
                voiceNoteStartTime = Date.now();
                
                // Update UI
                document.getElementById('voice-note-record-btn').classList.add('recording');
                document.getElementById('voice-note-record-icon').textContent = '‚èπ';
                document.getElementById('voice-note-timer').classList.add('recording');
                document.getElementById('voice-note-waveform').classList.add('recording');
                
                // Start timer
                voiceNoteTimerInterval = setInterval(updateVoiceNoteTimer, 100);
                
            } catch (err) {
                console.error('Failed to start recording:', err);
                showToast('error', 'Could not access microphone. Please allow microphone access.');
            }
        }
        
        // Stop recording
        function stopVoiceNoteRecording() {
            if (voiceNoteMediaRecorder && voiceNoteMediaRecorder.state !== 'inactive') {
                voiceNoteMediaRecorder.stop();
            }
            
            voiceNoteIsRecording = false;
            
            // Stop timer
            if (voiceNoteTimerInterval) {
                clearInterval(voiceNoteTimerInterval);
            }
            
            // Update UI
            document.getElementById('voice-note-record-btn').classList.remove('recording');
            document.getElementById('voice-note-record-icon').textContent = 'üî¥';
            document.getElementById('voice-note-timer').classList.remove('recording');
            document.getElementById('voice-note-waveform').classList.remove('recording');
        }
        
        // Update timer display
        function updateVoiceNoteTimer() {
            const elapsed = (Date.now() - voiceNoteStartTime) / 1000;
            document.getElementById('voice-note-timer').textContent = formatDuration(elapsed);
        }
        
        // Show playback controls
        function showVoiceNotePlayback() {
            document.getElementById('voice-note-playback').classList.add('visible');
            document.getElementById('voice-note-save-btn').disabled = false;
            document.getElementById('voice-note-discard-btn').style.display = 'inline-flex';
            
            // Set duration
            voiceNoteAudio.onloadedmetadata = () => {
                document.getElementById('voice-note-duration').textContent = formatDuration(voiceNoteAudio.duration);
            };
        }
        
        // Toggle playback
        function toggleVoiceNotePlayback() {
            if (!voiceNoteAudio) return;
            
            if (voiceNoteAudio.paused) {
                voiceNoteAudio.play();
                document.getElementById('voice-note-play-btn').textContent = '‚è∏';
            } else {
                voiceNoteAudio.pause();
                document.getElementById('voice-note-play-btn').textContent = '‚ñ∂';
            }
        }
        
        // Seek in voice note
        function seekVoiceNote(event) {
            if (!voiceNoteAudio) return;
            
            const progressBar = event.currentTarget;
            const rect = progressBar.getBoundingClientRect();
            const percent = (event.clientX - rect.left) / rect.width;
            voiceNoteAudio.currentTime = percent * voiceNoteAudio.duration;
        }
        
        // Transcribe voice note using Web Speech API
        function transcribeVoiceNote() {
            if (!isSpeechRecognitionSupported() || !voiceNoteAudioUrl) return;
            
            const transcriptEl = document.getElementById('voice-note-transcript-preview');
            transcriptEl.style.display = 'block';
            transcriptEl.textContent = 'Transcribing... (play audio to transcribe)';
            
            // Note: Web Speech API doesn't support transcribing from audio files directly.
            // This would need a backend service for full transcription.
            // For now, we'll offer manual transcript entry or skip.
            transcriptEl.textContent = 'Voice note recorded. Play to review.';
        }
        
        // Discard voice note
        function discardVoiceNote() {
            resetVoiceNoteModal();
        }
        
        // Cancel voice note modal
        function cancelVoiceNote() {
            if (voiceNoteIsRecording) {
                stopVoiceNoteRecording();
            }
            
            if (voiceNoteAudioUrl) {
                URL.revokeObjectURL(voiceNoteAudioUrl);
            }
            
            document.getElementById('voice-note-modal').classList.remove('visible');
            voiceNoteTargetTaskId = null;
        }
        
        // Save voice note
        async function saveVoiceNote() {
            if (!voiceNoteAudioBlob) {
                showToast('error', 'No recording to save');
                return;
            }
            
            // Convert audio blob to base64
            const base64Audio = await blobToBase64(voiceNoteAudioBlob);
            const duration = voiceNoteAudio ? voiceNoteAudio.duration : 0;
            
            const voiceNote = {
                id: 'vn_' + Date.now(),
                type: 'voice_note',
                audio: base64Audio,
                duration: Math.round(duration),
                transcript: voiceNoteTranscript || null,
                author: STATE.user?.login || 'User',
                createdAt: new Date().toISOString()
            };
            
            if (voiceNoteTargetTaskId) {
                // Add to existing task
                const task = STATE.data.tasks.find(t => t.id === voiceNoteTargetTaskId);
                if (task) {
                    if (!task.comments) task.comments = [];
                    task.comments.push(voiceNote);
                    
                    // Close modal and refresh
                    cancelVoiceNote();
                    renderComments(task);
                    renderTasks();
                    autoSave(`üé§ Voice note on "${task.title}"`);
                    showToast('success', 'Voice note saved!');
                }
            } else {
                // Create standalone voice memo task
                const newTask = {
                    id: 'task_' + Date.now(),
                    title: 'üé§ Voice Memo',
                    description: voiceNoteTranscript || 'Voice memo',
                    status: 'backlog',
                    project: 'system',
                    tags: ['voice-memo'],
                    subtasks: [],
                    priority: 'medium',
                    createdAt: new Date().toISOString(),
                    createdBy: 'voice',
                    comments: [voiceNote]
                };
                
                STATE.data.tasks.push(newTask);
                
                // Close modal and refresh
                cancelVoiceNote();
                renderTasks(true);
                autoSave('üé§ Voice memo created');
                showToast('success', 'Voice memo created!');
            }
        }
        
        // Convert blob to base64
        function blobToBase64(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }
        
        // === VOICE NOTE PLAYBACK IN COMMENTS ===
        let currentPlayingVoiceNote = null;
        let voiceNoteCommentAudios = {};
        
        // Play voice note in comments
        function playVoiceNoteComment(commentIdx, taskId) {
            const task = STATE.data.tasks.find(t => t.id === taskId);
            if (!task || !task.comments || !task.comments[commentIdx]) return;
            
            const comment = task.comments[commentIdx];
            if (comment.type !== 'voice_note' || !comment.audio) return;
            
            // Stop current playing audio if any
            if (currentPlayingVoiceNote !== null && voiceNoteCommentAudios[currentPlayingVoiceNote]) {
                voiceNoteCommentAudios[currentPlayingVoiceNote].pause();
                voiceNoteCommentAudios[currentPlayingVoiceNote].currentTime = 0;
                document.getElementById(`vn-play-${currentPlayingVoiceNote}`).textContent = '‚ñ∂';
            }
            
            // Create or get audio element
            if (!voiceNoteCommentAudios[commentIdx]) {
                voiceNoteCommentAudios[commentIdx] = new Audio(comment.audio);
                
                voiceNoteCommentAudios[commentIdx].onended = () => {
                    document.getElementById(`vn-play-${commentIdx}`).textContent = '‚ñ∂';
                    document.getElementById(`vn-progress-${commentIdx}`).style.width = '0%';
                    currentPlayingVoiceNote = null;
                };
                
                voiceNoteCommentAudios[commentIdx].ontimeupdate = () => {
                    const audio = voiceNoteCommentAudios[commentIdx];
                    const progress = (audio.currentTime / audio.duration) * 100;
                    document.getElementById(`vn-progress-${commentIdx}`).style.width = `${progress}%`;
                    document.getElementById(`vn-duration-${commentIdx}`).textContent = formatDuration(audio.currentTime);
                };
            }
            
            const audio = voiceNoteCommentAudios[commentIdx];
            const playBtn = document.getElementById(`vn-play-${commentIdx}`);
            
            if (audio.paused) {
                audio.play();
                playBtn.textContent = '‚è∏';
                currentPlayingVoiceNote = commentIdx;
            } else {
                audio.pause();
                playBtn.textContent = '‚ñ∂';
                currentPlayingVoiceNote = null;
            }
        }
        
        // Seek voice note in comments
        function seekVoiceNoteComment(event, commentIdx) {
            if (!voiceNoteCommentAudios[commentIdx]) return;
            
            const progressBar = event.currentTarget;
            const rect = progressBar.getBoundingClientRect();
            const percent = (event.clientX - rect.left) / rect.width;
            voiceNoteCommentAudios[commentIdx].currentTime = percent * voiceNoteCommentAudios[commentIdx].duration;
        }
        
        // Add keyboard shortcut for voice memo (Ctrl+Shift+M)
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.shiftKey && e.key === 'M') {
                e.preventDefault();
                openVoiceNoteModal(null);
            }
            
            // Escape to cancel voice note modal
            if (e.key === 'Escape') {
                const voiceNoteModal = document.getElementById('voice-note-modal');
                if (voiceNoteModal && voiceNoteModal.classList.contains('visible')) {
                    cancelVoiceNote();
                }
            }
        });

        // ============================================
        // NOTES + DIGITAL PEN SYSTEM
        // ============================================
        
        // Notes State
        let notesState = {
            currentNoteId: null,
            currentTool: 'pen',
            currentColor: '#000000',
            strokeWidth: 3,
            background: 'plain',
            isDrawing: false,
            penActive: false,  // For palm rejection
            currentStroke: null,
            strokes: [],
            undoStack: [],
            redoStack: [],
            lastPoint: null
        };

        // Canvas references
        let notesCanvas = null;
        let notesCtx = null;

        // Initialize Notes Canvas
        function initNotesCanvas() {
            notesCanvas = document.getElementById('notes-canvas');
            if (!notesCanvas) return;
            
            notesCtx = notesCanvas.getContext('2d');
            resizeNotesCanvas();
            
            // Pointer events for stylus/touch/mouse support
            notesCanvas.addEventListener('pointerdown', handleNotePointerDown);
            notesCanvas.addEventListener('pointermove', handleNotePointerMove);
            notesCanvas.addEventListener('pointerup', handleNotePointerUp);
            notesCanvas.addEventListener('pointerleave', handleNotePointerUp);
            notesCanvas.addEventListener('pointercancel', handleNotePointerUp);
            
            // Prevent default touch behavior (scrolling)
            notesCanvas.addEventListener('touchstart', (e) => e.preventDefault(), { passive: false });
            notesCanvas.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });
            
            // Resize on window resize
            window.addEventListener('resize', resizeNotesCanvas);
        }

        // Resize canvas to fit container
        function resizeNotesCanvas() {
            if (!notesCanvas) return;
            
            const container = document.getElementById('notes-canvas-container');
            if (!container) return;
            
            const rect = container.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            
            // Set display size
            notesCanvas.style.width = rect.width + 'px';
            notesCanvas.style.height = rect.height + 'px';
            
            // Set actual size in memory (scaled for retina)
            notesCanvas.width = rect.width * dpr;
            notesCanvas.height = rect.height * dpr;
            
            // Scale context for retina
            notesCtx.scale(dpr, dpr);
            
            // Redraw
            redrawNotes();
        }

        // Handle pointer down (start stroke)
        function handleNotePointerDown(e) {
            // Palm rejection: if touch and pen is active, ignore
            if (e.pointerType === 'touch' && notesState.penActive) {
                return;
            }
            
            // Track pen state for palm rejection
            if (e.pointerType === 'pen') {
                notesState.penActive = true;
            }
            
            notesState.isDrawing = true;
            
            const point = getCanvasPoint(e);
            point.p = e.pressure || 0.5; // Pressure (0-1)
            
            notesState.currentStroke = {
                points: [point],
                color: notesState.currentTool === 'eraser' ? 'eraser' : notesState.currentColor,
                width: notesState.strokeWidth
            };
            
            notesState.lastPoint = point;
            
            // Capture pointer for smooth tracking
            notesCanvas.setPointerCapture(e.pointerId);
        }

        // Handle pointer move (continue stroke)
        function handleNotePointerMove(e) {
            if (!notesState.isDrawing || !notesState.currentStroke) return;
            
            // Palm rejection
            if (e.pointerType === 'touch' && notesState.penActive) {
                return;
            }
            
            const point = getCanvasPoint(e);
            point.p = e.pressure || 0.5;
            
            notesState.currentStroke.points.push(point);
            
            // Draw the line segment
            if (notesState.currentTool === 'eraser') {
                // For eraser, we'll check intersection on pointer up
                drawEraserPreview(point);
            } else {
                drawLineSegment(notesState.lastPoint, point, notesState.currentStroke);
            }
            
            notesState.lastPoint = point;
        }

        // Handle pointer up (end stroke)
        function handleNotePointerUp(e) {
            if (!notesState.isDrawing) return;
            
            notesState.isDrawing = false;
            
            // Reset pen state
            if (e.pointerType === 'pen') {
                notesState.penActive = false;
            }
            
            if (notesState.currentStroke && notesState.currentStroke.points.length > 1) {
                if (notesState.currentTool === 'eraser') {
                    // Find and remove intersecting strokes
                    eraseStrokes(notesState.currentStroke.points);
                } else {
                    // Add stroke to array
                    notesState.strokes.push(notesState.currentStroke);
                    notesState.undoStack.push({ type: 'add', stroke: notesState.currentStroke });
                    notesState.redoStack = []; // Clear redo on new action
                }
                
                updateUndoRedoButtons();
            }
            
            notesState.currentStroke = null;
            notesState.lastPoint = null;
            
            // Redraw to clean up eraser preview
            if (notesState.currentTool === 'eraser') {
                redrawNotes();
            }
        }

        // Get canvas coordinates from event
        function getCanvasPoint(e) {
            const rect = notesCanvas.getBoundingClientRect();
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        }

        // Draw a line segment with pressure sensitivity
        function drawLineSegment(from, to, stroke) {
            notesCtx.beginPath();
            notesCtx.strokeStyle = stroke.color;
            notesCtx.lineCap = 'round';
            notesCtx.lineJoin = 'round';
            
            // Variable width based on pressure
            const avgPressure = ((from.p || 0.5) + (to.p || 0.5)) / 2;
            notesCtx.lineWidth = stroke.width * (0.5 + avgPressure);
            
            notesCtx.moveTo(from.x, from.y);
            notesCtx.lineTo(to.x, to.y);
            notesCtx.stroke();
        }

        // Draw eraser preview circle
        function drawEraserPreview(point) {
            // Draw a circle to show eraser area
            notesCtx.save();
            notesCtx.globalCompositeOperation = 'source-over';
            notesCtx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
            notesCtx.lineWidth = 2;
            notesCtx.beginPath();
            notesCtx.arc(point.x, point.y, notesState.strokeWidth * 2, 0, Math.PI * 2);
            notesCtx.stroke();
            notesCtx.restore();
        }

        // Erase strokes that intersect with eraser path
        function eraseStrokes(eraserPoints) {
            const eraserRadius = notesState.strokeWidth * 2;
            const strokesToRemove = [];
            
            for (let i = 0; i < notesState.strokes.length; i++) {
                const stroke = notesState.strokes[i];
                let shouldRemove = false;
                
                // Check if any point of this stroke is near the eraser path
                for (const sp of stroke.points) {
                    for (const ep of eraserPoints) {
                        const dist = Math.hypot(sp.x - ep.x, sp.y - ep.y);
                        if (dist < eraserRadius) {
                            shouldRemove = true;
                            break;
                        }
                    }
                    if (shouldRemove) break;
                }
                
                if (shouldRemove) {
                    strokesToRemove.push(i);
                }
            }
            
            // Remove strokes in reverse order
            for (let i = strokesToRemove.length - 1; i >= 0; i--) {
                const idx = strokesToRemove[i];
                const removed = notesState.strokes.splice(idx, 1)[0];
                notesState.undoStack.push({ type: 'remove', stroke: removed, index: idx });
            }
            
            if (strokesToRemove.length > 0) {
                notesState.redoStack = [];
            }
        }

        // Redraw all strokes
        function redrawNotes() {
            if (!notesCtx || !notesCanvas) return;
            
            const dpr = window.devicePixelRatio || 1;
            const w = notesCanvas.width / dpr;
            const h = notesCanvas.height / dpr;
            
            // Clear canvas
            notesCtx.clearRect(0, 0, w, h);
            
            // Draw each stroke
            for (const stroke of notesState.strokes) {
                if (stroke.points.length < 2) continue;
                
                for (let i = 1; i < stroke.points.length; i++) {
                    drawLineSegment(stroke.points[i - 1], stroke.points[i], stroke);
                }
            }
        }

        // Set tool (pen/eraser)
        function setNoteTool(tool) {
            notesState.currentTool = tool;
            
            document.getElementById('tool-pen').classList.toggle('active', tool === 'pen');
            document.getElementById('tool-eraser').classList.toggle('active', tool === 'eraser');
            
            // Change cursor
            if (notesCanvas) {
                notesCanvas.style.cursor = tool === 'eraser' ? 'cell' : 'crosshair';
            }
        }

        // Set stroke color
        function setNoteColor(color) {
            notesState.currentColor = color;
            
            // Update active button
            document.querySelectorAll('.notes-color-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Find and activate the right button
            const colorMap = {
                '#000000': 'color-black',
                '#2563eb': 'color-blue',
                '#dc2626': 'color-red',
                '#16a34a': 'color-green',
                '#eab308': 'color-yellow',
                '#ffffff': 'color-white'
            };
            
            const btnId = colorMap[color];
            if (btnId) {
                document.getElementById(btnId)?.classList.add('active');
            }
            
            // Switch to pen when selecting color
            setNoteTool('pen');
        }

        // Set stroke width
        function setNoteStrokeWidth(width) {
            notesState.strokeWidth = parseInt(width, 10);
            document.getElementById('stroke-width-value').textContent = width + 'px';
        }

        // Set background
        function setNoteBackground(bg) {
            notesState.background = bg;
            
            const container = document.getElementById('notes-canvas-container');
            if (container) {
                container.className = 'notes-canvas-container';
                if (bg !== 'plain') {
                    container.classList.add(bg);
                }
            }
        }

        // Undo
        function noteUndo() {
            if (notesState.undoStack.length === 0) return;
            
            const action = notesState.undoStack.pop();
            
            if (action.type === 'add') {
                // Remove the last added stroke
                const idx = notesState.strokes.indexOf(action.stroke);
                if (idx !== -1) {
                    notesState.strokes.splice(idx, 1);
                }
                notesState.redoStack.push(action);
            } else if (action.type === 'remove') {
                // Re-add the removed stroke at its original position
                notesState.strokes.splice(action.index, 0, action.stroke);
                notesState.redoStack.push(action);
            }
            
            updateUndoRedoButtons();
            redrawNotes();
        }

        // Redo
        function noteRedo() {
            if (notesState.redoStack.length === 0) return;
            
            const action = notesState.redoStack.pop();
            
            if (action.type === 'add') {
                // Re-add the stroke
                notesState.strokes.push(action.stroke);
                notesState.undoStack.push(action);
            } else if (action.type === 'remove') {
                // Remove again
                const idx = notesState.strokes.indexOf(action.stroke);
                if (idx !== -1) {
                    notesState.strokes.splice(idx, 1);
                }
                notesState.undoStack.push(action);
            }
            
            updateUndoRedoButtons();
            redrawNotes();
        }

        // Update undo/redo button states
        function updateUndoRedoButtons() {
            document.getElementById('tool-undo').disabled = notesState.undoStack.length === 0;
            document.getElementById('tool-redo').disabled = notesState.redoStack.length === 0;
        }

        // Clear all strokes
        function noteClear() {
            if (notesState.strokes.length === 0) return;
            
            if (!confirm('Clear all strokes? This cannot be undone.')) return;
            
            notesState.strokes = [];
            notesState.undoStack = [];
            notesState.redoStack = [];
            
            updateUndoRedoButtons();
            redrawNotes();
        }

        // Toggle fullscreen
        function toggleNotesFullscreen() {
            const container = document.getElementById('notes-container');
            container.classList.toggle('fullscreen');
            
            // Resize canvas after toggling
            setTimeout(resizeNotesCanvas, 100);
        }

        // Create new note
        function createNewNote() {
            const noteId = 'note_' + Date.now();
            const newNote = {
                id: noteId,
                title: 'Untitled Note',
                strokes: [],
                background: 'plain',
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString()
            };
            
            // Initialize notes array if needed
            if (!STATE.data.notes) {
                STATE.data.notes = [];
            }
            
            STATE.data.notes.push(newNote);
            
            // Open the editor for this note
            openNoteEditor(noteId);
        }

        // Open note editor
        function openNoteEditor(noteId) {
            const note = STATE.data.notes?.find(n => n.id === noteId);
            if (!note) {
                showToast('error', 'Note not found');
                return;
            }
            
            notesState.currentNoteId = noteId;
            
            // Load note data
            notesState.strokes = note.strokes ? JSON.parse(JSON.stringify(note.strokes)) : [];
            notesState.background = note.background || 'plain';
            notesState.undoStack = [];
            notesState.redoStack = [];
            
            // Update UI
            document.getElementById('note-title-input').value = note.title || 'Untitled Note';
            document.getElementById('note-bg-select').value = notesState.background;
            setNoteBackground(notesState.background);
            
            // Show editor, hide list
            document.getElementById('notes-list').classList.add('hidden');
            document.getElementById('notes-editor').classList.add('active');
            
            // Initialize canvas if needed
            if (!notesCanvas) {
                initNotesCanvas();
            }
            
            // Resize and redraw
            setTimeout(() => {
                resizeNotesCanvas();
                updateUndoRedoButtons();
            }, 50);
        }

        // Close note editor
        function closeNoteEditor() {
            // Auto-save before closing
            saveCurrentNote();
            
            notesState.currentNoteId = null;
            notesState.strokes = [];
            
            // Hide editor, show list
            document.getElementById('notes-editor').classList.remove('active');
            document.getElementById('notes-list').classList.remove('hidden');
            
            // Exit fullscreen if active
            document.getElementById('notes-container').classList.remove('fullscreen');
            
            // Refresh notes list
            renderNotesList();
        }

        // Update note title
        function updateNoteTitle() {
            if (!notesState.currentNoteId) return;
            
            const note = STATE.data.notes?.find(n => n.id === notesState.currentNoteId);
            if (!note) return;
            
            const title = document.getElementById('note-title-input').value.trim() || 'Untitled Note';
            note.title = title;
            note.updatedAt = new Date().toISOString();
        }

        // Save current note
        async function saveCurrentNote() {
            if (!notesState.currentNoteId) return;
            
            const note = STATE.data.notes?.find(n => n.id === notesState.currentNoteId);
            if (!note) return;
            
            // Update note data
            note.title = document.getElementById('note-title-input').value.trim() || 'Untitled Note';
            note.strokes = JSON.parse(JSON.stringify(notesState.strokes));
            note.background = notesState.background;
            note.updatedAt = new Date().toISOString();
            
            // Generate thumbnail
            note.thumbnail = generateNoteThumbnail();
            
            // Save to storage
            await autoSave(`üìù Save note: ${note.title}`);
            
            showToast('success', 'Note saved!');
        }

        // Generate thumbnail from current canvas
        function generateNoteThumbnail() {
            if (!notesCanvas) return null;
            
            // Create a smaller canvas for thumbnail
            const thumbCanvas = document.createElement('canvas');
            thumbCanvas.width = 200;
            thumbCanvas.height = 140;
            const thumbCtx = thumbCanvas.getContext('2d');
            
            // Draw background
            if (notesState.background === 'dark') {
                thumbCtx.fillStyle = '#1a1a1a';
            } else {
                thumbCtx.fillStyle = '#ffffff';
            }
            thumbCtx.fillRect(0, 0, 200, 140);
            
            // Scale and draw the main canvas
            const dpr = window.devicePixelRatio || 1;
            thumbCtx.drawImage(
                notesCanvas, 
                0, 0, notesCanvas.width, notesCanvas.height,
                0, 0, 200, 140
            );
            
            return thumbCanvas.toDataURL('image/png', 0.7);
        }

        // Delete note
        function deleteNote(noteId, event) {
            if (event) {
                event.stopPropagation();
            }
            
            if (!confirm('Delete this note? This cannot be undone.')) return;
            
            const idx = STATE.data.notes?.findIndex(n => n.id === noteId);
            if (idx === -1) return;
            
            const note = STATE.data.notes[idx];
            STATE.data.notes.splice(idx, 1);
            
            autoSave(`üóëÔ∏è Delete note: ${note.title}`);
            renderNotesList();
            
            showToast('success', 'Note deleted');
        }

        // Render notes list
        function renderNotesList() {
            const grid = document.getElementById('notes-grid');
            if (!grid) return;
            
            const notes = STATE.data.notes || [];
            
            // Sort by updated date (newest first)
            const sorted = [...notes].sort((a, b) => 
                new Date(b.updatedAt) - new Date(a.updatedAt)
            );
            
            let html = '';
            
            // New note card
            html += `
                <div class="note-card new-note" onclick="createNewNote()">
                    <div class="new-note-content">
                        <div class="icon">+</div>
                        <div>New Note</div>
                    </div>
                </div>
            `;
            
            // Existing notes
            for (const note of sorted) {
                const date = new Date(note.updatedAt);
                const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                
                const thumbClass = note.background === 'dark' ? 'dark' : 
                                   note.background === 'lined' ? 'lined' :
                                   note.background === 'grid' ? 'grid' : '';
                
                html += `
                    <div class="note-card" onclick="openNoteEditor('${note.id}')" style="position: relative;">
                        <button class="note-card-delete" onclick="deleteNote('${note.id}', event)" title="Delete">√ó</button>
                        <div class="note-card-thumbnail ${thumbClass}">
                            ${note.thumbnail 
                                ? `<img src="${note.thumbnail}" alt="Note thumbnail">`
                                : `<span class="empty-note">üìù</span>`
                            }
                        </div>
                        <div class="note-card-info">
                            <div class="note-card-title">${escapeHtml(note.title)}</div>
                            <div class="note-card-date">${dateStr}</div>
                        </div>
                    </div>
                `;
            }
            
            grid.innerHTML = html;
        }

        // Escape HTML helper
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Keyboard shortcuts for notes
        document.addEventListener('keydown', (e) => {
            // Only handle if notes view is active
            const notesView = document.getElementById('view-notes');
            if (!notesView || notesView.style.display === 'none') return;
            
            // Ctrl+Z: Undo
            if (e.ctrlKey && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                noteUndo();
            }
            
            // Ctrl+Shift+Z or Ctrl+Y: Redo
            if ((e.ctrlKey && e.shiftKey && e.key === 'z') || (e.ctrlKey && e.key === 'y')) {
                e.preventDefault();
                noteRedo();
            }
            
            // Ctrl+S: Save
            if (e.ctrlKey && e.key === 's') {
                e.preventDefault();
                saveCurrentNote();
            }
            
            // Escape: Close editor or exit fullscreen
            if (e.key === 'Escape') {
                const container = document.getElementById('notes-container');
                if (container.classList.contains('fullscreen')) {
                    toggleNotesFullscreen();
                } else if (document.getElementById('notes-editor').classList.contains('active')) {
                    closeNoteEditor();
                }
            }
            
            // P: Pen tool
            if (e.key === 'p' && !e.ctrlKey && !e.metaKey) {
                setNoteTool('pen');
            }
            
            // E: Eraser tool
            if (e.key === 'e' && !e.ctrlKey && !e.metaKey) {
                setNoteTool('eraser');
            }
        });

        // === INIT ===
        document.addEventListener('DOMContentLoaded', async () => {
            // Initialize Lucide icons
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
            
            // Initialize theme system
            initTheme();
            
            // Restore activity sidebar state
            if (localStorage.getItem('activity-collapsed') === 'true') {
                const sidebar = document.getElementById('activity-sidebar');
                const icon = document.getElementById('activity-toggle-icon');
                const reopen = document.getElementById('activity-reopen');
                if (sidebar) sidebar.classList.add('collapsed');
                if (icon) icon.textContent = '‚ò∞';
                if (reopen) reopen.style.display = 'flex';
            }
            // Auth is now handled by checkAuth() in the login script below
        });

        // Pause polling when tab not visible
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden && STATE.token) {
                pollForUpdates();
            }
        });

        // Auto-refresh crons data every 5 minutes for live status updates
        let cronRefreshInterval = null;
        let cronRenderInterval = null;
        
        function startCronAutoRefresh() {
            if (cronRefreshInterval) clearInterval(cronRefreshInterval);
            if (cronRenderInterval) clearInterval(cronRenderInterval);
            
            // Re-render crons every 30 seconds to update running status
            cronRenderInterval = setInterval(() => {
                if (!document.hidden && STATE.crons && STATE.crons.length > 0) {
                    renderCrons();
                }
            }, 30 * 1000); // 30 seconds
            
            // Fetch fresh data from GitHub every 5 minutes
            cronRefreshInterval = setInterval(async () => {
                if (!document.hidden && STATE.token) {
                    try {
                        await loadCronsFromGitHub();
                        renderCrons();
                        console.log('üîÑ Auto-refreshed cron data from GitHub');
                    } catch (e) {
                        console.warn('Auto-refresh crons failed:', e);
                    }
                }
            }, 5 * 60 * 1000); // 5 minutes
        }
        
        // Start auto-refresh after page loads
        setTimeout(startCronAutoRefresh, 10000); // Start 10s after load

        // === VERSION CHECK FUNCTIONS ===
        async function checkForUpdates() {
            try {
                // Add cache-busting to force fresh fetch
                const response = await fetch(`${VERSION_FILE}?t=${Date.now()}`, {
                    cache: 'no-store'
                });
                
                if (!response.ok) return;
                
                const versionData = await response.json();
                
                // First load - store current version
                if (currentVersion === null) {
                    currentVersion = versionData.buildHash;
                    console.log('[Version] Current build:', currentVersion);
                    return;
                }
                
                // Check if version changed
                if (versionData.buildHash !== currentVersion) {
                    console.log('[Version] New version detected:', versionData.buildHash);
                    showVersionBanner();
                }
            } catch (error) {
                console.log('[Version] Check failed:', error.message);
            }
        }

        function showVersionBanner() {
            const banner = document.getElementById('version-banner');
            if (banner) {
                banner.classList.add('visible');
            }
        }

        function dismissVersionBanner() {
            const banner = document.getElementById('version-banner');
            if (banner) {
                banner.classList.remove('visible');
            }
            // Stop checking for this session (user dismissed)
            if (versionCheckInterval) {
                clearInterval(versionCheckInterval);
                versionCheckInterval = null;
            }
        }

        function reloadPage() {
            // Force hard reload to get new version
            window.location.reload(true);
        }

        function startVersionCheck() {
            // Initial check
            checkForUpdates();
            
            // Periodic check
            versionCheckInterval = setInterval(checkForUpdates, VERSION_CHECK_INTERVAL);
            
            // Also check when tab becomes visible again
            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'visible') {
                    checkForUpdates();
                }
            });
        }

        // Start version check after page loads
        setTimeout(startVersionCheck, 5000);

        // Warn before leaving with unsaved changes
        window.addEventListener('beforeunload', (e) => {
            if (STATE.hasUnsavedChanges) {
                e.preventDefault();
                e.returnValue = '';
            }
        });
    </script>

    </div><!-- End Dashboard -->

    <script>
        // === LOGIN/AUTH GATE ===
        async function checkAuth() {
            // PROXY MODE (Option A): no login, no GitHub token.
            // We treat this as a local-only Kanban backed by /api/tasks.
            if (CONFIG.useProxy) {
                STATE.token = null;
                STATE.user = { login: 'local', avatar_url: 'https://github.com/github.png', name: 'Local' };
                showDashboard();
                await loadTasksFromGitHub();
                // Cron UI is a GitHub-only feature in this build; keep it empty in local mode.
                STATE.crons = [];
                renderCrons();
                return;
            }

            // Legacy GitHub-token mode
            // Check both old and new token keys, migrate if needed
            let token = localStorage.getItem('gh_token');
            if (!token) {
                const oldToken = localStorage.getItem('github_token');
                if (oldToken) {
                    // Migrate old token to new key
                    localStorage.setItem('gh_token', oldToken);
                    localStorage.removeItem('github_token');
                    localStorage.removeItem('github_user'); // Clean up old user data
                    token = oldToken;
                    console.log('Migrated token from github_token to gh_token');
                }
            }

            if (!token) {
                showLoginScreen();
                return;
            }

            // Validate token
            try {
                const response = await fetch('https://api.github.com/user', {
                    headers: { 'Authorization': `token ${token}` }
                });

                if (response.ok) {
                    const user = await response.json();
                    STATE.token = token;
                    STATE.user = user;
                    showDashboard();
                    await loadTasksFromGitHub();
                    await loadCronsFromGitHub(); // Load data after auth
                } else {
                    localStorage.removeItem('gh_token');
                    showLoginScreen();
                }
            } catch (e) {
                console.error('Auth check failed:', e);
                showLoginScreen();
            }
        }

        function showLoginScreen() {
            document.getElementById('login-screen').style.display = 'flex';
            document.getElementById('dashboard').style.display = 'none';
        }

        function showDashboard() {
            document.getElementById('login-screen').style.display = 'none';
            document.getElementById('dashboard').style.display = 'block';

            // Update UI with user info
            if (STATE.user) {
                document.getElementById('btn-connect').style.display = 'none';
                document.getElementById('user-profile').style.display = 'flex';
                document.getElementById('user-avatar').src = STATE.user.avatar_url;
                document.getElementById('user-name').textContent = STATE.user.login;
            }
        }

        async function handleLogin() {
            const tokenInput = document.getElementById('login-token-input');
            const token = tokenInput.value.trim();
            const errorDiv = document.getElementById('login-error');
            const loadingDiv = document.getElementById('login-loading');
            const btn = document.getElementById('login-btn');

            if (!token) {
                errorDiv.textContent = 'Please enter a token';
                errorDiv.style.display = 'block';
                return;
            }

            // Show loading
            errorDiv.style.display = 'none';
            loadingDiv.style.display = 'flex';
            btn.disabled = true;

            try {
                const response = await fetch('https://api.github.com/user', {
                    headers: { 'Authorization': `token ${token}` }
                });

                if (response.ok) {
                    const user = await response.json();
                    localStorage.setItem('gh_token', token);
                    STATE.token = token;
                    STATE.user = user;
                    showDashboard();
                    await loadTasksFromGitHub();
                    await loadCronsFromGitHub();
                } else {
                    errorDiv.textContent = 'Invalid token. Please check and try again.';
                    errorDiv.style.display = 'block';
                }
            } catch (e) {
                errorDiv.textContent = 'Connection error. Please try again.';
                errorDiv.style.display = 'block';
            } finally {
                loadingDiv.style.display = 'none';
                btn.disabled = false;
            }
        }

        // Handle Enter key on login input
        document.getElementById('login-token-input').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') handleLogin();
        });

        // Check auth on page load
        checkAuth();

        // ============================
        // CHAT WIDGET (Simple Notes)
        // ============================
        const chatWidget = document.getElementById('chat-widget');
        const chatBody = document.getElementById('chat-body');
        const chatMessages = document.getElementById('chat-messages');
        const chatInput = document.getElementById('chat-input');
        let chatInitialized = false;
        
        function toggleChat() {
            chatWidget.classList.toggle('collapsed');
            const toggle = document.getElementById('chat-toggle');
            toggle.textContent = chatWidget.classList.contains('collapsed') ? '‚ñ≤' : '‚ñº';
        }

        function addMessage(sender, text) {
            const msgDiv = document.createElement('div');
            msgDiv.className = `chat-message ${sender}`;
            msgDiv.textContent = text;
            chatMessages.appendChild(msgDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function sendChatMessage() {
            const text = chatInput.value.trim();
            if (!text) return;

            addMessage('user', text);
            chatInput.value = '';
            
            // Simple feedback - no actual connection
            setTimeout(() => {
                addMessage('system', 'üí° Chat in Telegram: https://t.me/NomuraBot');
            }, 300);
        }

        function handleChatKey(event) {
            if (event.key === 'Enter') {
                sendChatMessage();
            }
        }

        // Initialize chat on page load (once only)
        document.addEventListener('DOMContentLoaded', () => {
            if (chatInitialized) return;
            chatInitialized = true;
            
            // Show welcome message
            chatMessages.innerHTML = '';
            addMessage('bot', 'üëã Hi! Chat with me on Telegram.');
            addMessage('system', 'Telegram: @NomuraBot');
        });
    </script>
    
    <!-- PWA Service Worker Registration -->
    <script>
        // Register Service Worker for offline support
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', async () => {
                try {
                    const registration = await navigator.serviceWorker.register('/sw.js', {
                        scope: '/'
                    });
                    console.log('‚úÖ Service Worker registered:', registration.scope);
                    
                    // Check for updates
                    registration.addEventListener('updatefound', () => {
                        const newWorker = registration.installing;
                        console.log('üîÑ Service Worker update found');
                        
                        newWorker.addEventListener('statechange', () => {
                            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                // New version available - show update banner
                                const versionBanner = document.querySelector('.version-banner');
                                if (versionBanner) {
                                    versionBanner.classList.add('visible');
                                    versionBanner.querySelector('.version-banner-text').innerHTML = 
                                        '<span class="update-icon">üîÑ</span> New version available!';
                                }
                            }
                        });
                    });
                } catch (error) {
                    console.warn('‚ö†Ô∏è Service Worker registration failed:', error);
                }
            });
            
            // Handle controller change (new SW activated)
            navigator.serviceWorker.addEventListener('controllerchange', () => {
                console.log('üîÑ New Service Worker active');
            });
        }
        
        // Install prompt handler for "Add to Home Screen"
        let deferredPrompt;
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            console.log('üì≤ Install prompt available');
            
            // Could show custom install button here
            // For now, browser's native prompt will work
        });
        
        // Track successful installation
        window.addEventListener('appinstalled', () => {
            console.log('‚úÖ Mission Control installed as PWA');
            deferredPrompt = null;
        });
    </script>
</body>
</html>
<!-- test Wed Jan 28 19:46:49 CET 2026 -->
<!-- webhook test 19:54:54 -->
<!-- test 19:55:37 -->
<!-- final test 19:56:16 -->
<!-- ctx debug 19:56:50 -->
<!-- real push test 20:18:59 -->
<!-- FINAL TEST 20:20:41 -->
